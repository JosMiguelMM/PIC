CCS PCH C Compiler, Version 4.093, 51109               08-mar.-22 10:36

               Filename: C:\Proyecto arquitectura c\LCD - teclado\TECLADO__LCD.lst

               ROM used: 6344 bytes (19%)
                         Largest free fragment is 26424
               RAM used: 34 (2%) at main() level
                         45 (2%) worst case
               Stack:    5 locations

*
0000:  GOTO   0A10
.................... #include <18F4550.h> 
.................... //////// Standard Header file for the PIC18F4550 device //////////////// 
.................... #device PIC18F4550 
.................... #list 
....................  
.................... #fuses     HS,NOPROTECT,NOBROWNOUT,NOWDT,PUT,NOCPD,NODEBUG,NOLVP,NOMCLR  
.................... #use       delay(clock=20000000) 
*
04CE:  CLRF   FEA
04D0:  MOVLW  23
04D2:  MOVWF  FE9
04D4:  MOVF   FEF,W
04D6:  BZ    04F2
04D8:  MOVLW  06
04DA:  MOVWF  01
04DC:  CLRF   00
04DE:  DECFSZ 00,F
04E0:  BRA    04DE
04E2:  DECFSZ 01,F
04E4:  BRA    04DC
04E6:  MOVLW  7B
04E8:  MOVWF  00
04EA:  DECFSZ 00,F
04EC:  BRA    04EA
04EE:  DECFSZ FEF,F
04F0:  BRA    04D8
04F2:  RETLW  00
.................... #include   <stdlib.h>           //LIBRERIAS MATEMATICAS IGUAL LA DE ABAJO 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = TRUE, sign = FALSE, point = FALSE; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = FALSE; 
....................          if (c == '+') 
....................          { 
....................             sign = FALSE; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = TRUE; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = TRUE; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = TRUE, sign = FALSE, point = FALSE; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = FALSE; 
....................          if (c == '+') 
....................          { 
....................             sign = FALSE; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = TRUE; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = TRUE; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = TRUE, sign = FALSE, point = FALSE; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = FALSE; 
....................          if (c == '+') 
....................          { 
....................             sign = FALSE; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = TRUE; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = TRUE; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    BYTE t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=TRUE; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = FALSE; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include   <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float32)l); 
....................   res = 32768.0*(float32)l; 
....................   res += (float32)(unsigned int16)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float48)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float48)l); 
....................   res = 32768.0*(float32)l; 
....................   res += (float48)(unsigned int16)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float48)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float64)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float64)l); 
....................   res = 32768.0*(float64)l; 
....................   res += (float64)(unsigned int16)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float64)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y/LN2 - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y/LN2 - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y/LN2 - (float64)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {0.45145214, -9.0558803, 26.940971, -19.860189}; 
.................... float32 const ql[4] = {1.0000000,  -8.1354259, 16.780517, -9.9300943}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................    bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................       res = res*y2 + pl[2]; 
....................       res = res*y2 + pl[3]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + ql[2]; 
....................       r = r*y2 + ql[3]; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................     
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................    
....................       if(bit_test(data2,7)) 
....................          bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................       res = res*y2 + pl[2]; 
....................       res = res*y2 + pl[3]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + ql[2]; 
....................       r = r*y2 + ql[3]; 
....................  
....................       res = y*res/r; 
....................  
....................     data1 = *(((unsigned int8 *)(&x)+5)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+4)); 
....................     if(bit_test (data2,7)) 
....................        bit_set(data1,0); 
....................       
....................     n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................          r = -(float48)-n; 
....................       else 
....................          r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float32 const pl_64[4] = {0.45145214, -9.0558803, 26.940971, -19.860189}; 
.................... float32 const ql_64[4] = {1.0000000,  -8.1354259, 16.780517, -9.9300943}; 
.................... #endif 
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................       bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................     bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................    bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................      bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #define TWOBYPI          0.6366197723675813 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[4] = { 
....................       -0.499999993585, 
....................        0.041666636258, 
....................       -0.0013888361399, 
....................        0.00002476016134 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 3; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[4] = { 
....................       -0.499999993585, 
....................        0.041666636258, 
....................       -0.0013888361399, 
....................        0.00002476016134 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 3; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float48 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p[4] = { 
....................       -0.499999993585, 
....................        0.041666636258, 
....................       -0.0013888361399, 
....................        0.00002476016134 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 3; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #define   LCD_E    PIN_E2 
.................... #define   LCD_CK   PIN_E1 
.................... #define   LCD_DAT  PIN_E0 
.................... #include <LCD4x20_3PIN.c> 
.................... // flex_lcd_3_pins.c 
....................  
.................... //Modificacin de Flex_lcd por Duende_Azul y Akenafab 
.................... //Trabaja con 3 pines y 74VHC164 
.................... //8-Bit Serial-In, Parallel-Out Shift Register 
....................  
.................... //La LCD se usa en modo 4bits 
.................... //Revisar diagrama de conexion Adjunto 
....................  
.................... //No esta habilitada la lectura del LCD 
.................... //RW debe ir a gnd 
....................  
.................... //Definir pines antes de llamar libreria// 
.................... //#define LCD_E     PIN_A0 
.................... //#define LCD_CK    PIN_A1    
.................... //#define LCD_DAT   PIN_A2 
....................  
.................... //======================================== 
.................... int RS_bit; 
.................... #define lcd_type 2        // 0=5x7, 1=5x10, 2=2 lines 
.................... #define lcd_line_two 0x40 // LCD RAM address for the 2nd line 
....................  
....................  
.................... int8 const LCD_INIT_STRING[4] = 
.................... { 
....................  0x20 | (lcd_type << 2), // Func set: 4-bit, 2 lines, 5x8 dots 
....................  0xc,                    // Display on 
....................  1,                      // Clear display 
....................  6                       // Increment cursor 
....................  }; 
.................... BYTE lcdline; 
....................  
.................... //------------------------------------- 
.................... void lcd_send_nibble(int8 nibble, int rs_bit) 
.................... { 
....................  
.................... int x; 
.................... if(RS_bit==1) 
04F4:  DECFSZ 2B,W
04F6:  BRA    04FA
....................    nibble=nibble|0x10; 
04F8:  BSF    2A.4
....................  
.................... for(x=0;x<5;x++){ 
04FA:  CLRF   2C
04FC:  MOVF   2C,W
04FE:  SUBLW  04
0500:  BNC   0524
....................          output_bit(LCD_DAT,shift_right(&nibble,1,0)); 
0502:  BCF    FD8.0
0504:  RRCF   2A,F
0506:  BC    050C
0508:  BCF    F8D.0
050A:  BRA    050E
050C:  BSF    F8D.0
050E:  BCF    F96.0
....................          delay_cycles(1); 
0510:  NOP   
....................          output_low(LCD_CK); 
0512:  BCF    F96.1
0514:  BCF    F8D.1
....................          delay_us(1); 
0516:  BRA    0518
0518:  BRA    051A
051A:  NOP   
....................          output_high(LCD_CK);} 
051C:  BCF    F96.1
051E:  BSF    F8D.1
0520:  INCF   2C,F
0522:  BRA    04FC
....................  
....................  
....................  
....................  output_high(LCD_E); 
0524:  BCF    F96.2
0526:  BSF    F8D.2
....................  delay_us(2); 
0528:  MOVLW  03
052A:  MOVWF  00
052C:  DECFSZ 00,F
052E:  BRA    052C
....................  output_low(LCD_E); 
0530:  BCF    F96.2
0532:  BCF    F8D.2
.................... } 
0534:  RETLW  00
....................  
.................... //----------------------------------- 
.................... //---------------------------------------- 
.................... // Send a byte to the LCD. 
.................... void lcd_send_byte(int8 address, int8 n) 
.................... { 
.................... //output_low(LCD_RS); 
.................... RS_bit=0; 
0536:  CLRF   0B
.................... delay_us(100); 
0538:  MOVLW  A6
053A:  MOVWF  00
053C:  DECFSZ 00,F
053E:  BRA    053C
0540:  NOP   
....................  
....................  
.................... if(address) 
0542:  MOVF   27,F
0544:  BZ    054C
....................    //output_high(LCD_RS); 
....................    RS_bit=1; 
0546:  MOVLW  01
0548:  MOVWF  0B
.................... else 
054A:  BRA    054E
....................    //output_low(LCD_RS); 
....................    RS_bit=0; 
054C:  CLRF   0B
....................  
....................  delay_cycles(1); 
054E:  NOP   
....................  
....................  
.................... output_low(LCD_E); 
0550:  BCF    F96.2
0552:  BCF    F8D.2
....................  
.................... lcd_send_nibble(n >> 4,RS_bit); 
0554:  SWAPF  28,W
0556:  MOVWF  29
0558:  MOVLW  0F
055A:  ANDWF  29,F
055C:  MOVFF  29,2A
0560:  MOVFF  0B,2B
0564:  RCALL  04F4
.................... lcd_send_nibble(n & 0xf,RS_bit); 
0566:  MOVF   28,W
0568:  ANDLW  0F
056A:  MOVWF  29
056C:  MOVWF  2A
056E:  MOVFF  0B,2B
0572:  RCALL  04F4
.................... } 
0574:  RETLW  00
....................  
.................... //---------------------------- 
.................... void lcd_init(void) 
.................... { 
.................... int8 i; 
....................  
.................... //output_low(LCD_RS); 
.................... RS_bit=0; 
0576:  CLRF   0B
....................  
.................... output_low(LCD_E); 
0578:  BCF    F96.2
057A:  BCF    F8D.2
....................  
.................... delay_ms(20); 
057C:  MOVLW  14
057E:  MOVWF  23
0580:  RCALL  04CE
....................  
.................... for(i=0 ;i < 3; i++) 
0582:  CLRF   21
0584:  MOVF   21,W
0586:  SUBLW  02
0588:  BNC   059E
....................    { 
....................     lcd_send_nibble(0x03,RS_bit); 
058A:  MOVLW  03
058C:  MOVWF  2A
058E:  MOVFF  0B,2B
0592:  RCALL  04F4
....................     delay_ms(5); 
0594:  MOVLW  05
0596:  MOVWF  23
0598:  RCALL  04CE
....................    } 
059A:  INCF   21,F
059C:  BRA    0584
....................  
.................... lcd_send_nibble(0x02,RS_bit); 
059E:  MOVLW  02
05A0:  MOVWF  2A
05A2:  MOVFF  0B,2B
05A6:  RCALL  04F4
....................  
.................... for(i=0; i < sizeof(LCD_INIT_STRING); i++) 
05A8:  CLRF   21
05AA:  MOVF   21,W
05AC:  SUBLW  03
05AE:  BNC   05D2
....................    { 
....................     lcd_send_byte(0, LCD_INIT_STRING[i]); 
05B0:  CLRF   03
05B2:  MOVF   21,W
05B4:  MOVFF  FF2,22
05B8:  BCF    FF2.7
05BA:  RCALL  0004
05BC:  BTFSC  22.7
05BE:  BSF    FF2.7
05C0:  MOVWF  22
05C2:  CLRF   27
05C4:  MOVWF  28
05C6:  RCALL  0536
....................  
....................     delay_ms(5); 
05C8:  MOVLW  05
05CA:  MOVWF  23
05CC:  RCALL  04CE
....................      
....................    } 
05CE:  INCF   21,F
05D0:  BRA    05AA
....................  
.................... } 
05D2:  GOTO   0A56 (RETURN)
....................  
.................... //---------------------------- 
....................  
.................... void lcd_gotoxy(int8 x, int8 y) 
.................... { 
.................... int8 address; 
....................  
....................    switch(y) { 
*
05DA:  MOVLW  01
05DC:  SUBWF  24,W
05DE:  ADDLW  FC
05E0:  BC    0600
05E2:  ADDLW  04
05E4:  GOTO   0614
....................      case 1 : address=0x80;break; 
05E8:  MOVLW  80
05EA:  MOVWF  25
05EC:  BRA    0600
....................      case 2 : address=0xc0;break; 
05EE:  MOVLW  C0
05F0:  MOVWF  25
05F2:  BRA    0600
....................      case 3 : address=0x94;break; 
05F4:  MOVLW  94
05F6:  MOVWF  25
05F8:  BRA    0600
....................      case 4 : address=0xd4;break; 
05FA:  MOVLW  D4
05FC:  MOVWF  25
05FE:  BRA    0600
....................    } 
.................... address += x-1; 
0600:  MOVLW  01
0602:  SUBWF  23,W
0604:  ADDWF  25,F
.................... lcd_send_byte(0, 0x80 | address); 
0606:  MOVF   25,W
0608:  IORLW  80
060A:  MOVWF  26
060C:  CLRF   27
060E:  MOVWF  28
0610:  RCALL  0536
.................... } 
0612:  RETLW  00
....................  
.................... //----------------------------- 
.................... void lcd_putc(char c) 
.................... { 
....................  switch(c) 
....................    { 
*
0636:  MOVF   22,W
0638:  XORLW  0C
063A:  BZ    0652
063C:  XORLW  06
063E:  BZ    0666
0640:  XORLW  02
0642:  BZ    0674
0644:  XORLW  6B
0646:  BZ    067E
0648:  XORLW  04
064A:  BZ    0688
064C:  XORLW  0F
064E:  BZ    0692
0650:  BRA    069C
....................     case '\f':                //limpia pantalla 
....................       lcd_send_byte(0,1); 
0652:  CLRF   27
0654:  MOVLW  01
0656:  MOVWF  28
0658:  RCALL  0536
....................       lcdline=1; 
065A:  MOVLW  01
065C:  MOVWF  0C
....................       delay_ms(8); 
065E:  MOVLW  08
0660:  MOVWF  23
0662:  RCALL  04CE
....................       break; 
0664:  BRA    06A8
....................  
....................     case '\n':                //cambio de linea 
....................        lcd_gotoxy(1,++lcdline); 
0666:  INCF   0C,F
0668:  MOVLW  01
066A:  MOVWF  23
066C:  MOVFF  0C,24
0670:  RCALL  05DA
....................        break; 
0672:  BRA    06A8
....................  
....................     case '\b':                //retrocede 1 caracter 
....................        lcd_send_byte(0,0x10); 
0674:  CLRF   27
0676:  MOVLW  10
0678:  MOVWF  28
067A:  RCALL  0536
....................        break; 
067C:  BRA    06A8
....................         
....................     case '\c':                //on display 
....................     lcd_send_byte(0,0x0c); 
067E:  CLRF   27
0680:  MOVLW  0C
0682:  MOVWF  28
0684:  RCALL  0536
....................     break; 
0686:  BRA    06A8
....................     
....................     case '\g':                 
....................     lcd_send_byte(0,0x0f);    // prende cursor y parpadea 
0688:  CLRF   27
068A:  MOVLW  0F
068C:  MOVWF  28
068E:  RCALL  0536
....................     break;   
0690:  BRA    06A8
....................  
....................     case '\h':                //retrocede 1 caracter 
....................     lcd_send_byte(0,0x0f);    // prende cursor y parpadea 
0692:  CLRF   27
0694:  MOVLW  0F
0696:  MOVWF  28
0698:  RCALL  0536
....................     break; 
069A:  BRA    06A8
....................      
....................     default: 
....................        lcd_send_byte(1,c); 
069C:  MOVLW  01
069E:  MOVWF  27
06A0:  MOVFF  22,28
06A4:  RCALL  0536
....................        break; 
06A6:  BRA    06A8
....................    } 
.................... } 
06A8:  RETLW  00
....................  
.................... //------------------------------ 
....................  
.................... void lcd_cursor_vb(short visible, short blink) {  
....................   lcd_send_byte(0, 0xC|(visible<<1)|blink);  
.................... }  
....................  
....................  
.................... #include <KBD18F.c> 
.................... //////////////////////////////////////////////////////////////////////////////////// 
.................... //                                   KBD.C                                        // 
.................... //               FUNCIONES PARA ESCANEO DE UN TECLADO MATRICIAL                   // 
.................... //                         4X4 HEXADECIMAL, EN EL PORTB                           // 
.................... //       kbd_init()       Debe ser invocada antes que las otras funciones.         // 
.................... //       c=lcd_getc(c)    Si h sido presionada una tecla devuelve el caracter c    // 
.................... //                  y lo salva en el char c, sino se presiona una tecla       // 
.................... //                  retorna el valor /0, esta funcin puede invocarse         // 
.................... //                  frecuentemente para no perder teclas pulsadas.            // 
.................... //        NOTA: REQUIERE COLOCAR RESISTENCIAS (2.2K) EN LOS PINES DE COLUMNAS     // 
.................... //               PINES DE COLUMNAS DE RB0(COL0) A RB3(COL3))                   // 
.................... //               PINES DE FILAS DE RB4(ROW0)) A RB7(ROW3))                    //  
.................... //                  MODIF.: ING. FRANK GIRALDO - UD                       // 
.................... //////////////////////////////////////////////////////////////////////////////////// 
.................... /*//////////////////////////////////////////////////////////////////////////////////  
.................... *    RB0 RB1 RB2 RB3    
.................... *     |   |   |   | 
.................... *     c0  c1  c2  c3   
.................... *   | 1 | 2 | 3 | F | r0 - RB4 
.................... *   | 4 | 5 | 6 | E | r1 - RB5 
.................... *   | 7 | 8 | 9 | D | r2 - RB6 
.................... *   | A | 0 | B | C | r3 - RB7 
.................... * 
.................... *   COLUMNS=OUTs 
.................... *   ROWS=INs 
.................... *   SE HABILITAN PULL-UP INTERNAS  
.................... *   SE REQUIERE COLOCAR RESISTENCIAS (2.2K) EN LOS PINES DE COLUMNAS  
.................... * 
.................... */////////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... #byte portkbd = 0XF81                  //portkbd = portB 
.................... //Keypad connection:   (Column 0 es B0) 
.................... //                Bx: 
.................... #define COL0 (0 << 0) 
.................... #define COL1 (0 << 1) 
.................... #define COL2 (0 << 2) 
.................... #define COL3 (0 << 3) 
.................... #define ROW0 (1 << 4) 
.................... #define ROW1 (1 << 5) 
.................... #define ROW2 (1 << 6) 
.................... #define ROW3 (1 << 7) 
.................... #define ALL_ROWS (ROW3|ROW2|ROW1|ROW0) 
.................... #define ALL_PINS (ALL_ROWS|COL3|COL2|COL1|COL0) 
....................  
.................... char const KEYS[4][4] = {{'1','2','3','A'}, 
....................                          {'4','5','6','B'}, 
....................                          {'7','8','9','C'}, 
....................                          {'*','0','#','D'}}; 
....................  
.................... #define KBD_DEBOUNCE_FACTOR 0.2 
.................... // Modifique el valor de temporizacin antirrebote con (KBD_DEBOUNCE_FACTOR = n/333), 
.................... // en donde n es el nmero de veces por segundo en los que ud. invoca 
.................... //la funcin kbd_getc(). 
.................... // 
....................  
.................... void kbd_init(){ 
.................... } 
*
05D6:  GOTO   0A58 (RETURN)
....................  
.................... char kbd_getc( ) 
.................... { 
....................    static BYTE kbd_call_count; 
....................    static short int kbd_down; 
....................    static char last_key; 
....................    static BYTE col; 
....................    BYTE kchar; 
....................    BYTE row; 
....................    port_b_pullups(TRUE); 
*
075A:  BCF    FF1.7
....................    kchar='\0'; 
075C:  CLRF   21
....................  
....................    if(++kbd_call_count>KBD_DEBOUNCE_FACTOR) 
075E:  INCF   0D,F
0760:  CLRF   24
0762:  MOVFF  0D,23
0766:  BRA    06AA
0768:  MOVLW  CD
076A:  MOVWF  26
076C:  MOVLW  CC
076E:  MOVWF  25
0770:  MOVLW  4C
0772:  MOVWF  24
0774:  MOVLW  7C
0776:  MOVWF  23
0778:  MOVFF  03,2A
077C:  MOVFF  02,29
0780:  MOVFF  01,28
0784:  MOVFF  00,27
0788:  BRA    06E2
078A:  BNC   0842
....................    { 
....................        switch (col) 
....................        { 
078C:  MOVF   10,W
078E:  ADDLW  FC
0790:  BC    07C0
0792:  ADDLW  04
0794:  GOTO   0850
....................          case 0   : set_tris_b(ALL_PINS&~COL0); 
0798:  MOVLW  F0
079A:  MOVWF  F93
....................                     portkbd=(0b1110); 
079C:  MOVLW  0E
079E:  MOVWF  F81
....................                     break; 
07A0:  BRA    07C0
....................  
....................          case 1   : set_tris_b(ALL_PINS&~COL1); 
07A2:  MOVLW  F0
07A4:  MOVWF  F93
....................                     portkbd=(0b1101); 
07A6:  MOVLW  0D
07A8:  MOVWF  F81
....................                     break; 
07AA:  BRA    07C0
....................  
....................          case 2   : set_tris_b(ALL_PINS&~COL2); 
07AC:  MOVLW  F0
07AE:  MOVWF  F93
....................                     portkbd=(0b1011); 
07B0:  MOVLW  0B
07B2:  MOVWF  F81
....................                     break; 
07B4:  BRA    07C0
....................  
....................          case 3   : set_tris_b(ALL_PINS&~COL3); 
07B6:  MOVLW  F0
07B8:  MOVWF  F93
....................                     portkbd=(0b0111); 
07BA:  MOVLW  07
07BC:  MOVWF  F81
....................                     break; 
07BE:  BRA    07C0
....................        } 
....................  
....................        if(kbd_down) 
07C0:  BTFSS  0E.0
07C2:  BRA    07D6
....................        { 
....................          if((portkbd & (ALL_ROWS))==(ALL_ROWS)) 
07C4:  MOVF   F81,W
07C6:  ANDLW  F0
07C8:  SUBLW  F0
07CA:  BNZ   07D4
....................          { 
....................            kbd_down=FALSE; 
07CC:  BCF    0E.0
....................            kchar=last_key; 
07CE:  MOVFF  0F,21
....................            last_key='\0'; 
07D2:  CLRF   0F
....................          } 
....................        } 
....................        else 
07D4:  BRA    0840
....................        { 
....................           if((portkbd & (ALL_ROWS))!=(ALL_ROWS)) 
07D6:  MOVF   F81,W
07D8:  ANDLW  F0
07DA:  SUBLW  F0
07DC:  BZ    0836
....................           { 
....................              if((portkbd & ROW0) == 0) 
07DE:  MOVF   F81,W
07E0:  ANDLW  10
07E2:  BNZ   07E8
....................                row = 0; 
07E4:  CLRF   22
....................              else if((portkbd & ROW1) == 0) 
07E6:  BRA    080A
07E8:  MOVF   F81,W
07EA:  ANDLW  20
07EC:  BNZ   07F4
....................                row = 1; 
07EE:  MOVLW  01
07F0:  MOVWF  22
....................              else if((portkbd & ROW2) == 0) 
07F2:  BRA    080A
07F4:  MOVF   F81,W
07F6:  ANDLW  40
07F8:  BNZ   0800
....................                row = 2; 
07FA:  MOVLW  02
07FC:  MOVWF  22
....................              else if((portkbd & ROW3) == 0) 
07FE:  BRA    080A
0800:  MOVF   F81,W
0802:  ANDLW  80
0804:  BNZ   080A
....................                row = 3; 
0806:  MOVLW  03
0808:  MOVWF  22
....................              last_key = KEYS[row][col]; 
080A:  MOVF   22,W
080C:  MULLW  04
080E:  MOVF   FF3,W
0810:  CLRF   24
0812:  MOVWF  23
0814:  CLRF   03
0816:  MOVF   10,W
0818:  ADDWF  23,W
081A:  MOVWF  01
081C:  MOVF   24,W
081E:  ADDWFC 03,F
0820:  MOVF   01,W
0822:  MOVFF  FF2,23
0826:  BCF    FF2.7
0828:  CALL   0018
082C:  BTFSC  23.7
082E:  BSF    FF2.7
0830:  MOVWF  0F
....................              kbd_down = TRUE; 
0832:  BSF    0E.0
....................           } 
....................           else 
0834:  BRA    0840
....................           { 
....................              ++col; 
0836:  INCF   10,F
....................              if(col==4) 
0838:  MOVF   10,W
083A:  SUBLW  04
083C:  BNZ   0840
....................              col=0; 
083E:  CLRF   10
....................           } 
....................        } 
....................       kbd_call_count=0; 
0840:  CLRF   0D
....................    } 
....................   kchar = last_key; 
0842:  MOVFF  0F,21
....................   set_tris_b(ALL_PINS); 
0846:  MOVLW  F0
0848:  MOVWF  F93
....................   return(kchar); 
084A:  MOVFF  21,01
.................... } 
084E:  RETLW  00
....................  
.................... /*char dato; 
.................... char tecla() 
.................... { 
....................    dato='\0'; 
....................    while(dato=='\0') 
....................    { 
....................       dato=kbd_getc(); 
....................       delay_ms(100); 
....................    } 
.................... return dato; 
.................... } */ 
....................  
.................... //#include <DS1307.c> 
....................  
.................... #define SW PIN A5 
.................... //Vamos a nombrar los registros de proposito GRAL 
.................... int i, b, dato, clave[4]; 
.................... char datom; 
.................... float valor; 
.................... short flag; 
.................... long segundos, auxsegundos; 
.................... //long contador; 
....................  
.................... /************************** 
.................... SECCION DE METODOS 
.................... ************************/ 
....................  
.................... void teclado() 
.................... {  
....................     lcd_putc('\f'); 
*
0872:  MOVLW  0C
0874:  MOVWF  22
0876:  RCALL  0636
....................     segundos=0; 
0878:  CLRF   1E
087A:  CLRF   1D
....................     auxsegundos=0; 
087C:  CLRF   20
087E:  CLRF   1F
....................     b=6; 
0880:  MOVLW  06
0882:  MOVWF  12
....................      for(i=0;i<4; i++) 
0884:  CLRF   11
0886:  MOVF   11,W
0888:  SUBLW  03
088A:  BTFSS  FD8.0
088C:  BRA    0988
....................       { 
....................         do{ 
....................             datom=kbd_getc(); // escanea teclado 
088E:  RCALL  075A
0890:  MOVFF  01,18
....................             delay_ms(60); 
0894:  MOVLW  3C
0896:  MOVWF  23
0898:  RCALL  04CE
....................              if(datom!='\0')  //si hay dato valido 
089A:  MOVF   18,F
089C:  BZ    092E
....................               { 
....................                  switch (i+1) 
....................                   { 
089E:  MOVLW  01
08A0:  ADDWF  11,W
08A2:  ADDLW  FF
08A4:  ADDLW  FC
08A6:  BC    0916
08A8:  ADDLW  04
08AA:  GOTO   098C
....................                    case 1: 
....................                    clave[0]=datom-0X30; 
08AE:  MOVLW  30
08B0:  SUBWF  18,W
08B2:  MOVWF  14
....................                    swap(clave[0]); 
08B4:  SWAPF  14,F
....................                    lcd_gotoxy(6,1); 
08B6:  MOVLW  06
08B8:  MOVWF  23
08BA:  MOVLW  01
08BC:  MOVWF  24
08BE:  RCALL  05DA
....................                    printf(lcd_putc,"*"); 
08C0:  MOVLW  2A
08C2:  MOVWF  22
08C4:  RCALL  0636
....................                    delay_ms(50); 
08C6:  MOVLW  32
08C8:  MOVWF  23
08CA:  RCALL  04CE
....................                    break; 
08CC:  BRA    0916
....................            
....................                    case 2: 
....................                    clave[1]=datom-0X30; 
08CE:  MOVLW  30
08D0:  SUBWF  18,W
08D2:  MOVWF  15
....................                    clave[0]=clave[0]+clave[1]; 
08D4:  MOVF   15,W
08D6:  ADDWF  14,F
....................                    printf(lcd_putc,"*"); 
08D8:  MOVLW  2A
08DA:  MOVWF  22
08DC:  RCALL  0636
....................                    delay_ms(50); 
08DE:  MOVLW  32
08E0:  MOVWF  23
08E2:  RCALL  04CE
....................                    break; 
08E4:  BRA    0916
....................               
....................                    case 3: 
....................                    clave[2]=datom-0X30; 
08E6:  MOVLW  30
08E8:  SUBWF  18,W
08EA:  MOVWF  16
....................                    swap(clave[2]); 
08EC:  SWAPF  16,F
....................                    printf(lcd_putc,"*"); 
08EE:  MOVLW  2A
08F0:  MOVWF  22
08F2:  RCALL  0636
....................                    delay_ms(50); 
08F4:  MOVLW  32
08F6:  MOVWF  23
08F8:  RCALL  04CE
....................                    break; 
08FA:  BRA    0916
....................               
....................                    case 4: 
....................                    clave[3]=datom-0X30; 
08FC:  MOVLW  30
08FE:  SUBWF  18,W
0900:  MOVWF  17
....................                    clave[1]=clave[2]+clave[3]; 
0902:  MOVF   17,W
0904:  ADDWF  16,W
0906:  MOVWF  15
....................                    printf(lcd_putc,"*"); 
0908:  MOVLW  2A
090A:  MOVWF  22
090C:  RCALL  0636
....................                    delay_ms(50); 
090E:  MOVLW  32
0910:  MOVWF  23
0912:  RCALL  04CE
....................                    break; 
0914:  BRA    0916
....................                  }  
....................                   i++; 
0916:  INCF   11,F
....................                   delay_ms(500); 
0918:  MOVLW  02
091A:  MOVWF  21
091C:  MOVLW  FA
091E:  MOVWF  23
0920:  RCALL  04CE
0922:  DECFSZ 21,F
0924:  BRA    091C
....................                   auxsegundos=0; 
0926:  CLRF   20
0928:  CLRF   1F
....................                   segundos=0; 
092A:  CLRF   1E
092C:  CLRF   1D
....................            } 
....................            auxsegundos++; 
092E:  INCF   1F,F
0930:  BTFSC  FD8.2
0932:  INCF   20,F
....................            if(auxsegundos > 20) 
0934:  MOVF   20,F
0936:  BNZ   093E
0938:  MOVF   1F,W
093A:  SUBLW  14
093C:  BC    0948
....................             { 
....................               segundos++; 
093E:  INCF   1D,F
0940:  BTFSC  FD8.2
0942:  INCF   1E,F
....................               auxsegundos=0; 
0944:  CLRF   20
0946:  CLRF   1F
....................             } 
....................          
....................       
....................     
....................     }while(i<4 && segundos<6); 
0948:  MOVF   11,W
094A:  SUBLW  03
094C:  BNC   0958
094E:  MOVF   1E,F
0950:  BNZ   0958
0952:  MOVF   1D,W
0954:  SUBLW  05
0956:  BC    088E
....................       clave[i]='#'; 
0958:  CLRF   03
095A:  MOVF   11,W
095C:  ADDLW  14
095E:  MOVWF  FE9
0960:  MOVLW  00
0962:  ADDWFC 03,W
0964:  MOVWF  FEA
0966:  MOVLW  23
0968:  MOVWF  FEF
....................       lcd_gotoxy(b,1); 
096A:  MOVFF  12,23
096E:  MOVLW  01
0970:  MOVWF  24
0972:  RCALL  05DA
....................       printf(lcd_putc,"*") ; 
0974:  MOVLW  2A
0976:  MOVWF  22
0978:  RCALL  0636
....................       b++; 
097A:  INCF   12,F
....................       auxsegundos=0; 
097C:  CLRF   20
097E:  CLRF   1F
....................       segundos=0; 
0980:  CLRF   1E
0982:  CLRF   1D
....................    } 
0984:  INCF   11,F
0986:  BRA    0886
.................... } 
0988:  GOTO   0BA0 (RETURN)
....................  
....................  
.................... void un_digito() 
.................... { lcd_putc('\f'); 
*
09AE:  MOVLW  0C
09B0:  MOVWF  22
09B2:  RCALL  0636
....................   segundos=0; 
09B4:  CLRF   1E
09B6:  CLRF   1D
....................   auxsegundos=0; 
09B8:  CLRF   20
09BA:  CLRF   1F
....................   flag=false; 
09BC:  BCF    0E.1
....................   do{ 
....................       datom=kbd_getc(); 
09BE:  RCALL  075A
09C0:  MOVFF  01,18
....................       delay_ms(60); 
09C4:  MOVLW  3C
09C6:  MOVWF  23
09C8:  RCALL  04CE
....................       if(datom !='\0') 
09CA:  MOVF   18,F
09CC:  BZ    09E6
....................         { 
....................           lcd_gotoxy(8,1);  //coloque el numero digitado  en posicion del LCD 
09CE:  MOVLW  08
09D0:  MOVWF  23
09D2:  MOVLW  01
09D4:  MOVWF  24
09D6:  RCALL  05DA
....................           lcd_putc(datom); //visualice datom 
09D8:  MOVFF  18,22
09DC:  RCALL  0636
....................           datom=datom-0x30; //quitele ASCII 
09DE:  MOVLW  30
09E0:  SUBWF  18,F
....................           flag=true; 
09E2:  BSF    0E.1
....................            
....................         }else { 
09E4:  BRA    0A00
....................                auxsegundos++; 
09E6:  INCF   1F,F
09E8:  BTFSC  FD8.2
09EA:  INCF   20,F
....................                if(auxsegundos>20) 
09EC:  MOVF   20,F
09EE:  BNZ   09F6
09F0:  MOVF   1F,W
09F2:  SUBLW  14
09F4:  BC    0A00
....................                { 
....................                  segundos++; 
09F6:  INCF   1D,F
09F8:  BTFSC  FD8.2
09FA:  INCF   1E,F
....................                  auxsegundos=0; 
09FC:  CLRF   20
09FE:  CLRF   1F
....................                 } 
....................        } 
....................          
....................   }while(segundos<6 && flag==false ); 
0A00:  MOVF   1E,F
0A02:  BNZ   0A0E
0A04:  MOVF   1D,W
0A06:  SUBLW  05
0A08:  BNC   0A0E
0A0A:  BTFSS  0E.1
0A0C:  BRA    09BE
.................... } 
0A0E:  RETLW  00
....................  
....................  
....................    
.................... /************************** 
.................... PROGRAMA PRINCIPAL 
.................... ************************/   
....................  
.................... void main() 
.................... {#zero_ram 
0A10:  CLRF   FF8
0A12:  BCF    FD0.7
0A14:  MOVLW  FE
0A16:  MOVWF  00
0A18:  MOVLW  08
0A1A:  MOVWF  01
0A1C:  MOVLW  02
0A1E:  MOVWF  FE9
0A20:  MOVLW  00
0A22:  MOVWF  FEA
0A24:  CLRF   FEE
0A26:  DECFSZ 00,F
0A28:  BRA    0A24
0A2A:  DECFSZ 01,F
0A2C:  BRA    0A24
0A2E:  CLRF   FEA
0A30:  CLRF   FE9
0A32:  MOVF   FC1,W
0A34:  ANDLW  C0
0A36:  IORLW  0F
0A38:  MOVWF  FC1
0A3A:  MOVLW  07
0A3C:  MOVWF  FB4
0A3E:  CLRF   05
0A40:  CLRF   06
0A42:  CLRF   0D
0A44:  BCF    0E.0
0A46:  CLRF   0F
0A48:  CLRF   10
.................... inicio:                       //etiquetas siempre a la izquierda 
....................     set_tris_A(0x28);         /*0010 1000 EL 28 SALE ES DIVIDIENDO LOS 8BITS EN 4 DIGITOS Y TOMAR A QUE NUMERO CORRESPONCEN 
0A4A:  MOVLW  28
0A4C:  MOVWF  F92
....................     RA0 PIN 2  FREE 
....................     RA1 PIN 3  FREE 
....................     RA2 PIN 4  FREE 
....................     RA3 PIN 5  FREE 
....................     RA4 PIN 6  FREE 
....................     RA5 PIN 7  FREE 
....................     RA6 PIN 14 FREE 
....................     RA7 NO EXISTE */ 
....................      
....................     set_tris_B(0x00); /*0000 0000 EL 28 SALE ES DIVIDIENDO LOS 8BITS EN 4 DIGITOS Y TOMAR A QUE NUMERO CORRESPONCEN 
0A4E:  MOVLW  00
0A50:  MOVWF  F93
....................     RB0 PIN 33  LED1 
....................     RB1 PIN 34  LED2 
....................     RB2 PIN 35  LED4 
....................     RB3 PIN 36  LED5 
....................     RB4 PIN 37  LED6 
....................     RB5 PIN 38  LED7 
....................     RB6 PIN 39  LED8 
....................     RB7 PIN 40  LED8 */ 
....................      
....................     set_tris_D(0x00); /*0000 0000 EL 28 SALE ES DIVIDIENDO LOS 8BITS EN 4 DIGITOS Y TOMAR A QUE NUMERO CORRESPONCEN 
0A52:  MOVWF  F95
....................     RB0 PIN 33  LED1 
....................     RB1 PIN 34  LED2 
....................     RB2 PIN 35  LED4 
....................     RB3 PIN 36  LED5 
....................     RB4 PIN 37  LED6 
....................     RB5 PIN 38  LED7 
....................     RB6 PIN 39  LED8 
....................     RB7 PIN 40  LED8 */ 
....................      
....................     lcd_init(); 
0A54:  BRA    0576
....................     kbd_init(); 
0A56:  BRA    05D6
....................     output_A(0x00);                            //Limpiar el puerto A 
0A58:  CLRF   F92
0A5A:  CLRF   F89
....................     output_B(0x00);                           //Limipiar el puerto B 
0A5C:  CLRF   F93
0A5E:  CLRF   F8A
....................     output_D(0x00);                           //Limipiar el puerto D 
0A60:  CLRF   F95
0A62:  CLRF   F8C
....................     
.................... menu: 
....................    lcd_putc('\f');                            //Limpiar pantalla comando 
0A64:  MOVLW  0C
0A66:  MOVWF  22
0A68:  RCALL  0636
....................    lcd_gotoxy(1,1);                           //escribir en a primera fila primera posicion  
0A6A:  MOVLW  01
0A6C:  MOVWF  23
0A6E:  MOVWF  24
0A70:  RCALL  05DA
....................    lcd_putc("   BIENVENIDOS  ");              //lo que se escribe 
0A72:  CLRF   21
0A74:  MOVF   21,W
0A76:  CALL   0038
0A7A:  IORLW  00
0A7C:  BZ    0A86
0A7E:  INCF   21,F
0A80:  MOVWF  22
0A82:  RCALL  0636
0A84:  BRA    0A74
....................    lcd_gotoxy(1,2);                           //escribir en a primera fila primera posicion  
0A86:  MOVLW  01
0A88:  MOVWF  23
0A8A:  MOVLW  02
0A8C:  MOVWF  24
0A8E:  RCALL  05DA
....................    lcd_putc("ARQ. COMP. TARDE"); 
0A90:  CLRF   21
0A92:  MOVF   21,W
0A94:  CALL   005A
0A98:  IORLW  00
0A9A:  BZ    0AA4
0A9C:  INCF   21,F
0A9E:  MOVWF  22
0AA0:  RCALL  0636
0AA2:  BRA    0A92
....................    delay_ms(3000); 
0AA4:  MOVLW  0C
0AA6:  MOVWF  21
0AA8:  MOVLW  FA
0AAA:  MOVWF  23
0AAC:  RCALL  04CE
0AAE:  DECFSZ 21,F
0AB0:  BRA    0AA8
....................     
....................    lcd_putc('\f');                            //Limpiar pantalla comando 
0AB2:  MOVLW  0C
0AB4:  MOVWF  22
0AB6:  RCALL  0636
....................    lcd_gotoxy(1,1);                           //escribir en a primera fila primera posicion  
0AB8:  MOVLW  01
0ABA:  MOVWF  23
0ABC:  MOVWF  24
0ABE:  RCALL  05DA
....................    lcd_putc("MIGUEL MENDEZ");                 //lo que se escribe 
0AC0:  CLRF   21
0AC2:  MOVF   21,W
0AC4:  CALL   007C
0AC8:  IORLW  00
0ACA:  BZ    0AD4
0ACC:  INCF   21,F
0ACE:  MOVWF  22
0AD0:  RCALL  0636
0AD2:  BRA    0AC2
....................    lcd_gotoxy(1,2);                           //escribir en a primera fila primera posicion  
0AD4:  MOVLW  01
0AD6:  MOVWF  23
0AD8:  MOVLW  02
0ADA:  MOVWF  24
0ADC:  RCALL  05DA
....................    lcd_putc(" DAVID MARTINEZ "); 
0ADE:  CLRF   21
0AE0:  MOVF   21,W
0AE2:  CALL   009A
0AE6:  IORLW  00
0AE8:  BZ    0AF2
0AEA:  INCF   21,F
0AEC:  MOVWF  22
0AEE:  RCALL  0636
0AF0:  BRA    0AE0
....................    //printf(lcd_putc,"\f   MIGUEL MENDEZ\n DAVID MARTINEZ ");// /n pase a sigueinet linea 
....................    delay_ms(3000); 
0AF2:  MOVLW  0C
0AF4:  MOVWF  21
0AF6:  MOVLW  FA
0AF8:  MOVWF  23
0AFA:  RCALL  04CE
0AFC:  DECFSZ 21,F
0AFE:  BRA    0AF6
....................     
....................    lcd_putc('\f');                           //Limpiar pantalla comando 
0B00:  MOVLW  0C
0B02:  MOVWF  22
0B04:  RCALL  0636
....................    lcd_gotoxy(3,1);                          //escribir en a primera fila primera posicion  
0B06:  MOVLW  03
0B08:  MOVWF  23
0B0A:  MOVLW  01
0B0C:  MOVWF  24
0B0E:  RCALL  05DA
....................    lcd_putc("GRUPO");                        //lo que se escribe 
0B10:  CLRF   21
0B12:  MOVF   21,W
0B14:  CALL   00BC
0B18:  IORLW  00
0B1A:  BZ    0B24
0B1C:  INCF   21,F
0B1E:  MOVWF  22
0B20:  RCALL  0636
0B22:  BRA    0B12
....................    lcd_gotoxy(2,2);                          //escribir en a primera fila primera posicion  
0B24:  MOVLW  02
0B26:  MOVWF  23
0B28:  MOVWF  24
0B2A:  RCALL  05DA
....................    lcd_putc(" NUMERO"); 
0B2C:  CLRF   21
0B2E:  MOVF   21,W
0B30:  CALL   00D2
0B34:  IORLW  00
0B36:  BZ    0B40
0B38:  INCF   21,F
0B3A:  MOVWF  22
0B3C:  RCALL  0636
0B3E:  BRA    0B2E
....................    //printf(lcd_putc,"\f        GRUPO   \n       NUMERO    ");// /n pase a sigueinet linea 
....................    delay_ms(3000); 
0B40:  MOVLW  0C
0B42:  MOVWF  21
0B44:  MOVLW  FA
0B46:  MOVWF  23
0B48:  RCALL  04CE
0B4A:  DECFSZ 21,F
0B4C:  BRA    0B44
....................     
....................    lcd_putc('\f');                          //Limpiar pantalla comando 
0B4E:  MOVLW  0C
0B50:  MOVWF  22
0B52:  RCALL  0636
....................    lcd_gotoxy(2,1);                         //escribir en a primera fila primera posicion  
0B54:  MOVLW  02
0B56:  MOVWF  23
0B58:  MOVLW  01
0B5A:  MOVWF  24
0B5C:  RCALL  05DA
....................    lcd_putc("POR FAVOR");                   //lo que se escribe 
0B5E:  CLRF   21
0B60:  MOVF   21,W
0B62:  CALL   00EA
0B66:  IORLW  00
0B68:  BZ    0B72
0B6A:  INCF   21,F
0B6C:  MOVWF  22
0B6E:  RCALL  0636
0B70:  BRA    0B60
....................    lcd_gotoxy(1,2);                         //escribir en a primera fila primera posicion  
0B72:  MOVLW  01
0B74:  MOVWF  23
0B76:  MOVLW  02
0B78:  MOVWF  24
0B7A:  RCALL  05DA
....................    lcd_putc("INGRESE CLAVE"); 
0B7C:  CLRF   21
0B7E:  MOVF   21,W
0B80:  CALL   0104
0B84:  IORLW  00
0B86:  BZ    0B90
0B88:  INCF   21,F
0B8A:  MOVWF  22
0B8C:  RCALL  0636
0B8E:  BRA    0B7E
....................    //printf(lcd_putc,"\f    POR FAVOR   \n INGRESE CLAVE");// /n pase a sigueinet linea 
....................    delay_ms(3000); 
0B90:  MOVLW  0C
0B92:  MOVWF  21
0B94:  MOVLW  FA
0B96:  MOVWF  23
0B98:  RCALL  04CE
0B9A:  DECFSZ 21,F
0B9C:  BRA    0B94
....................     
....................     
....................     
....................     
....................    teclado();                               //clave [0]=0x34, clave[1]=0x78 
0B9E:  BRA    0872
....................    if(clave[0]==0x12 & clave[1]==0x34) 
0BA0:  MOVF   14,W
0BA2:  SUBLW  12
0BA4:  BZ    0BAA
0BA6:  MOVLW  00
0BA8:  BRA    0BAC
0BAA:  MOVLW  01
0BAC:  MOVWF  21
0BAE:  MOVF   15,W
0BB0:  SUBLW  34
0BB2:  BZ    0BB8
0BB4:  MOVLW  00
0BB6:  BRA    0BBA
0BB8:  MOVLW  01
0BBA:  ANDWF  21,W
0BBC:  BTFSC  FD8.2
0BBE:  BRA    0D4C
....................    { 
.................... admin:  
....................       lcd_putc('\f');                          //Limpiar pantalla comando 
0BC0:  MOVLW  0C
0BC2:  MOVWF  22
0BC4:  RCALL  0636
....................       lcd_gotoxy(1,1);                         //escribir en a primera fila primera posicion  
0BC6:  MOVLW  01
0BC8:  MOVWF  23
0BCA:  MOVWF  24
0BCC:  RCALL  05DA
....................       lcd_putc("BIENVENIDOS AL");              //lo que se escribe 
0BCE:  CLRF   21
0BD0:  MOVF   21,W
0BD2:  CALL   0122
0BD6:  IORLW  00
0BD8:  BZ    0BE2
0BDA:  INCF   21,F
0BDC:  MOVWF  22
0BDE:  RCALL  0636
0BE0:  BRA    0BD0
....................       lcd_gotoxy(4,2);                         //escribir en a primera fila primera posicion  
0BE2:  MOVLW  04
0BE4:  MOVWF  23
0BE6:  MOVLW  02
0BE8:  MOVWF  24
0BEA:  RCALL  05DA
....................       lcd_putc(" MENU"); 
0BEC:  CLRF   21
0BEE:  MOVF   21,W
0BF0:  CALL   0142
0BF4:  IORLW  00
0BF6:  BZ    0C00
0BF8:  INCF   21,F
0BFA:  MOVWF  22
0BFC:  RCALL  0636
0BFE:  BRA    0BEE
....................       //printf(lcd_putc,"\f    POR FAVOR   \n INGRESE CLAVE");// /n pase a sigueinet linea 
....................       delay_ms(3000); 
0C00:  MOVLW  0C
0C02:  MOVWF  21
0C04:  MOVLW  FA
0C06:  MOVWF  23
0C08:  RCALL  04CE
0C0A:  DECFSZ 21,F
0C0C:  BRA    0C04
....................       
....................       lcd_putc('\f');                         //Limpiar pantalla comando 
0C0E:  MOVLW  0C
0C10:  MOVWF  22
0C12:  RCALL  0636
....................       lcd_gotoxy(1,1);                        //escribir en a primera fila primera posicion  
0C14:  MOVLW  01
0C16:  MOVWF  23
0C18:  MOVWF  24
0C1A:  RCALL  05DA
....................       lcd_putc("MARQUE 1 PARA EL");           //lo que se escribe 
0C1C:  CLRF   21
0C1E:  MOVF   21,W
0C20:  CALL   0158
0C24:  IORLW  00
0C26:  BZ    0C30
0C28:  INCF   21,F
0C2A:  MOVWF  22
0C2C:  RCALL  0636
0C2E:  BRA    0C1E
....................       lcd_gotoxy(1,2);                        //escribir en a primera fila primera posicion  
0C30:  MOVLW  01
0C32:  MOVWF  23
0C34:  MOVLW  02
0C36:  MOVWF  24
0C38:  RCALL  05DA
....................       lcd_putc("MENU DE DAVID"); 
0C3A:  CLRF   21
0C3C:  MOVF   21,W
0C3E:  CALL   017A
0C42:  IORLW  00
0C44:  BZ    0C4E
0C46:  INCF   21,F
0C48:  MOVWF  22
0C4A:  RCALL  0636
0C4C:  BRA    0C3C
....................       //printf(lcd_putc,"\f    POR FAVOR   \n INGRESE CLAVE");// /n pase a sigueinet linea 
....................       delay_ms(3000); 
0C4E:  MOVLW  0C
0C50:  MOVWF  21
0C52:  MOVLW  FA
0C54:  MOVWF  23
0C56:  RCALL  04CE
0C58:  DECFSZ 21,F
0C5A:  BRA    0C52
....................     
....................       lcd_putc('\f');                         //Limpiar pantalla comando 
0C5C:  MOVLW  0C
0C5E:  MOVWF  22
0C60:  RCALL  0636
....................       lcd_gotoxy(1,1);                        //escribir en a primera fila primera posicion  
0C62:  MOVLW  01
0C64:  MOVWF  23
0C66:  MOVWF  24
0C68:  RCALL  05DA
....................       lcd_putc("MARQUE 2 PARA EL");           //lo que se escribe 
0C6A:  CLRF   21
0C6C:  MOVF   21,W
0C6E:  CALL   0198
0C72:  IORLW  00
0C74:  BZ    0C7E
0C76:  INCF   21,F
0C78:  MOVWF  22
0C7A:  RCALL  0636
0C7C:  BRA    0C6C
....................       lcd_gotoxy(1,2);                        //escribir en a primera fila primera posicion  
0C7E:  MOVLW  01
0C80:  MOVWF  23
0C82:  MOVLW  02
0C84:  MOVWF  24
0C86:  RCALL  05DA
....................       lcd_putc("MENU DE MIGUEL"); 
0C88:  CLRF   21
0C8A:  MOVF   21,W
0C8C:  CALL   01BA
0C90:  IORLW  00
0C92:  BZ    0C9C
0C94:  INCF   21,F
0C96:  MOVWF  22
0C98:  RCALL  0636
0C9A:  BRA    0C8A
....................       //printf(lcd_putc,"\f    POR FAVOR   \n INGRESE CLAVE");// /n pase a sigueinet linea 
....................       delay_ms(3000); 
0C9C:  MOVLW  0C
0C9E:  MOVWF  21
0CA0:  MOVLW  FA
0CA2:  MOVWF  23
0CA4:  RCALL  04CE
0CA6:  DECFSZ 21,F
0CA8:  BRA    0CA0
....................      
....................       lcd_putc('\f');                         //Limpiar pantalla comando 
0CAA:  MOVLW  0C
0CAC:  MOVWF  22
0CAE:  RCALL  0636
....................       lcd_gotoxy(1,1);                        //escribir en a primera fila primera posicion  
0CB0:  MOVLW  01
0CB2:  MOVWF  23
0CB4:  MOVWF  24
0CB6:  RCALL  05DA
....................       lcd_putc("MARQUE 3 PARA ");             //lo que se escribe 
0CB8:  CLRF   21
0CBA:  MOVF   21,W
0CBC:  CALL   01DA
0CC0:  IORLW  00
0CC2:  BZ    0CCC
0CC4:  INCF   21,F
0CC6:  MOVWF  22
0CC8:  RCALL  0636
0CCA:  BRA    0CBA
....................       lcd_gotoxy(1,2);                        //escribir en a primera fila primera posicion  
0CCC:  MOVLW  01
0CCE:  MOVWF  23
0CD0:  MOVLW  02
0CD2:  MOVWF  24
0CD4:  RCALL  05DA
....................       lcd_putc("SALIR"); 
0CD6:  CLRF   21
0CD8:  MOVF   21,W
0CDA:  CALL   01FA
0CDE:  IORLW  00
0CE0:  BZ    0CEA
0CE2:  INCF   21,F
0CE4:  MOVWF  22
0CE6:  RCALL  0636
0CE8:  BRA    0CD8
....................       //printf(lcd_putc,"\f    POR FAVOR   \n INGRESE CLAVE");// /n pase a sigueinet linea 
....................       delay_ms(3000); 
0CEA:  MOVLW  0C
0CEC:  MOVWF  21
0CEE:  MOVLW  FA
0CF0:  MOVWF  23
0CF2:  CALL   04CE
0CF6:  DECFSZ 21,F
0CF8:  BRA    0CEE
....................     
....................     
....................        //bienvenidos al menu del diseador 
....................        //marque 1 para menu de MIGUEL 
....................        //marque 2 para menu de David 
....................        //marque 3 salir  */ 
....................         
....................         
....................      un_digito(); 
0CFA:  RCALL  09AE
....................     if(datom==0x01) 
0CFC:  DECFSZ 18,W
0CFE:  BRA    0D02
....................      { 
....................         goto David; 
0D00:  BRA    12FE
....................      } 
....................      if(datom==0x02) 
0D02:  MOVF   18,W
0D04:  SUBLW  02
0D06:  BNZ   0D0A
....................      { 
....................         goto Miguel; 
0D08:  BRA    0D6C
....................      } 
....................      if(datom==0x03) 
0D0A:  MOVF   18,W
0D0C:  SUBLW  03
0D0E:  BNZ   0D12
....................      { 
....................         reset_cpu();  //salir 
0D10:  RESET
....................      } 
....................      lcd_putc('\f');                        //Limpiar pantalla comando 
0D12:  MOVLW  0C
0D14:  MOVWF  22
0D16:  RCALL  0636
....................      lcd_gotoxy(1,2);                       //escribir en a primera fila primera posicion  
0D18:  MOVLW  01
0D1A:  MOVWF  23
0D1C:  MOVLW  02
0D1E:  MOVWF  24
0D20:  RCALL  05DA
....................      lcd_putc("ERROR DE NUMERO");           //lo que se escribe 
0D22:  CLRF   21
0D24:  MOVF   21,W
0D26:  CALL   0210
0D2A:  IORLW  00
0D2C:  BZ    0D36
0D2E:  INCF   21,F
0D30:  MOVWF  22
0D32:  RCALL  0636
0D34:  BRA    0D24
....................      delay_ms(3000); 
0D36:  MOVLW  0C
0D38:  MOVWF  21
0D3A:  MOVLW  FA
0D3C:  MOVWF  23
0D3E:  CALL   04CE
0D42:  DECFSZ 21,F
0D44:  BRA    0D3A
....................      goto admin; 
0D46:  BRA    0BC0
....................      } else if(clave[0]==0x44 & clave[1]==0x66) 
0D48:  GOTO   18C6
0D4C:  MOVF   14,W
0D4E:  SUBLW  44
0D50:  BZ    0D56
0D52:  MOVLW  00
0D54:  BRA    0D58
0D56:  MOVLW  01
0D58:  MOVWF  21
0D5A:  MOVF   15,W
0D5C:  SUBLW  66
0D5E:  BZ    0D64
0D60:  MOVLW  00
0D62:  BRA    0D66
0D64:  MOVLW  01
0D66:  ANDWF  21,W
0D68:  BTFSC  FD8.2
0D6A:  BRA    12DE
....................     {Miguel: 
....................        /*escribirle al lcd 
....................        bienvenidos al menu del diseador 
....................        marque 1 para cambiar clave 
....................        marque 2 para fecha y hora 
....................        marque 3 para reportes 
....................        marque 4 para motor paso a paso 
....................        marque 5 para servomotor 
....................        marque 6 para cad 
....................        marque 7 para DTMF 
....................        marque 8 para sensores 
....................        marque 9 para salir*/ 
....................       
....................     lcd_putc('\f');                       //Limpiar pantalla comando 
0D6C:  MOVLW  0C
0D6E:  MOVWF  22
0D70:  RCALL  0636
....................     lcd_gotoxy(1,1);                      //escribir en a primera fila primera posicion  
0D72:  MOVLW  01
0D74:  MOVWF  23
0D76:  MOVWF  24
0D78:  RCALL  05DA
....................     lcd_putc("MENU USUAR.");              //lo que se escribe 
0D7A:  CLRF   21
0D7C:  MOVF   21,W
0D7E:  CALL   0230
0D82:  IORLW  00
0D84:  BZ    0D8E
0D86:  INCF   21,F
0D88:  MOVWF  22
0D8A:  RCALL  0636
0D8C:  BRA    0D7C
....................     lcd_gotoxy(1,2);                      //escribir en a primera fila primera posicion  
0D8E:  MOVLW  01
0D90:  MOVWF  23
0D92:  MOVLW  02
0D94:  MOVWF  24
0D96:  RCALL  05DA
....................     lcd_putc("MIGUEL"); 
0D98:  CLRF   21
0D9A:  MOVF   21,W
0D9C:  CALL   024C
0DA0:  IORLW  00
0DA2:  BZ    0DAC
0DA4:  INCF   21,F
0DA6:  MOVWF  22
0DA8:  RCALL  0636
0DAA:  BRA    0D9A
....................     delay_ms(3000);  
0DAC:  MOVLW  0C
0DAE:  MOVWF  21
0DB0:  MOVLW  FA
0DB2:  MOVWF  23
0DB4:  CALL   04CE
0DB8:  DECFSZ 21,F
0DBA:  BRA    0DB0
....................         
....................     lcd_putc('\f');                       //Limpiar pantalla comando 
0DBC:  MOVLW  0C
0DBE:  MOVWF  22
0DC0:  RCALL  0636
....................     lcd_gotoxy(1,1);                      //escribir en a primera fila primera posicion  
0DC2:  MOVLW  01
0DC4:  MOVWF  23
0DC6:  MOVWF  24
0DC8:  RCALL  05DA
....................     lcd_putc("MARQUE NUM PARA");          //lo que se escribe 
0DCA:  CLRF   21
0DCC:  MOVF   21,W
0DCE:  CALL   0264
0DD2:  IORLW  00
0DD4:  BZ    0DDE
0DD6:  INCF   21,F
0DD8:  MOVWF  22
0DDA:  RCALL  0636
0DDC:  BRA    0DCC
....................     lcd_gotoxy(1,2);                      //escribir en a primera fila primera posicion  
0DDE:  MOVLW  01
0DE0:  MOVWF  23
0DE2:  MOVLW  02
0DE4:  MOVWF  24
0DE6:  CALL   05DA
....................     lcd_putc("1 CAMBIAR CLAVE"); 
0DEA:  CLRF   21
0DEC:  MOVF   21,W
0DEE:  CALL   0284
0DF2:  IORLW  00
0DF4:  BZ    0DFE
0DF6:  INCF   21,F
0DF8:  MOVWF  22
0DFA:  RCALL  0636
0DFC:  BRA    0DEC
....................     delay_ms(3000);   
0DFE:  MOVLW  0C
0E00:  MOVWF  21
0E02:  MOVLW  FA
0E04:  MOVWF  23
0E06:  CALL   04CE
0E0A:  DECFSZ 21,F
0E0C:  BRA    0E02
....................      
....................     lcd_putc('\f');                      //Limpiar pantalla comando 
0E0E:  MOVLW  0C
0E10:  MOVWF  22
0E12:  RCALL  0636
....................     lcd_gotoxy(1,1);                     //escribir en a primera fila primera posicion  
0E14:  MOVLW  01
0E16:  MOVWF  23
0E18:  MOVWF  24
0E1A:  CALL   05DA
....................     lcd_putc("2 FECHA Y HORA");          //lo que se escribe 
0E1E:  CLRF   21
0E20:  MOVF   21,W
0E22:  CALL   02A4
0E26:  IORLW  00
0E28:  BZ    0E32
0E2A:  INCF   21,F
0E2C:  MOVWF  22
0E2E:  RCALL  0636
0E30:  BRA    0E20
....................     lcd_gotoxy(1,2);                     //escribir en a primera fila primera posicion  
0E32:  MOVLW  01
0E34:  MOVWF  23
0E36:  MOVLW  02
0E38:  MOVWF  24
0E3A:  CALL   05DA
....................     lcd_putc("3 REPORTES"); 
0E3E:  CLRF   21
0E40:  MOVF   21,W
0E42:  CALL   02C4
0E46:  IORLW  00
0E48:  BZ    0E54
0E4A:  INCF   21,F
0E4C:  MOVWF  22
0E4E:  CALL   0636
0E52:  BRA    0E40
....................     delay_ms(3000); 
0E54:  MOVLW  0C
0E56:  MOVWF  21
0E58:  MOVLW  FA
0E5A:  MOVWF  23
0E5C:  CALL   04CE
0E60:  DECFSZ 21,F
0E62:  BRA    0E58
....................      
....................     lcd_putc('\f');                      //Limpiar pantalla comando 
0E64:  MOVLW  0C
0E66:  MOVWF  22
0E68:  CALL   0636
....................     lcd_gotoxy(1,1);                     //escribir en a primera fila primera posicion  
0E6C:  MOVLW  01
0E6E:  MOVWF  23
0E70:  MOVWF  24
0E72:  CALL   05DA
....................     lcd_putc("4 MOTOR PAS A PA");        //lo que se escribe 
0E76:  CLRF   21
0E78:  MOVF   21,W
0E7A:  CALL   02E0
0E7E:  IORLW  00
0E80:  BZ    0E8C
0E82:  INCF   21,F
0E84:  MOVWF  22
0E86:  CALL   0636
0E8A:  BRA    0E78
....................     lcd_gotoxy(1,2);                     //escribir en a primera fila primera posicion  
0E8C:  MOVLW  01
0E8E:  MOVWF  23
0E90:  MOVLW  02
0E92:  MOVWF  24
0E94:  CALL   05DA
....................     lcd_putc("5 SERVOMOTOR"); 
0E98:  CLRF   21
0E9A:  MOVF   21,W
0E9C:  CALL   0302
0EA0:  IORLW  00
0EA2:  BZ    0EAE
0EA4:  INCF   21,F
0EA6:  MOVWF  22
0EA8:  CALL   0636
0EAC:  BRA    0E9A
....................     delay_ms(3000); 
0EAE:  MOVLW  0C
0EB0:  MOVWF  21
0EB2:  MOVLW  FA
0EB4:  MOVWF  23
0EB6:  CALL   04CE
0EBA:  DECFSZ 21,F
0EBC:  BRA    0EB2
....................      
....................     lcd_putc('\f');                      //Limpiar pantalla comando 
0EBE:  MOVLW  0C
0EC0:  MOVWF  22
0EC2:  CALL   0636
....................     lcd_gotoxy(1,1);                     //escribir en a primera fila primera posicion  
0EC6:  MOVLW  01
0EC8:  MOVWF  23
0ECA:  MOVWF  24
0ECC:  CALL   05DA
....................     lcd_putc("6 CAD");                   //lo que se escribe 
0ED0:  CLRF   21
0ED2:  MOVF   21,W
0ED4:  CALL   0320
0ED8:  IORLW  00
0EDA:  BZ    0EE6
0EDC:  INCF   21,F
0EDE:  MOVWF  22
0EE0:  CALL   0636
0EE4:  BRA    0ED2
....................     lcd_gotoxy(1,2);                     //escribir en a primera fila primera posicion  
0EE6:  MOVLW  01
0EE8:  MOVWF  23
0EEA:  MOVLW  02
0EEC:  MOVWF  24
0EEE:  CALL   05DA
....................     lcd_putc("7 DTMF"); 
0EF2:  CLRF   21
0EF4:  MOVF   21,W
0EF6:  CALL   0336
0EFA:  IORLW  00
0EFC:  BZ    0F08
0EFE:  INCF   21,F
0F00:  MOVWF  22
0F02:  CALL   0636
0F06:  BRA    0EF4
....................     delay_ms(3000); 
0F08:  MOVLW  0C
0F0A:  MOVWF  21
0F0C:  MOVLW  FA
0F0E:  MOVWF  23
0F10:  CALL   04CE
0F14:  DECFSZ 21,F
0F16:  BRA    0F0C
....................      
....................     lcd_putc('\f');                      //Limpiar pantalla comando 
0F18:  MOVLW  0C
0F1A:  MOVWF  22
0F1C:  CALL   0636
....................     lcd_gotoxy(1,1);                     //escribir en a primera fila primera posicion  
0F20:  MOVLW  01
0F22:  MOVWF  23
0F24:  MOVWF  24
0F26:  CALL   05DA
....................     lcd_putc("8 SENSORES");              //lo que se escribe 
0F2A:  CLRF   21
0F2C:  MOVF   21,W
0F2E:  CALL   034E
0F32:  IORLW  00
0F34:  BZ    0F40
0F36:  INCF   21,F
0F38:  MOVWF  22
0F3A:  CALL   0636
0F3E:  BRA    0F2C
....................     lcd_gotoxy(3,2);                     //escribir en a primera fila primera posicion  
0F40:  MOVLW  03
0F42:  MOVWF  23
0F44:  MOVLW  02
0F46:  MOVWF  24
0F48:  CALL   05DA
....................     lcd_putc("9 SALIR"); 
0F4C:  CLRF   21
0F4E:  MOVF   21,W
0F50:  CALL   036A
0F54:  IORLW  00
0F56:  BZ    0F62
0F58:  INCF   21,F
0F5A:  MOVWF  22
0F5C:  CALL   0636
0F60:  BRA    0F4E
....................     delay_ms(3000); 
0F62:  MOVLW  0C
0F64:  MOVWF  21
0F66:  MOVLW  FA
0F68:  MOVWF  23
0F6A:  CALL   04CE
0F6E:  DECFSZ 21,F
0F70:  BRA    0F66
....................      
....................     un_digito(); 
0F72:  RCALL  09AE
....................     if(datom==0x01) 
0F74:  DECFSZ 18,W
0F76:  BRA    0FD6
....................      { 
....................        lcd_putc('\f');                   //Limpiar pantalla comando 
0F78:  MOVLW  0C
0F7A:  MOVWF  22
0F7C:  CALL   0636
....................        lcd_gotoxy(1,1);                  //escribir en a primera fila primera posicion  
0F80:  MOVLW  01
0F82:  MOVWF  23
0F84:  MOVWF  24
0F86:  CALL   05DA
....................        lcd_putc("MEN CAMBIAR CLAV");     //lo que se escribe 
0F8A:  CLRF   21
0F8C:  MOVF   21,W
0F8E:  CALL   0382
0F92:  IORLW  00
0F94:  BZ    0FA0
0F96:  INCF   21,F
0F98:  MOVWF  22
0F9A:  CALL   0636
0F9E:  BRA    0F8C
....................        lcd_gotoxy(3,2);                  //escribir en a primera fila primera posicion  
0FA0:  MOVLW  03
0FA2:  MOVWF  23
0FA4:  MOVLW  02
0FA6:  MOVWF  24
0FA8:  CALL   05DA
....................        lcd_putc("EN CONSTRUCCION"); 
0FAC:  CLRF   21
0FAE:  MOVF   21,W
0FB0:  CALL   03A4
0FB4:  IORLW  00
0FB6:  BZ    0FC2
0FB8:  INCF   21,F
0FBA:  MOVWF  22
0FBC:  CALL   0636
0FC0:  BRA    0FAE
....................        delay_ms(3000); 
0FC2:  MOVLW  0C
0FC4:  MOVWF  21
0FC6:  MOVLW  FA
0FC8:  MOVWF  23
0FCA:  CALL   04CE
0FCE:  DECFSZ 21,F
0FD0:  BRA    0FC6
....................        goto Miguel; 
0FD2:  BRA    0D6C
....................      } 
....................      else if(datom==0x02) 
0FD4:  BRA    12DC
0FD6:  MOVF   18,W
0FD8:  SUBLW  02
0FDA:  BNZ   103A
....................      { 
....................        lcd_putc('\f');                  //Limpiar pantalla comando 
0FDC:  MOVLW  0C
0FDE:  MOVWF  22
0FE0:  CALL   0636
....................        lcd_gotoxy(1,1);                 //escribir en a primera fila primera posicion  
0FE4:  MOVLW  01
0FE6:  MOVWF  23
0FE8:  MOVWF  24
0FEA:  CALL   05DA
....................        lcd_putc("MEN FECHA Y HORA");    //lo que se escribe 
0FEE:  CLRF   21
0FF0:  MOVF   21,W
0FF2:  CALL   03C4
0FF6:  IORLW  00
0FF8:  BZ    1004
0FFA:  INCF   21,F
0FFC:  MOVWF  22
0FFE:  CALL   0636
1002:  BRA    0FF0
....................        lcd_gotoxy(3,2);                 //escribir en a primera fila primera posicion  
1004:  MOVLW  03
1006:  MOVWF  23
1008:  MOVLW  02
100A:  MOVWF  24
100C:  CALL   05DA
....................        lcd_putc("EN CONSTRUCCION"); 
1010:  CLRF   21
1012:  MOVF   21,W
1014:  CALL   03A4
1018:  IORLW  00
101A:  BZ    1026
101C:  INCF   21,F
101E:  MOVWF  22
1020:  CALL   0636
1024:  BRA    1012
....................        delay_ms(3000); 
1026:  MOVLW  0C
1028:  MOVWF  21
102A:  MOVLW  FA
102C:  MOVWF  23
102E:  CALL   04CE
1032:  DECFSZ 21,F
1034:  BRA    102A
....................        goto Miguel; 
1036:  BRA    0D6C
....................      } 
....................     else if(datom==0x03) 
1038:  BRA    12DC
103A:  MOVF   18,W
103C:  SUBLW  03
103E:  BNZ   109E
....................      { 
....................        lcd_putc('\f');                //Limpiar pantalla comando 
1040:  MOVLW  0C
1042:  MOVWF  22
1044:  CALL   0636
....................        lcd_gotoxy(1,1);               //escribir en a primera fila primera posicion  
1048:  MOVLW  01
104A:  MOVWF  23
104C:  MOVWF  24
104E:  CALL   05DA
....................        lcd_putc("MENU REPORTES");     //lo que se escribe 
1052:  CLRF   21
1054:  MOVF   21,W
1056:  CALL   03E6
105A:  IORLW  00
105C:  BZ    1068
105E:  INCF   21,F
1060:  MOVWF  22
1062:  CALL   0636
1066:  BRA    1054
....................        lcd_gotoxy(3,2);               //escribir en a primera fila primera posicion  
1068:  MOVLW  03
106A:  MOVWF  23
106C:  MOVLW  02
106E:  MOVWF  24
1070:  CALL   05DA
....................        lcd_putc("EN CONSTRUCCION"); 
1074:  CLRF   21
1076:  MOVF   21,W
1078:  CALL   03A4
107C:  IORLW  00
107E:  BZ    108A
1080:  INCF   21,F
1082:  MOVWF  22
1084:  CALL   0636
1088:  BRA    1076
....................        delay_ms(3000); 
108A:  MOVLW  0C
108C:  MOVWF  21
108E:  MOVLW  FA
1090:  MOVWF  23
1092:  CALL   04CE
1096:  DECFSZ 21,F
1098:  BRA    108E
....................        goto Miguel; 
109A:  BRA    0D6C
....................      } 
....................     else if(datom==0x04) 
109C:  BRA    12DC
109E:  MOVF   18,W
10A0:  SUBLW  04
10A2:  BNZ   1102
....................      { 
....................        lcd_putc('\f');               //Limpiar pantalla comando 
10A4:  MOVLW  0C
10A6:  MOVWF  22
10A8:  CALL   0636
....................        lcd_gotoxy(1,1);              //escribir en a primera fila primera posicion  
10AC:  MOVLW  01
10AE:  MOVWF  23
10B0:  MOVWF  24
10B2:  CALL   05DA
....................        lcd_putc("MEN MOTOR PAS A."); //lo que se escribe 
10B6:  CLRF   21
10B8:  MOVF   21,W
10BA:  CALL   0404
10BE:  IORLW  00
10C0:  BZ    10CC
10C2:  INCF   21,F
10C4:  MOVWF  22
10C6:  CALL   0636
10CA:  BRA    10B8
....................        lcd_gotoxy(3,2);              //escribir en a primera fila primera posicion  
10CC:  MOVLW  03
10CE:  MOVWF  23
10D0:  MOVLW  02
10D2:  MOVWF  24
10D4:  CALL   05DA
....................        lcd_putc("EN CONSTRUCCION"); 
10D8:  CLRF   21
10DA:  MOVF   21,W
10DC:  CALL   03A4
10E0:  IORLW  00
10E2:  BZ    10EE
10E4:  INCF   21,F
10E6:  MOVWF  22
10E8:  CALL   0636
10EC:  BRA    10DA
....................        delay_ms(3000); 
10EE:  MOVLW  0C
10F0:  MOVWF  21
10F2:  MOVLW  FA
10F4:  MOVWF  23
10F6:  CALL   04CE
10FA:  DECFSZ 21,F
10FC:  BRA    10F2
....................        goto Miguel; 
10FE:  BRA    0D6C
....................      } 
....................      else if(datom==0x05) 
1100:  BRA    12DC
1102:  MOVF   18,W
1104:  SUBLW  05
1106:  BNZ   1166
....................      { 
....................        lcd_putc('\f');              //Limpiar pantalla comando 
1108:  MOVLW  0C
110A:  MOVWF  22
110C:  CALL   0636
....................        lcd_gotoxy(1,1);             //escribir en a primera fila primera posicion  
1110:  MOVLW  01
1112:  MOVWF  23
1114:  MOVWF  24
1116:  CALL   05DA
....................        lcd_putc("MEN SERVOMOTOR");  //lo que se escribe 
111A:  CLRF   21
111C:  MOVF   21,W
111E:  CALL   0426
1122:  IORLW  00
1124:  BZ    1130
1126:  INCF   21,F
1128:  MOVWF  22
112A:  CALL   0636
112E:  BRA    111C
....................        lcd_gotoxy(3,2);             //escribir en a primera fila primera posicion  
1130:  MOVLW  03
1132:  MOVWF  23
1134:  MOVLW  02
1136:  MOVWF  24
1138:  CALL   05DA
....................        lcd_putc("EN CONSTRUCCION"); 
113C:  CLRF   21
113E:  MOVF   21,W
1140:  CALL   03A4
1144:  IORLW  00
1146:  BZ    1152
1148:  INCF   21,F
114A:  MOVWF  22
114C:  CALL   0636
1150:  BRA    113E
....................        delay_ms(3000); 
1152:  MOVLW  0C
1154:  MOVWF  21
1156:  MOVLW  FA
1158:  MOVWF  23
115A:  CALL   04CE
115E:  DECFSZ 21,F
1160:  BRA    1156
....................        goto Miguel; 
1162:  BRA    0D6C
....................      } 
....................    else  if(datom==0x06) 
1164:  BRA    12DC
1166:  MOVF   18,W
1168:  SUBLW  06
116A:  BNZ   11CA
....................      { 
....................        lcd_putc('\f');               //Limpiar pantalla comando 
116C:  MOVLW  0C
116E:  MOVWF  22
1170:  CALL   0636
....................        lcd_gotoxy(1,1);              //escribir en a primera fila primera posicion  
1174:  MOVLW  01
1176:  MOVWF  23
1178:  MOVWF  24
117A:  CALL   05DA
....................        lcd_putc("MENU CAD");         //lo que se escribe 
117E:  CLRF   21
1180:  MOVF   21,W
1182:  CALL   0446
1186:  IORLW  00
1188:  BZ    1194
118A:  INCF   21,F
118C:  MOVWF  22
118E:  CALL   0636
1192:  BRA    1180
....................        lcd_gotoxy(3,2);              //escribir en a primera fila primera posicion  
1194:  MOVLW  03
1196:  MOVWF  23
1198:  MOVLW  02
119A:  MOVWF  24
119C:  CALL   05DA
....................        lcd_putc("EN CONSTRUCCION"); 
11A0:  CLRF   21
11A2:  MOVF   21,W
11A4:  CALL   03A4
11A8:  IORLW  00
11AA:  BZ    11B6
11AC:  INCF   21,F
11AE:  MOVWF  22
11B0:  CALL   0636
11B4:  BRA    11A2
....................        delay_ms(3000); 
11B6:  MOVLW  0C
11B8:  MOVWF  21
11BA:  MOVLW  FA
11BC:  MOVWF  23
11BE:  CALL   04CE
11C2:  DECFSZ 21,F
11C4:  BRA    11BA
....................        goto Miguel; 
11C6:  BRA    0D6C
....................      } 
....................     else if(datom==0x07) 
11C8:  BRA    12DC
11CA:  MOVF   18,W
11CC:  SUBLW  07
11CE:  BNZ   122E
....................      { 
....................        lcd_putc('\f');               //Limpiar pantalla comando 
11D0:  MOVLW  0C
11D2:  MOVWF  22
11D4:  CALL   0636
....................        lcd_gotoxy(1,1);              //escribir en a primera fila primera posicion  
11D8:  MOVLW  01
11DA:  MOVWF  23
11DC:  MOVWF  24
11DE:  CALL   05DA
....................        lcd_putc("MEN DTMF");         //lo que se escribe 
11E2:  CLRF   21
11E4:  MOVF   21,W
11E6:  CALL   0460
11EA:  IORLW  00
11EC:  BZ    11F8
11EE:  INCF   21,F
11F0:  MOVWF  22
11F2:  CALL   0636
11F6:  BRA    11E4
....................        lcd_gotoxy(3,2);              //escribir en a primera fila primera posicion  
11F8:  MOVLW  03
11FA:  MOVWF  23
11FC:  MOVLW  02
11FE:  MOVWF  24
1200:  CALL   05DA
....................        lcd_putc("EN CONSTRUCCION"); 
1204:  CLRF   21
1206:  MOVF   21,W
1208:  CALL   03A4
120C:  IORLW  00
120E:  BZ    121A
1210:  INCF   21,F
1212:  MOVWF  22
1214:  CALL   0636
1218:  BRA    1206
....................        delay_ms(3000); 
121A:  MOVLW  0C
121C:  MOVWF  21
121E:  MOVLW  FA
1220:  MOVWF  23
1222:  CALL   04CE
1226:  DECFSZ 21,F
1228:  BRA    121E
....................       goto Miguel; 
122A:  BRA    0D6C
....................      } 
....................     else if(datom==0x08) 
122C:  BRA    12DC
122E:  MOVF   18,W
1230:  SUBLW  08
1232:  BNZ   1292
....................      { 
....................        lcd_putc('\f');              //Limpiar pantalla comando 
1234:  MOVLW  0C
1236:  MOVWF  22
1238:  CALL   0636
....................        lcd_gotoxy(1,1);             //escribir en a primera fila primera posicion  
123C:  MOVLW  01
123E:  MOVWF  23
1240:  MOVWF  24
1242:  CALL   05DA
....................        lcd_putc("MEN SENSORES");    //lo que se escribe 
1246:  CLRF   21
1248:  MOVF   21,W
124A:  CALL   047A
124E:  IORLW  00
1250:  BZ    125C
1252:  INCF   21,F
1254:  MOVWF  22
1256:  CALL   0636
125A:  BRA    1248
....................        lcd_gotoxy(3,2);             //escribir en a primera fila primera posicion  
125C:  MOVLW  03
125E:  MOVWF  23
1260:  MOVLW  02
1262:  MOVWF  24
1264:  CALL   05DA
....................        lcd_putc("EN CONSTRUCCION"); 
1268:  CLRF   21
126A:  MOVF   21,W
126C:  CALL   03A4
1270:  IORLW  00
1272:  BZ    127E
1274:  INCF   21,F
1276:  MOVWF  22
1278:  CALL   0636
127C:  BRA    126A
....................        delay_ms(3000); 
127E:  MOVLW  0C
1280:  MOVWF  21
1282:  MOVLW  FA
1284:  MOVWF  23
1286:  CALL   04CE
128A:  DECFSZ 21,F
128C:  BRA    1282
....................        goto Miguel; 
128E:  BRA    0D6C
....................      } 
....................     else if(datom==0x09) 
1290:  BRA    12DC
1292:  MOVF   18,W
1294:  SUBLW  09
1296:  BNZ   129C
....................      { 
....................       goto admin; 
1298:  BRA    0BC0
....................      } 
....................      else{ 
129A:  BRA    12DC
....................           lcd_putc('\f');                 //Limpiar pantalla comando 
129C:  MOVLW  0C
129E:  MOVWF  22
12A0:  CALL   0636
....................           lcd_gotoxy(1,2);                //escribir en a primera fila primera posicion  
12A4:  MOVLW  01
12A6:  MOVWF  23
12A8:  MOVLW  02
12AA:  MOVWF  24
12AC:  CALL   05DA
....................           lcd_putc("ERROR DE NUMERO");   //lo que se escribe 
12B0:  CLRF   21
12B2:  MOVF   21,W
12B4:  CALL   0210
12B8:  IORLW  00
12BA:  BZ    12C6
12BC:  INCF   21,F
12BE:  MOVWF  22
12C0:  CALL   0636
12C4:  BRA    12B2
....................           delay_ms(3000); 
12C6:  MOVLW  0C
12C8:  MOVWF  21
12CA:  MOVLW  FA
12CC:  MOVWF  23
12CE:  CALL   04CE
12D2:  DECFSZ 21,F
12D4:  BRA    12CA
....................           goto menu; 
12D6:  GOTO   0A64
....................      goto admin; 
12DA:  BRA    0BC0
....................      } 
....................      } 
....................    
....................     else if(clave[0]==0x33 & clave[1]==0x55) 
12DC:  BRA    18C6
12DE:  MOVF   14,W
12E0:  SUBLW  33
12E2:  BZ    12E8
12E4:  MOVLW  00
12E6:  BRA    12EA
12E8:  MOVLW  01
12EA:  MOVWF  21
12EC:  MOVF   15,W
12EE:  SUBLW  55
12F0:  BZ    12F6
12F2:  MOVLW  00
12F4:  BRA    12F8
12F6:  MOVLW  01
12F8:  ANDWF  21,W
12FA:  BTFSC  FD8.2
12FC:  BRA    1888
....................     {David: 
....................        /*escribirle al lcd 
....................        bienvenidos al menu del diseador 
....................        marque 1 para cambiar clave 
....................        marque 2 para fecha y hora 
....................        marque 3 para reportes 
....................        marque 4 para motor paso a paso 
....................        marque 5 para servomotor 
....................        marque 6 para cad 
....................        marque 7 para DTMF 
....................        marque 8 para sensores 
....................        marque 9 para salir*/ 
....................       
....................     lcd_putc('\f');                       //Limpiar pantalla comando 
12FE:  MOVLW  0C
1300:  MOVWF  22
1302:  CALL   0636
....................     lcd_gotoxy(1,1);                      //escribir en a primera fila primera posicion  
1306:  MOVLW  01
1308:  MOVWF  23
130A:  MOVWF  24
130C:  CALL   05DA
....................     lcd_putc("MENU USUAR.");              //lo que se escribe 
1310:  CLRF   21
1312:  MOVF   21,W
1314:  CALL   0230
1318:  IORLW  00
131A:  BZ    1326
131C:  INCF   21,F
131E:  MOVWF  22
1320:  CALL   0636
1324:  BRA    1312
....................     lcd_gotoxy(4,2);                      //escribir en a primera fila primera posicion  
1326:  MOVLW  04
1328:  MOVWF  23
132A:  MOVLW  02
132C:  MOVWF  24
132E:  CALL   05DA
....................     lcd_putc("DAVID"); 
1332:  CLRF   21
1334:  MOVF   21,W
1336:  CALL   0498
133A:  IORLW  00
133C:  BZ    1348
133E:  INCF   21,F
1340:  MOVWF  22
1342:  CALL   0636
1346:  BRA    1334
....................     delay_ms(3000);  
1348:  MOVLW  0C
134A:  MOVWF  21
134C:  MOVLW  FA
134E:  MOVWF  23
1350:  CALL   04CE
1354:  DECFSZ 21,F
1356:  BRA    134C
....................         
....................     lcd_putc('\f');                       //Limpiar pantalla comando 
1358:  MOVLW  0C
135A:  MOVWF  22
135C:  CALL   0636
....................     lcd_gotoxy(1,1);                      //escribir en a primera fila primera posicion  
1360:  MOVLW  01
1362:  MOVWF  23
1364:  MOVWF  24
1366:  CALL   05DA
....................     lcd_putc("MARQUE NUM PARA");          //lo que se escribe 
136A:  CLRF   21
136C:  MOVF   21,W
136E:  CALL   0264
1372:  IORLW  00
1374:  BZ    1380
1376:  INCF   21,F
1378:  MOVWF  22
137A:  CALL   0636
137E:  BRA    136C
....................     lcd_gotoxy(1,2);                      //escribir en a primera fila primera posicion  
1380:  MOVLW  01
1382:  MOVWF  23
1384:  MOVLW  02
1386:  MOVWF  24
1388:  CALL   05DA
....................     lcd_putc("1 CAMBIAR CLAVE"); 
138C:  CLRF   21
138E:  MOVF   21,W
1390:  CALL   0284
1394:  IORLW  00
1396:  BZ    13A2
1398:  INCF   21,F
139A:  MOVWF  22
139C:  CALL   0636
13A0:  BRA    138E
....................     delay_ms(3000);   
13A2:  MOVLW  0C
13A4:  MOVWF  21
13A6:  MOVLW  FA
13A8:  MOVWF  23
13AA:  CALL   04CE
13AE:  DECFSZ 21,F
13B0:  BRA    13A6
....................      
....................     lcd_putc('\f');                      //Limpiar pantalla comando 
13B2:  MOVLW  0C
13B4:  MOVWF  22
13B6:  CALL   0636
....................     lcd_gotoxy(1,1);                     //escribir en a primera fila primera posicion  
13BA:  MOVLW  01
13BC:  MOVWF  23
13BE:  MOVWF  24
13C0:  CALL   05DA
....................     lcd_putc("2 FECHA Y HORA");          //lo que se escribe 
13C4:  CLRF   21
13C6:  MOVF   21,W
13C8:  CALL   02A4
13CC:  IORLW  00
13CE:  BZ    13DA
13D0:  INCF   21,F
13D2:  MOVWF  22
13D4:  CALL   0636
13D8:  BRA    13C6
....................     lcd_gotoxy(1,2);                     //escribir en a primera fila primera posicion  
13DA:  MOVLW  01
13DC:  MOVWF  23
13DE:  MOVLW  02
13E0:  MOVWF  24
13E2:  CALL   05DA
....................     lcd_putc("3 REPORTES"); 
13E6:  CLRF   21
13E8:  MOVF   21,W
13EA:  CALL   02C4
13EE:  IORLW  00
13F0:  BZ    13FC
13F2:  INCF   21,F
13F4:  MOVWF  22
13F6:  CALL   0636
13FA:  BRA    13E8
....................     delay_ms(3000); 
13FC:  MOVLW  0C
13FE:  MOVWF  21
1400:  MOVLW  FA
1402:  MOVWF  23
1404:  CALL   04CE
1408:  DECFSZ 21,F
140A:  BRA    1400
....................      
....................     lcd_putc('\f');                     //Limpiar pantalla comando 
140C:  MOVLW  0C
140E:  MOVWF  22
1410:  CALL   0636
....................     lcd_gotoxy(1,1);                    //escribir en a primera fila primera posicion  
1414:  MOVLW  01
1416:  MOVWF  23
1418:  MOVWF  24
141A:  CALL   05DA
....................     lcd_putc("4 MOTOR PAS A PA");       //lo que se escribe 
141E:  CLRF   21
1420:  MOVF   21,W
1422:  CALL   02E0
1426:  IORLW  00
1428:  BZ    1434
142A:  INCF   21,F
142C:  MOVWF  22
142E:  CALL   0636
1432:  BRA    1420
....................     lcd_gotoxy(1,2);                     //escribir en a primera fila primera posicion  
1434:  MOVLW  01
1436:  MOVWF  23
1438:  MOVLW  02
143A:  MOVWF  24
143C:  CALL   05DA
....................     lcd_putc("5 SERVOMOTOR"); 
1440:  CLRF   21
1442:  MOVF   21,W
1444:  CALL   0302
1448:  IORLW  00
144A:  BZ    1456
144C:  INCF   21,F
144E:  MOVWF  22
1450:  CALL   0636
1454:  BRA    1442
....................     delay_ms(3000); 
1456:  MOVLW  0C
1458:  MOVWF  21
145A:  MOVLW  FA
145C:  MOVWF  23
145E:  CALL   04CE
1462:  DECFSZ 21,F
1464:  BRA    145A
....................      
....................     lcd_putc('\f');                      //Limpiar pantalla comando 
1466:  MOVLW  0C
1468:  MOVWF  22
146A:  CALL   0636
....................     lcd_gotoxy(1,1);                     //escribir en a primera fila primera posicion  
146E:  MOVLW  01
1470:  MOVWF  23
1472:  MOVWF  24
1474:  CALL   05DA
....................     lcd_putc("6 CAD");                   //lo que se escribe 
1478:  CLRF   21
147A:  MOVF   21,W
147C:  CALL   0320
1480:  IORLW  00
1482:  BZ    148E
1484:  INCF   21,F
1486:  MOVWF  22
1488:  CALL   0636
148C:  BRA    147A
....................     lcd_gotoxy(1,2);                     //escribir en a primera fila primera posicion  
148E:  MOVLW  01
1490:  MOVWF  23
1492:  MOVLW  02
1494:  MOVWF  24
1496:  CALL   05DA
....................     lcd_putc("7 DTMF"); 
149A:  CLRF   21
149C:  MOVF   21,W
149E:  CALL   0336
14A2:  IORLW  00
14A4:  BZ    14B0
14A6:  INCF   21,F
14A8:  MOVWF  22
14AA:  CALL   0636
14AE:  BRA    149C
....................     delay_ms(3000); 
14B0:  MOVLW  0C
14B2:  MOVWF  21
14B4:  MOVLW  FA
14B6:  MOVWF  23
14B8:  CALL   04CE
14BC:  DECFSZ 21,F
14BE:  BRA    14B4
....................      
....................     lcd_putc('\f');                      //Limpiar pantalla comando 
14C0:  MOVLW  0C
14C2:  MOVWF  22
14C4:  CALL   0636
....................     lcd_gotoxy(1,1);                     //escribir en a primera fila primera posicion  
14C8:  MOVLW  01
14CA:  MOVWF  23
14CC:  MOVWF  24
14CE:  CALL   05DA
....................     lcd_putc("8 SENSORES");              //lo que se escribe 
14D2:  CLRF   21
14D4:  MOVF   21,W
14D6:  CALL   034E
14DA:  IORLW  00
14DC:  BZ    14E8
14DE:  INCF   21,F
14E0:  MOVWF  22
14E2:  CALL   0636
14E6:  BRA    14D4
....................     lcd_gotoxy(3,2);                     //escribir en a primera fila primera posicion  
14E8:  MOVLW  03
14EA:  MOVWF  23
14EC:  MOVLW  02
14EE:  MOVWF  24
14F0:  CALL   05DA
....................     lcd_putc("9 SALIR"); 
14F4:  CLRF   21
14F6:  MOVF   21,W
14F8:  CALL   036A
14FC:  IORLW  00
14FE:  BZ    150A
1500:  INCF   21,F
1502:  MOVWF  22
1504:  CALL   0636
1508:  BRA    14F6
....................     delay_ms(3000); 
150A:  MOVLW  0C
150C:  MOVWF  21
150E:  MOVLW  FA
1510:  MOVWF  23
1512:  CALL   04CE
1516:  DECFSZ 21,F
1518:  BRA    150E
....................      
....................     un_digito(); 
151A:  CALL   09AE
....................     if(datom==0x01) 
151E:  DECFSZ 18,W
1520:  BRA    1580
....................      { 
....................        lcd_putc('\f');                   //Limpiar pantalla comando 
1522:  MOVLW  0C
1524:  MOVWF  22
1526:  CALL   0636
....................        lcd_gotoxy(1,1);                  //escribir en a primera fila primera posicion  
152A:  MOVLW  01
152C:  MOVWF  23
152E:  MOVWF  24
1530:  CALL   05DA
....................        lcd_putc("MEN CAMBIAR CLAV");     //lo que se escribe 
1534:  CLRF   21
1536:  MOVF   21,W
1538:  CALL   0382
153C:  IORLW  00
153E:  BZ    154A
1540:  INCF   21,F
1542:  MOVWF  22
1544:  CALL   0636
1548:  BRA    1536
....................        lcd_gotoxy(3,2);                  //escribir en a primera fila primera posicion  
154A:  MOVLW  03
154C:  MOVWF  23
154E:  MOVLW  02
1550:  MOVWF  24
1552:  CALL   05DA
....................        lcd_putc("EN CONSTRUCCION"); 
1556:  CLRF   21
1558:  MOVF   21,W
155A:  CALL   03A4
155E:  IORLW  00
1560:  BZ    156C
1562:  INCF   21,F
1564:  MOVWF  22
1566:  CALL   0636
156A:  BRA    1558
....................        delay_ms(3000);  
156C:  MOVLW  0C
156E:  MOVWF  21
1570:  MOVLW  FA
1572:  MOVWF  23
1574:  CALL   04CE
1578:  DECFSZ 21,F
157A:  BRA    1570
....................        goto David; 
157C:  BRA    12FE
....................      } 
....................      else if(datom==0x02) 
157E:  BRA    1886
1580:  MOVF   18,W
1582:  SUBLW  02
1584:  BNZ   15E4
....................      { 
....................        lcd_putc('\f');                  //Limpiar pantalla comando 
1586:  MOVLW  0C
1588:  MOVWF  22
158A:  CALL   0636
....................        lcd_gotoxy(1,1);                 //escribir en a primera fila primera posicion  
158E:  MOVLW  01
1590:  MOVWF  23
1592:  MOVWF  24
1594:  CALL   05DA
....................        lcd_putc("MEN FECHA Y HORA");    //lo que se escribe 
1598:  CLRF   21
159A:  MOVF   21,W
159C:  CALL   03C4
15A0:  IORLW  00
15A2:  BZ    15AE
15A4:  INCF   21,F
15A6:  MOVWF  22
15A8:  CALL   0636
15AC:  BRA    159A
....................        lcd_gotoxy(3,2);                 //escribir en a primera fila primera posicion  
15AE:  MOVLW  03
15B0:  MOVWF  23
15B2:  MOVLW  02
15B4:  MOVWF  24
15B6:  CALL   05DA
....................        lcd_putc("EN CONSTRUCCION"); 
15BA:  CLRF   21
15BC:  MOVF   21,W
15BE:  CALL   03A4
15C2:  IORLW  00
15C4:  BZ    15D0
15C6:  INCF   21,F
15C8:  MOVWF  22
15CA:  CALL   0636
15CE:  BRA    15BC
....................        delay_ms(3000); 
15D0:  MOVLW  0C
15D2:  MOVWF  21
15D4:  MOVLW  FA
15D6:  MOVWF  23
15D8:  CALL   04CE
15DC:  DECFSZ 21,F
15DE:  BRA    15D4
....................        goto David; 
15E0:  BRA    12FE
....................      } 
....................     else  if(datom==0x03) 
15E2:  BRA    1886
15E4:  MOVF   18,W
15E6:  SUBLW  03
15E8:  BNZ   1648
....................      { 
....................        lcd_putc('\f');                //Limpiar pantalla comando 
15EA:  MOVLW  0C
15EC:  MOVWF  22
15EE:  CALL   0636
....................        lcd_gotoxy(1,1);               //escribir en a primera fila primera posicion  
15F2:  MOVLW  01
15F4:  MOVWF  23
15F6:  MOVWF  24
15F8:  CALL   05DA
....................        lcd_putc("MENU REPORTES");     //lo que se escribe 
15FC:  CLRF   21
15FE:  MOVF   21,W
1600:  CALL   03E6
1604:  IORLW  00
1606:  BZ    1612
1608:  INCF   21,F
160A:  MOVWF  22
160C:  CALL   0636
1610:  BRA    15FE
....................        lcd_gotoxy(3,2);               //escribir en a primera fila primera posicion  
1612:  MOVLW  03
1614:  MOVWF  23
1616:  MOVLW  02
1618:  MOVWF  24
161A:  CALL   05DA
....................        lcd_putc("EN CONSTRUCCION"); 
161E:  CLRF   21
1620:  MOVF   21,W
1622:  CALL   03A4
1626:  IORLW  00
1628:  BZ    1634
162A:  INCF   21,F
162C:  MOVWF  22
162E:  CALL   0636
1632:  BRA    1620
....................        delay_ms(3000); 
1634:  MOVLW  0C
1636:  MOVWF  21
1638:  MOVLW  FA
163A:  MOVWF  23
163C:  CALL   04CE
1640:  DECFSZ 21,F
1642:  BRA    1638
....................        goto David;; 
1644:  BRA    12FE
....................      } 
....................     else if(datom==0x04) 
1646:  BRA    1886
1648:  MOVF   18,W
164A:  SUBLW  04
164C:  BNZ   16AC
....................      { 
....................        lcd_putc('\f');               //Limpiar pantalla comando 
164E:  MOVLW  0C
1650:  MOVWF  22
1652:  CALL   0636
....................        lcd_gotoxy(1,1);              //escribir en a primera fila primera posicion  
1656:  MOVLW  01
1658:  MOVWF  23
165A:  MOVWF  24
165C:  CALL   05DA
....................        lcd_putc("MEN MOTOR PAS A."); //lo que se escribe 
1660:  CLRF   21
1662:  MOVF   21,W
1664:  CALL   0404
1668:  IORLW  00
166A:  BZ    1676
166C:  INCF   21,F
166E:  MOVWF  22
1670:  CALL   0636
1674:  BRA    1662
....................        lcd_gotoxy(3,2);              //escribir en a primera fila primera posicion  
1676:  MOVLW  03
1678:  MOVWF  23
167A:  MOVLW  02
167C:  MOVWF  24
167E:  CALL   05DA
....................        lcd_putc("EN CONSTRUCCION"); 
1682:  CLRF   21
1684:  MOVF   21,W
1686:  CALL   03A4
168A:  IORLW  00
168C:  BZ    1698
168E:  INCF   21,F
1690:  MOVWF  22
1692:  CALL   0636
1696:  BRA    1684
....................        delay_ms(3000); 
1698:  MOVLW  0C
169A:  MOVWF  21
169C:  MOVLW  FA
169E:  MOVWF  23
16A0:  CALL   04CE
16A4:  DECFSZ 21,F
16A6:  BRA    169C
....................        goto David; 
16A8:  BRA    12FE
....................      } 
....................     else if(datom==0x05) 
16AA:  BRA    1886
16AC:  MOVF   18,W
16AE:  SUBLW  05
16B0:  BNZ   1710
....................      { 
....................        lcd_putc('\f');              //Limpiar pantalla comando 
16B2:  MOVLW  0C
16B4:  MOVWF  22
16B6:  CALL   0636
....................        lcd_gotoxy(1,1);             //escribir en a primera fila primera posicion  
16BA:  MOVLW  01
16BC:  MOVWF  23
16BE:  MOVWF  24
16C0:  CALL   05DA
....................        lcd_putc("MEN SERVOMOTOR");  //lo que se escribe 
16C4:  CLRF   21
16C6:  MOVF   21,W
16C8:  CALL   0426
16CC:  IORLW  00
16CE:  BZ    16DA
16D0:  INCF   21,F
16D2:  MOVWF  22
16D4:  CALL   0636
16D8:  BRA    16C6
....................        lcd_gotoxy(3,2);             //escribir en a primera fila primera posicion  
16DA:  MOVLW  03
16DC:  MOVWF  23
16DE:  MOVLW  02
16E0:  MOVWF  24
16E2:  CALL   05DA
....................        lcd_putc("EN CONSTRUCCION"); 
16E6:  CLRF   21
16E8:  MOVF   21,W
16EA:  CALL   03A4
16EE:  IORLW  00
16F0:  BZ    16FC
16F2:  INCF   21,F
16F4:  MOVWF  22
16F6:  CALL   0636
16FA:  BRA    16E8
....................        delay_ms(3000); 
16FC:  MOVLW  0C
16FE:  MOVWF  21
1700:  MOVLW  FA
1702:  MOVWF  23
1704:  CALL   04CE
1708:  DECFSZ 21,F
170A:  BRA    1700
....................        goto David; 
170C:  BRA    12FE
....................      } 
....................     else if(datom==0x06) 
170E:  BRA    1886
1710:  MOVF   18,W
1712:  SUBLW  06
1714:  BNZ   1774
....................      { 
....................        lcd_putc('\f');               //Limpiar pantalla comando 
1716:  MOVLW  0C
1718:  MOVWF  22
171A:  CALL   0636
....................        lcd_gotoxy(1,1);              //escribir en a primera fila primera posicion  
171E:  MOVLW  01
1720:  MOVWF  23
1722:  MOVWF  24
1724:  CALL   05DA
....................        lcd_putc("MENU CAD");         //lo que se escribe 
1728:  CLRF   21
172A:  MOVF   21,W
172C:  CALL   0446
1730:  IORLW  00
1732:  BZ    173E
1734:  INCF   21,F
1736:  MOVWF  22
1738:  CALL   0636
173C:  BRA    172A
....................        lcd_gotoxy(3,2);              //escribir en a primera fila primera posicion  
173E:  MOVLW  03
1740:  MOVWF  23
1742:  MOVLW  02
1744:  MOVWF  24
1746:  CALL   05DA
....................        lcd_putc("EN CONSTRUCCION"); 
174A:  CLRF   21
174C:  MOVF   21,W
174E:  CALL   03A4
1752:  IORLW  00
1754:  BZ    1760
1756:  INCF   21,F
1758:  MOVWF  22
175A:  CALL   0636
175E:  BRA    174C
....................        delay_ms(3000); 
1760:  MOVLW  0C
1762:  MOVWF  21
1764:  MOVLW  FA
1766:  MOVWF  23
1768:  CALL   04CE
176C:  DECFSZ 21,F
176E:  BRA    1764
....................        goto David; 
1770:  BRA    12FE
....................      } 
....................     else if(datom==0x07) 
1772:  BRA    1886
1774:  MOVF   18,W
1776:  SUBLW  07
1778:  BNZ   17D8
....................      { 
....................        lcd_putc('\f');               //Limpiar pantalla comando 
177A:  MOVLW  0C
177C:  MOVWF  22
177E:  CALL   0636
....................        lcd_gotoxy(1,1);              //escribir en a primera fila primera posicion  
1782:  MOVLW  01
1784:  MOVWF  23
1786:  MOVWF  24
1788:  CALL   05DA
....................        lcd_putc("MEN DTMF");         //lo que se escribe 
178C:  CLRF   21
178E:  MOVF   21,W
1790:  CALL   0460
1794:  IORLW  00
1796:  BZ    17A2
1798:  INCF   21,F
179A:  MOVWF  22
179C:  CALL   0636
17A0:  BRA    178E
....................        lcd_gotoxy(3,2);              //escribir en a primera fila primera posicion  
17A2:  MOVLW  03
17A4:  MOVWF  23
17A6:  MOVLW  02
17A8:  MOVWF  24
17AA:  CALL   05DA
....................        lcd_putc("EN CONSTRUCCION"); 
17AE:  CLRF   21
17B0:  MOVF   21,W
17B2:  CALL   03A4
17B6:  IORLW  00
17B8:  BZ    17C4
17BA:  INCF   21,F
17BC:  MOVWF  22
17BE:  CALL   0636
17C2:  BRA    17B0
....................        delay_ms(3000); 
17C4:  MOVLW  0C
17C6:  MOVWF  21
17C8:  MOVLW  FA
17CA:  MOVWF  23
17CC:  CALL   04CE
17D0:  DECFSZ 21,F
17D2:  BRA    17C8
....................        goto David; 
17D4:  BRA    12FE
....................      } 
....................     else if(datom==0x08) 
17D6:  BRA    1886
17D8:  MOVF   18,W
17DA:  SUBLW  08
17DC:  BNZ   183C
....................      { 
....................        lcd_putc('\f');              //Limpiar pantalla comando 
17DE:  MOVLW  0C
17E0:  MOVWF  22
17E2:  CALL   0636
....................        lcd_gotoxy(1,1);             //escribir en a primera fila primera posicion  
17E6:  MOVLW  01
17E8:  MOVWF  23
17EA:  MOVWF  24
17EC:  CALL   05DA
....................        lcd_putc("MEN SENSORES");    //lo que se escribe 
17F0:  CLRF   21
17F2:  MOVF   21,W
17F4:  CALL   047A
17F8:  IORLW  00
17FA:  BZ    1806
17FC:  INCF   21,F
17FE:  MOVWF  22
1800:  CALL   0636
1804:  BRA    17F2
....................        lcd_gotoxy(3,2);             //escribir en a primera fila primera posicion  
1806:  MOVLW  03
1808:  MOVWF  23
180A:  MOVLW  02
180C:  MOVWF  24
180E:  CALL   05DA
....................        lcd_putc("EN CONSTRUCCION"); 
1812:  CLRF   21
1814:  MOVF   21,W
1816:  CALL   03A4
181A:  IORLW  00
181C:  BZ    1828
181E:  INCF   21,F
1820:  MOVWF  22
1822:  CALL   0636
1826:  BRA    1814
....................        delay_ms(3000); 
1828:  MOVLW  0C
182A:  MOVWF  21
182C:  MOVLW  FA
182E:  MOVWF  23
1830:  CALL   04CE
1834:  DECFSZ 21,F
1836:  BRA    182C
....................        goto David; 
1838:  BRA    12FE
....................      } 
....................     else if(datom==0x09) 
183A:  BRA    1886
183C:  MOVF   18,W
183E:  SUBLW  09
1840:  BNZ   1848
....................      { 
....................       goto admin; 
1842:  GOTO   0BC0
....................      } 
....................      else{ 
1846:  BRA    1886
....................           lcd_putc('\f');                 //Limpiar pantalla comando 
1848:  MOVLW  0C
184A:  MOVWF  22
184C:  CALL   0636
....................           lcd_gotoxy(1,2);                //escribir en a primera fila primera posicion  
1850:  MOVLW  01
1852:  MOVWF  23
1854:  MOVLW  02
1856:  MOVWF  24
1858:  CALL   05DA
....................           lcd_putc("ERROR DE NUMERO");   //lo que se escribe 
185C:  CLRF   21
185E:  MOVF   21,W
1860:  CALL   0210
1864:  IORLW  00
1866:  BZ    1872
1868:  INCF   21,F
186A:  MOVWF  22
186C:  CALL   0636
1870:  BRA    185E
....................           delay_ms(3000); 
1872:  MOVLW  0C
1874:  MOVWF  21
1876:  MOVLW  FA
1878:  MOVWF  23
187A:  CALL   04CE
187E:  DECFSZ 21,F
1880:  BRA    1876
....................           goto menu; 
1882:  GOTO   0A64
....................       } 
....................      }else{ 
1886:  BRA    18C6
....................      lcd_putc('\f');                 //Limpiar pantalla comando 
1888:  MOVLW  0C
188A:  MOVWF  22
188C:  CALL   0636
....................      lcd_gotoxy(1,2);                //escribir en a primera fila primera posicion  
1890:  MOVLW  01
1892:  MOVWF  23
1894:  MOVLW  02
1896:  MOVWF  24
1898:  CALL   05DA
....................      lcd_putc("CONTRA. ERRONEA");   //lo que se escribe 
189C:  CLRF   21
189E:  MOVF   21,W
18A0:  CALL   04AE
18A4:  IORLW  00
18A6:  BZ    18B2
18A8:  INCF   21,F
18AA:  MOVWF  22
18AC:  CALL   0636
18B0:  BRA    189E
....................      delay_ms(3000); 
18B2:  MOVLW  0C
18B4:  MOVWF  21
18B6:  MOVLW  FA
18B8:  MOVWF  23
18BA:  CALL   04CE
18BE:  DECFSZ 21,F
18C0:  BRA    18B6
....................      goto menu; 
18C2:  GOTO   0A64
....................      } 
....................    } 
....................  
18C6:  SLEEP 

Configuration Fuses:
   Word  1: 0C00   NOIESO NOFCMEN HS PLL1 CPUDIV1 NOUSBDIV
   Word  2: 1E18   NOBROWNOUT NOWDT BORV20 PUT WDT32768 NOVREGEN
   Word  3: 0300   PBADEN CCP2C1 NOMCLR NOLPT1OSC
   Word  4: 0081   STVREN NODEBUG NOLVP NOXINST NOICPRT
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: E00F   NOWRT NOWRTD NOWRTC NOWRTB
   Word  7: 400F   NOEBTR NOEBTRB
