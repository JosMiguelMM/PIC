CCS PCH C Compiler, Version 4.093, 51109               12-oct.-21 18:57

               Filename: C:\Proyecto arquitectura c\Direccionamiento de la memoria\Direccionamiento de memoria.lst

               ROM used: 11530 bytes (35%)
                         Largest free fragment is 21238
               RAM used: 141 (7%) at main() level
                         158 (8%) worst case
               Stack:    6 locations

*
0000:  GOTO   1798
.................... #include <18F4550.h> 
.................... //////// Standard Header file for the PIC18F4550 device //////////////// 
.................... #device PIC18F4550 
.................... #list 
....................  
.................... #fuses     HS,NOPROTECT,NOBROWNOUT,NOWDT,PUT,NOCPD,NODEBUG,NOLVP,NOMCLR  
.................... #use       delay(clock=20000000) 
*
06DC:  CLRF   FEA
06DE:  MOVLW  94
06E0:  MOVWF  FE9
06E2:  MOVF   FEF,W
06E4:  BZ    0700
06E6:  MOVLW  06
06E8:  MOVWF  01
06EA:  CLRF   00
06EC:  DECFSZ 00,F
06EE:  BRA    06EC
06F0:  DECFSZ 01,F
06F2:  BRA    06EA
06F4:  MOVLW  7B
06F6:  MOVWF  00
06F8:  DECFSZ 00,F
06FA:  BRA    06F8
06FC:  DECFSZ FEF,F
06FE:  BRA    06E6
0700:  RETLW  00
.................... #include   <stdlib.h>          //LIBRERIAS MATEMATICAS IGUAL LA DE ABAJO 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = TRUE, sign = FALSE, point = FALSE; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = FALSE; 
....................          if (c == '+') 
....................          { 
....................             sign = FALSE; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = TRUE; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = TRUE; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = TRUE, sign = FALSE, point = FALSE; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = FALSE; 
....................          if (c == '+') 
....................          { 
....................             sign = FALSE; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = TRUE; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = TRUE; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = TRUE, sign = FALSE, point = FALSE; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = FALSE; 
....................          if (c == '+') 
....................          { 
....................             sign = FALSE; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = TRUE; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = TRUE; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    BYTE t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=TRUE; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = FALSE; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include   <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float32)l); 
....................   res = 32768.0*(float32)l; 
....................   res += (float32)(unsigned int16)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float48)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float48)l); 
....................   res = 32768.0*(float32)l; 
....................   res += (float48)(unsigned int16)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float48)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float64)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float64)l); 
....................   res = 32768.0*(float64)l; 
....................   res += (float64)(unsigned int16)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float64)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y/LN2 - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y/LN2 - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y/LN2 - (float64)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {0.45145214, -9.0558803, 26.940971, -19.860189}; 
.................... float32 const ql[4] = {1.0000000,  -8.1354259, 16.780517, -9.9300943}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................    bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................       res = res*y2 + pl[2]; 
....................       res = res*y2 + pl[3]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + ql[2]; 
....................       r = r*y2 + ql[3]; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................     
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................    
....................       if(bit_test(data2,7)) 
....................          bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................       res = res*y2 + pl[2]; 
....................       res = res*y2 + pl[3]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + ql[2]; 
....................       r = r*y2 + ql[3]; 
....................  
....................       res = y*res/r; 
....................  
....................     data1 = *(((unsigned int8 *)(&x)+5)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+4)); 
....................     if(bit_test (data2,7)) 
....................        bit_set(data1,0); 
....................       
....................     n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................          r = -(float48)-n; 
....................       else 
....................          r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float32 const pl_64[4] = {0.45145214, -9.0558803, 26.940971, -19.860189}; 
.................... float32 const ql_64[4] = {1.0000000,  -8.1354259, 16.780517, -9.9300943}; 
.................... #endif 
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................       bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................     bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................    bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................      bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #define TWOBYPI          0.6366197723675813 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[4] = { 
....................       -0.499999993585, 
....................        0.041666636258, 
....................       -0.0013888361399, 
....................        0.00002476016134 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 3; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[4] = { 
....................       -0.499999993585, 
....................        0.041666636258, 
....................       -0.0013888361399, 
....................        0.00002476016134 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 3; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float48 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p[4] = { 
....................       -0.499999993585, 
....................        0.041666636258, 
....................       -0.0013888361399, 
....................        0.00002476016134 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 3; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #define   LCD_E    PIN_E2 
.................... #define   LCD_CK   PIN_E1 
.................... #define   LCD_DAT  PIN_E0 
.................... #include <LCD4x20_3PIN.c>       //libreria LCD 
.................... // flex_lcd_3_pins.c 
....................  
.................... //Modificacin de Flex_lcd por Duende_Azul y Akenafab 
.................... //Trabaja con 3 pines y 74VHC164 
.................... //8-Bit Serial-In, Parallel-Out Shift Register 
....................  
.................... //La LCD se usa en modo 4bits 
.................... //Revisar diagrama de conexion Adjunto 
....................  
.................... //No esta habilitada la lectura del LCD 
.................... //RW debe ir a gnd 
....................  
.................... //Definir pines antes de llamar libreria// 
.................... //#define LCD_E     PIN_A0 
.................... //#define LCD_CK    PIN_A1    
.................... //#define LCD_DAT   PIN_A2 
....................  
.................... //======================================== 
.................... int RS_bit; 
.................... #define lcd_type 2        // 0=5x7, 1=5x10, 2=2 lines 
.................... #define lcd_line_two 0x40 // LCD RAM address for the 2nd line 
....................  
....................  
.................... int8 const LCD_INIT_STRING[4] = 
.................... { 
....................  0x20 | (lcd_type << 2), // Func set: 4-bit, 2 lines, 5x8 dots 
....................  0xc,                    // Display on 
....................  1,                      // Clear display 
....................  6                       // Increment cursor 
....................  }; 
.................... BYTE lcdline; 
....................  
.................... //------------------------------------- 
.................... void lcd_send_nibble(int8 nibble, int rs_bit) 
.................... { 
....................  
.................... int x; 
.................... if(RS_bit==1) 
0702:  DECFSZ x9C,W
0704:  BRA    0708
....................    nibble=nibble|0x10; 
0706:  BSF    x9B.4
....................  
.................... for(x=0;x<5;x++){ 
0708:  CLRF   x9D
070A:  MOVF   x9D,W
070C:  SUBLW  04
070E:  BNC   0732
....................          output_bit(LCD_DAT,shift_right(&nibble,1,0)); 
0710:  BCF    FD8.0
0712:  RRCF   x9B,F
0714:  BC    071A
0716:  BCF    F8D.0
0718:  BRA    071C
071A:  BSF    F8D.0
071C:  BCF    F96.0
....................          delay_cycles(1); 
071E:  NOP   
....................          output_low(LCD_CK); 
0720:  BCF    F96.1
0722:  BCF    F8D.1
....................          delay_us(1); 
0724:  BRA    0726
0726:  BRA    0728
0728:  NOP   
....................          output_high(LCD_CK);} 
072A:  BCF    F96.1
072C:  BSF    F8D.1
072E:  INCF   x9D,F
0730:  BRA    070A
....................  
....................  
....................  
....................  output_high(LCD_E); 
0732:  BCF    F96.2
0734:  BSF    F8D.2
....................  delay_us(2); 
0736:  MOVLW  03
0738:  MOVWF  00
073A:  DECFSZ 00,F
073C:  BRA    073A
....................  output_low(LCD_E); 
073E:  BCF    F96.2
0740:  BCF    F8D.2
.................... } 
0742:  RETLW  00
....................  
.................... //----------------------------------- 
.................... //---------------------------------------- 
.................... // Send a byte to the LCD. 
.................... void lcd_send_byte(int8 address, int8 n) 
.................... { 
.................... //output_low(LCD_RS); 
.................... RS_bit=0; 
0744:  CLRF   0B
.................... delay_us(100); 
0746:  MOVLW  A6
0748:  MOVWF  00
074A:  DECFSZ 00,F
074C:  BRA    074A
074E:  NOP   
....................  
....................  
.................... if(address) 
0750:  MOVF   x98,F
0752:  BZ    075A
....................    //output_high(LCD_RS); 
....................    RS_bit=1; 
0754:  MOVLW  01
0756:  MOVWF  0B
.................... else 
0758:  BRA    075C
....................    //output_low(LCD_RS); 
....................    RS_bit=0; 
075A:  CLRF   0B
....................  
....................  delay_cycles(1); 
075C:  NOP   
....................  
....................  
.................... output_low(LCD_E); 
075E:  BCF    F96.2
0760:  BCF    F8D.2
....................  
.................... lcd_send_nibble(n >> 4,RS_bit); 
0762:  SWAPF  x99,W
0764:  MOVWF  x9A
0766:  MOVLW  0F
0768:  ANDWF  x9A,F
076A:  MOVFF  9A,9B
076E:  MOVFF  0B,9C
0772:  RCALL  0702
.................... lcd_send_nibble(n & 0xf,RS_bit); 
0774:  MOVF   x99,W
0776:  ANDLW  0F
0778:  MOVWF  x9A
077A:  MOVWF  x9B
077C:  MOVFF  0B,9C
0780:  RCALL  0702
.................... } 
0782:  RETLW  00
....................  
.................... //---------------------------- 
.................... void lcd_init(void) 
.................... { 
.................... int8 i; 
....................  
.................... //output_low(LCD_RS); 
.................... RS_bit=0; 
0784:  CLRF   0B
....................  
.................... output_low(LCD_E); 
0786:  BCF    F96.2
0788:  BCF    F8D.2
....................  
.................... delay_ms(20); 
078A:  MOVLW  14
078C:  MOVWF  x94
078E:  RCALL  06DC
....................  
.................... for(i=0 ;i < 3; i++) 
0790:  CLRF   x8C
0792:  MOVF   x8C,W
0794:  SUBLW  02
0796:  BNC   07AC
....................    { 
....................     lcd_send_nibble(0x03,RS_bit); 
0798:  MOVLW  03
079A:  MOVWF  x9B
079C:  MOVFF  0B,9C
07A0:  RCALL  0702
....................     delay_ms(5); 
07A2:  MOVLW  05
07A4:  MOVWF  x94
07A6:  RCALL  06DC
....................    } 
07A8:  INCF   x8C,F
07AA:  BRA    0792
....................  
.................... lcd_send_nibble(0x02,RS_bit); 
07AC:  MOVLW  02
07AE:  MOVWF  x9B
07B0:  MOVFF  0B,9C
07B4:  RCALL  0702
....................  
.................... for(i=0; i < sizeof(LCD_INIT_STRING); i++) 
07B6:  CLRF   x8C
07B8:  MOVF   x8C,W
07BA:  SUBLW  03
07BC:  BNC   07E0
....................    { 
....................     lcd_send_byte(0, LCD_INIT_STRING[i]); 
07BE:  CLRF   03
07C0:  MOVF   x8C,W
07C2:  MOVFF  FF2,8D
07C6:  BCF    FF2.7
07C8:  RCALL  0004
07CA:  BTFSC  x8D.7
07CC:  BSF    FF2.7
07CE:  MOVWF  x8D
07D0:  CLRF   x98
07D2:  MOVWF  x99
07D4:  RCALL  0744
....................  
....................     delay_ms(5); 
07D6:  MOVLW  05
07D8:  MOVWF  x94
07DA:  RCALL  06DC
....................      
....................    } 
07DC:  INCF   x8C,F
07DE:  BRA    07B8
....................  
.................... } 
07E0:  GOTO   18D4 (RETURN)
....................  
.................... //---------------------------- 
....................  
.................... void lcd_gotoxy(int8 x, int8 y) 
.................... { 
.................... int8 address; 
....................  
....................    switch(y) { 
*
07E8:  MOVLW  01
07EA:  SUBWF  x95,W
07EC:  ADDLW  FC
07EE:  BC    080E
07F0:  ADDLW  04
07F2:  GOTO   0822
....................      case 1 : address=0x80;break; 
07F6:  MOVLW  80
07F8:  MOVWF  x96
07FA:  BRA    080E
....................      case 2 : address=0xc0;break; 
07FC:  MOVLW  C0
07FE:  MOVWF  x96
0800:  BRA    080E
....................      case 3 : address=0x94;break; 
0802:  MOVLW  94
0804:  MOVWF  x96
0806:  BRA    080E
....................      case 4 : address=0xd4;break; 
0808:  MOVLW  D4
080A:  MOVWF  x96
080C:  BRA    080E
....................    } 
.................... address += x-1; 
080E:  MOVLW  01
0810:  SUBWF  x94,W
0812:  ADDWF  x96,F
.................... lcd_send_byte(0, 0x80 | address); 
0814:  MOVF   x96,W
0816:  IORLW  80
0818:  MOVWF  x97
081A:  CLRF   x98
081C:  MOVWF  x99
081E:  RCALL  0744
.................... } 
0820:  RETLW  00
....................  
.................... //----------------------------- 
.................... void lcd_putc(char c) 
.................... { 
....................  switch(c) 
....................    { 
*
0844:  MOVF   x93,W
0846:  XORLW  0C
0848:  BZ    0860
084A:  XORLW  06
084C:  BZ    0874
084E:  XORLW  02
0850:  BZ    0882
0852:  XORLW  6B
0854:  BZ    088C
0856:  XORLW  04
0858:  BZ    0896
085A:  XORLW  0F
085C:  BZ    08A0
085E:  BRA    08AA
....................     case '\f':                //limpia pantalla 
....................       lcd_send_byte(0,1); 
0860:  CLRF   x98
0862:  MOVLW  01
0864:  MOVWF  x99
0866:  RCALL  0744
....................       lcdline=1; 
0868:  MOVLW  01
086A:  MOVWF  0C
....................       delay_ms(8); 
086C:  MOVLW  08
086E:  MOVWF  x94
0870:  RCALL  06DC
....................       break; 
0872:  BRA    08B6
....................  
....................     case '\n':                //cambio de linea 
....................        lcd_gotoxy(1,++lcdline); 
0874:  INCF   0C,F
0876:  MOVLW  01
0878:  MOVWF  x94
087A:  MOVFF  0C,95
087E:  RCALL  07E8
....................        break; 
0880:  BRA    08B6
....................  
....................     case '\b':                //retrocede 1 caracter 
....................        lcd_send_byte(0,0x10); 
0882:  CLRF   x98
0884:  MOVLW  10
0886:  MOVWF  x99
0888:  RCALL  0744
....................        break; 
088A:  BRA    08B6
....................         
....................     case '\c':                //on display 
....................     lcd_send_byte(0,0x0c); 
088C:  CLRF   x98
088E:  MOVLW  0C
0890:  MOVWF  x99
0892:  RCALL  0744
....................     break; 
0894:  BRA    08B6
....................     
....................     case '\g':                 
....................     lcd_send_byte(0,0x0f);    // prende cursor y parpadea 
0896:  CLRF   x98
0898:  MOVLW  0F
089A:  MOVWF  x99
089C:  RCALL  0744
....................     break;   
089E:  BRA    08B6
....................  
....................     case '\h':                //retrocede 1 caracter 
....................     lcd_send_byte(0,0x0f);    // prende cursor y parpadea 
08A0:  CLRF   x98
08A2:  MOVLW  0F
08A4:  MOVWF  x99
08A6:  RCALL  0744
....................     break; 
08A8:  BRA    08B6
....................      
....................     default: 
....................        lcd_send_byte(1,c); 
08AA:  MOVLW  01
08AC:  MOVWF  x98
08AE:  MOVFF  93,99
08B2:  RCALL  0744
....................        break; 
08B4:  BRA    08B6
....................    } 
.................... } 
08B6:  RETLW  00
....................  
.................... //------------------------------ 
....................  
.................... void lcd_cursor_vb(short visible, short blink) {  
....................   lcd_send_byte(0, 0xC|(visible<<1)|blink);  
.................... }  
....................  
....................  
.................... #include <KBD18F.c>             //LIBRERIA TECLADO 
.................... //////////////////////////////////////////////////////////////////////////////////// 
.................... //                                   KBD.C                                        // 
.................... //               FUNCIONES PARA ESCANEO DE UN TECLADO MATRICIAL                   // 
.................... //                         4X4 HEXADECIMAL, EN EL PORTB                           // 
.................... //       kbd_init()       Debe ser invocada antes que las otras funciones.         // 
.................... //       c=lcd_getc(c)    Si h sido presionada una tecla devuelve el caracter c    // 
.................... //                  y lo salva en el char c, sino se presiona una tecla       // 
.................... //                  retorna el valor /0, esta funcin puede invocarse         // 
.................... //                  frecuentemente para no perder teclas pulsadas.            // 
.................... //        NOTA: REQUIERE COLOCAR RESISTENCIAS (2.2K) EN LOS PINES DE COLUMNAS     // 
.................... //               PINES DE COLUMNAS DE RB0(COL0) A RB3(COL3))                   // 
.................... //               PINES DE FILAS DE RB4(ROW0)) A RB7(ROW3))                    //  
.................... //                  MODIF.: ING. FRANK GIRALDO - UD                       // 
.................... //////////////////////////////////////////////////////////////////////////////////// 
.................... /*//////////////////////////////////////////////////////////////////////////////////  
.................... *    RB0 RB1 RB2 RB3    
.................... *     |   |   |   | 
.................... *     c0  c1  c2  c3   
.................... *   | 1 | 2 | 3 | F | r0 - RB4 
.................... *   | 4 | 5 | 6 | E | r1 - RB5 
.................... *   | 7 | 8 | 9 | D | r2 - RB6 
.................... *   | A | 0 | B | C | r3 - RB7 
.................... * 
.................... *   COLUMNS=OUTs 
.................... *   ROWS=INs 
.................... *   SE HABILITAN PULL-UP INTERNAS  
.................... *   SE REQUIERE COLOCAR RESISTENCIAS (2.2K) EN LOS PINES DE COLUMNAS  
.................... * 
.................... */////////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... #byte portkbd = 0XF81                  //portkbd = portB 
.................... //Keypad connection:   (Column 0 es B0) 
.................... //                Bx: 
.................... #define COL0 (0 << 0) 
.................... #define COL1 (0 << 1) 
.................... #define COL2 (0 << 2) 
.................... #define COL3 (0 << 3) 
.................... #define ROW0 (1 << 4) 
.................... #define ROW1 (1 << 5) 
.................... #define ROW2 (1 << 6) 
.................... #define ROW3 (1 << 7) 
.................... #define ALL_ROWS (ROW3|ROW2|ROW1|ROW0) 
.................... #define ALL_PINS (ALL_ROWS|COL3|COL2|COL1|COL0) 
....................  
.................... char const KEYS[4][4] = {{'1','2','3','A'}, 
....................                          {'4','5','6','B'}, 
....................                          {'7','8','9','C'}, 
....................                          {'*','0','#','D'}}; 
....................  
.................... #define KBD_DEBOUNCE_FACTOR 0.2 
.................... // Modifique el valor de temporizacin antirrebote con (KBD_DEBOUNCE_FACTOR = n/333), 
.................... // en donde n es el nmero de veces por segundo en los que ud. invoca 
.................... //la funcin kbd_getc(). 
.................... // 
....................  
.................... void kbd_init(){ 
.................... } 
*
07E4:  GOTO   18D8 (RETURN)
....................  
.................... char kbd_getc( ) 
.................... { 
....................    static BYTE kbd_call_count; 
....................    static short int kbd_down; 
....................    static char last_key; 
....................    static BYTE col; 
....................    BYTE kchar; 
....................    BYTE row; 
....................    port_b_pullups(TRUE); 
*
0B4A:  BCF    FF1.7
....................    kchar='\0'; 
0B4C:  CLRF   x8C
....................  
....................    if(++kbd_call_count>KBD_DEBOUNCE_FACTOR) 
0B4E:  INCF   0D,F
0B50:  CLRF   x8F
0B52:  MOVFF  0D,8E
0B56:  RCALL  0A9E
0B58:  MOVLW  CD
0B5A:  MOVWF  x91
0B5C:  MOVLW  CC
0B5E:  MOVWF  x90
0B60:  MOVLW  4C
0B62:  MOVWF  x8F
0B64:  MOVLW  7C
0B66:  MOVWF  x8E
0B68:  MOVFF  03,95
0B6C:  MOVFF  02,94
0B70:  MOVFF  01,93
0B74:  MOVFF  00,92
0B78:  RCALL  0AD4
0B7A:  BNC   0C32
....................    { 
....................        switch (col) 
....................        { 
0B7C:  MOVF   10,W
0B7E:  ADDLW  FC
0B80:  BC    0BB0
0B82:  ADDLW  04
0B84:  GOTO   0C40
....................          case 0   : set_tris_b(ALL_PINS&~COL0); 
0B88:  MOVLW  F0
0B8A:  MOVWF  F93
....................                     portkbd=(0b1110); 
0B8C:  MOVLW  0E
0B8E:  MOVWF  F81
....................                     break; 
0B90:  BRA    0BB0
....................  
....................          case 1   : set_tris_b(ALL_PINS&~COL1); 
0B92:  MOVLW  F0
0B94:  MOVWF  F93
....................                     portkbd=(0b1101); 
0B96:  MOVLW  0D
0B98:  MOVWF  F81
....................                     break; 
0B9A:  BRA    0BB0
....................  
....................          case 2   : set_tris_b(ALL_PINS&~COL2); 
0B9C:  MOVLW  F0
0B9E:  MOVWF  F93
....................                     portkbd=(0b1011); 
0BA0:  MOVLW  0B
0BA2:  MOVWF  F81
....................                     break; 
0BA4:  BRA    0BB0
....................  
....................          case 3   : set_tris_b(ALL_PINS&~COL3); 
0BA6:  MOVLW  F0
0BA8:  MOVWF  F93
....................                     portkbd=(0b0111); 
0BAA:  MOVLW  07
0BAC:  MOVWF  F81
....................                     break; 
0BAE:  BRA    0BB0
....................        } 
....................  
....................        if(kbd_down) 
0BB0:  BTFSS  0E.0
0BB2:  BRA    0BC6
....................        { 
....................          if((portkbd & (ALL_ROWS))==(ALL_ROWS)) 
0BB4:  MOVF   F81,W
0BB6:  ANDLW  F0
0BB8:  SUBLW  F0
0BBA:  BNZ   0BC4
....................          { 
....................            kbd_down=FALSE; 
0BBC:  BCF    0E.0
....................            kchar=last_key; 
0BBE:  MOVFF  0F,8C
....................            last_key='\0'; 
0BC2:  CLRF   0F
....................          } 
....................        } 
....................        else 
0BC4:  BRA    0C30
....................        { 
....................           if((portkbd & (ALL_ROWS))!=(ALL_ROWS)) 
0BC6:  MOVF   F81,W
0BC8:  ANDLW  F0
0BCA:  SUBLW  F0
0BCC:  BZ    0C26
....................           { 
....................              if((portkbd & ROW0) == 0) 
0BCE:  MOVF   F81,W
0BD0:  ANDLW  10
0BD2:  BNZ   0BD8
....................                row = 0; 
0BD4:  CLRF   x8D
....................              else if((portkbd & ROW1) == 0) 
0BD6:  BRA    0BFA
0BD8:  MOVF   F81,W
0BDA:  ANDLW  20
0BDC:  BNZ   0BE4
....................                row = 1; 
0BDE:  MOVLW  01
0BE0:  MOVWF  x8D
....................              else if((portkbd & ROW2) == 0) 
0BE2:  BRA    0BFA
0BE4:  MOVF   F81,W
0BE6:  ANDLW  40
0BE8:  BNZ   0BF0
....................                row = 2; 
0BEA:  MOVLW  02
0BEC:  MOVWF  x8D
....................              else if((portkbd & ROW3) == 0) 
0BEE:  BRA    0BFA
0BF0:  MOVF   F81,W
0BF2:  ANDLW  80
0BF4:  BNZ   0BFA
....................                row = 3; 
0BF6:  MOVLW  03
0BF8:  MOVWF  x8D
....................              last_key = KEYS[row][col]; 
0BFA:  MOVF   x8D,W
0BFC:  MULLW  04
0BFE:  MOVF   FF3,W
0C00:  CLRF   x8F
0C02:  MOVWF  x8E
0C04:  CLRF   03
0C06:  MOVF   10,W
0C08:  ADDWF  x8E,W
0C0A:  MOVWF  01
0C0C:  MOVF   x8F,W
0C0E:  ADDWFC 03,F
0C10:  MOVF   01,W
0C12:  MOVFF  FF2,8E
0C16:  BCF    FF2.7
0C18:  CALL   0018
0C1C:  BTFSC  x8E.7
0C1E:  BSF    FF2.7
0C20:  MOVWF  0F
....................              kbd_down = TRUE; 
0C22:  BSF    0E.0
....................           } 
....................           else 
0C24:  BRA    0C30
....................           { 
....................              ++col; 
0C26:  INCF   10,F
....................              if(col==4) 
0C28:  MOVF   10,W
0C2A:  SUBLW  04
0C2C:  BNZ   0C30
....................              col=0; 
0C2E:  CLRF   10
....................           } 
....................        } 
....................       kbd_call_count=0; 
0C30:  CLRF   0D
....................    } 
....................   kchar = last_key; 
0C32:  MOVFF  0F,8C
....................   set_tris_b(ALL_PINS); 
0C36:  MOVLW  F0
0C38:  MOVWF  F93
....................   return(kchar); 
0C3A:  MOVFF  8C,01
.................... } 
0C3E:  RETLW  00
....................  
.................... /*char dato; 
.................... char tecla() 
.................... { 
....................    dato='\0'; 
....................    while(dato=='\0') 
....................    { 
....................       dato=kbd_getc(); 
....................       delay_ms(100); 
....................    } 
.................... return dato; 
.................... } */ 
....................  
.................... #include <DS1307A.c>            //LIBRERIA RELOJ 
.................... /////////////////////////////////////////////////////////////////////////////////////// 
.................... ///                               DS1307.C                                           /// 
.................... ///                     Driver for Real Time Clock                                   /// 
.................... ///                     modified by Redpic 08/2006                                   /// 
.................... ///                  http://picmania.garcia-cuervo.com                               /// 
.................... ///                                                                                  /// 
.................... /// void ds1307_init(val)                                                            /// 
.................... ///                  - Enable oscillator without clearing the seconds register       /// 
.................... ///                    used when PIC loses power and DS1307 run from 3V BAT          /// 
.................... ///                  - Config Control Register with next parameters:                 /// 
.................... ///                     DS1307_ALL_DISABLED          All disabled                    /// 
.................... ///                     DS1307_OUT_ON_DISABLED_HIHG  Out to Hight on Disable Out     /// 
.................... ///                     DS1307_OUT_ENABLED           Out Enabled                     /// 
.................... ///                     DS1307_OUT_1_HZ              Freq. Out to 1 Hz               /// 
.................... ///                     DS1307_OUT_4_KHZ             Freq. Out to 4.096 Khz          /// 
.................... ///                     DS1307_OUT_8_KHZ             Freq. Out to 8.192 Khz          /// 
.................... ///                     DS1307_OUT_32_KHZ            Freq. Out to 32.768 Khz         /// 
.................... ///                                                                                  /// 
.................... ///                     Example init:                                                /// 
.................... ///                     ds1307_init(DS1307_ALL_DISABLED);                            /// 
.................... ///                     ds1307_init(DS1307_OUT_ENABLED | DS1307_OUT_1_HZ);           /// 
.................... ///                                                                                  /// 
.................... /// void ds1307_set_date_time(day,mth,year,dow,hour,min,sec) - Set the date/time     /// 
.................... ///                                                                                  /// 
.................... /// void ds1307_get_date(day,mth,year,dow)                   - Get the date          /// 
.................... ///                                                                                  /// 
.................... /// void ds1307_get_time(hr,min,sec)                         - Get the time          /// 
.................... ///                                                                                  /// 
.................... /// char ds1307_read_nvram_byte(char addr)                   - Read byte in address  /// 
.................... ///                                                                                  /// 
.................... /// void ds1307_write_nvram_byte(char addr, char value)      - Write byte in address /// 
.................... ///                                                                                  /// 
.................... /// void ds1307_get_day_of_week(char* ptr)                   - Get string Day Of Week/// 
.................... ///                                                                                  /// 
.................... /// If defined USE_INTERRUPTS all functions disable Global Interrupts on starts and  /// 
.................... ///                           enable Global on ends else usar can do it hiself       /// 
.................... ///                                                                                  /// 
.................... /////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef RTC_SDA 
.................... #define RTC_SDA  PIN_A3 
.................... #define RTC_SCL  PIN_A2 
.................... #endif 
....................  
.................... #use i2c(master, sda=RTC_SDA, scl=RTC_SCL) 
*
0F8A:  MOVLW  08
0F8C:  MOVWF  01
0F8E:  MOVLW  05
0F90:  MOVWF  00
0F92:  DECFSZ 00,F
0F94:  BRA    0F92
0F96:  BCF    F89.2
0F98:  BCF    F92.2
0F9A:  MOVLW  06
0F9C:  MOVWF  00
0F9E:  DECFSZ 00,F
0FA0:  BRA    0F9E
0FA2:  RLCF   x90,F
0FA4:  BCF    F89.3
0FA6:  BTFSC  FD8.0
0FA8:  BSF    F92.3
0FAA:  BTFSS  FD8.0
0FAC:  BCF    F92.3
0FAE:  BSF    F92.2
0FB0:  BTFSS  F80.2
0FB2:  BRA    0FB0
0FB4:  DECFSZ 01,F
0FB6:  BRA    0F8E
0FB8:  MOVLW  05
0FBA:  MOVWF  00
0FBC:  DECFSZ 00,F
0FBE:  BRA    0FBC
0FC0:  BCF    F89.2
0FC2:  BCF    F92.2
0FC4:  NOP   
0FC6:  BSF    F92.3
0FC8:  MOVLW  06
0FCA:  MOVWF  00
0FCC:  DECFSZ 00,F
0FCE:  BRA    0FCC
0FD0:  MOVLW  06
0FD2:  MOVWF  00
0FD4:  DECFSZ 00,F
0FD6:  BRA    0FD4
0FD8:  BSF    F92.2
0FDA:  BTFSS  F80.2
0FDC:  BRA    0FDA
0FDE:  CLRF   01
0FE0:  MOVLW  06
0FE2:  MOVWF  00
0FE4:  DECFSZ 00,F
0FE6:  BRA    0FE4
0FE8:  BTFSC  F80.3
0FEA:  BSF    01.0
0FEC:  BCF    F89.2
0FEE:  BCF    F92.2
0FF0:  BCF    F89.3
0FF2:  BCF    F92.3
0FF4:  RETLW  00
0FF6:  MOVLW  08
0FF8:  MOVWF  x91
0FFA:  MOVFF  00,92
0FFE:  BSF    F92.3
1000:  MOVLW  06
1002:  MOVWF  00
1004:  DECFSZ 00,F
1006:  BRA    1004
1008:  BSF    F92.2
100A:  BTFSS  F80.2
100C:  BRA    100A
100E:  BTFSC  F80.3
1010:  BSF    FD8.0
1012:  BTFSS  F80.3
1014:  BCF    FD8.0
1016:  RLCF   01,F
1018:  MOVLW  05
101A:  MOVWF  00
101C:  DECFSZ 00,F
101E:  BRA    101C
1020:  BCF    F92.2
1022:  BCF    F89.2
1024:  DECFSZ x91,F
1026:  BRA    0FFE
1028:  BSF    F92.3
102A:  MOVLW  06
102C:  MOVWF  00
102E:  DECFSZ 00,F
1030:  BRA    102E
1032:  BCF    F89.3
1034:  MOVF   x92,W
1036:  BTFSS  FD8.2
1038:  BCF    F92.3
103A:  NOP   
103C:  BSF    F92.2
103E:  BTFSS  F80.2
1040:  BRA    103E
1042:  MOVLW  05
1044:  MOVWF  00
1046:  DECFSZ 00,F
1048:  BRA    1046
104A:  BCF    F89.2
104C:  BCF    F92.2
104E:  MOVLW  06
1050:  MOVWF  00
1052:  DECFSZ 00,F
1054:  BRA    1052
1056:  BCF    F89.3
1058:  BCF    F92.3
105A:  RETLW  00
....................  
.................... #define DS1307_ALL_DISABLED         0b00000000 // All disabled 
.................... #define DS1307_OUT_ON_DISABLED_HIHG 0b10000000 // Out to Hight on Disable Out 
.................... #define DS1307_OUT_ENABLED          0b00010000 // Out Enabled 
.................... #define DS1307_OUT_1_HZ             0b00000000 // Freq. Out to 1 Hz 
.................... #define DS1307_OUT_4_KHZ            0b00000001 // Freq. Out to 4.096 Khz 
.................... #define DS1307_OUT_8_KHZ            0b00000010 // Freq. Out to 8.192 Khz 
.................... #define DS1307_OUT_32_KHZ           0b00000011 // Freq. Out to 32.768 Khz 
....................  
.................... #define Start_user_address_nvram    0x08 
.................... #define End_user_address_nvram      0x3f 
....................  
.................... char days_of_week[7][11]={"Lunes\0","Martes\0","Mircoles\0","Jueves\0","Viernes\0","Sbado\0","Domingo\0"}; 
....................  
.................... byte ds1307_bin2bcd(byte binary_value); 
.................... byte ds1307_bcd2bin(byte bcd_value); 
....................  
.................... void ds1307_init(int val){ 
....................  
....................    byte seconds = 0; 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    disable_interrupts(global); 
.................... #endif 
....................  
....................    i2c_start(); 
....................    i2c_write(0xD0); 
....................    i2c_write(0x00); 
....................    i2c_start(); 
....................    i2c_write(0xD1); 
....................    seconds = ds1307_bcd2bin(i2c_read(0)); 
....................    i2c_stop(); 
....................    seconds &= 0x7F; 
....................  
....................    delay_us(3); 
....................  
....................    i2c_start(); 
....................    i2c_write(0xD0); 
....................    i2c_write(0x00); 
....................    i2c_write(ds1307_bin2bcd(seconds)); 
....................    i2c_start(); 
....................    i2c_write(0xD0); 
....................    i2c_write(0x07); 
....................    i2c_write(val); 
....................    i2c_stop(); 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    enable_interrupts(global); 
.................... #endif 
....................  
.................... } 
....................  
.................... void ds1307_set_date_time(byte day, byte mth, byte year, byte dow, byte hr, byte min, byte sec){ 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    disable_interrupts(global); 
.................... #endif 
....................  
....................   sec &= 0x7F; 
....................   hr &= 0x3F; 
....................  
....................   i2c_start(); 
....................   i2c_write(0xD0); 
....................   i2c_write(0x00); 
....................   i2c_write(ds1307_bin2bcd(sec)); 
....................   i2c_write(ds1307_bin2bcd(min)); 
....................   i2c_write(ds1307_bin2bcd(hr)); 
....................   i2c_write(ds1307_bin2bcd(dow)); 
....................   i2c_write(ds1307_bin2bcd(day)); 
....................   i2c_write(ds1307_bin2bcd(mth)); 
....................   i2c_write(ds1307_bin2bcd(year)); 
....................   i2c_stop(); 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    enable_interrupts(global); 
.................... #endif 
....................  
.................... } 
....................  
.................... void ds1307_get_date(byte &day, byte &mth, byte &year, byte &dow){ 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    disable_interrupts(global); 
*
117A:  BCF    FF2.6
117C:  BCF    FF2.7
117E:  BTFSC  FF2.7
1180:  BRA    117C
*
14A2:  BCF    FF2.6
14A4:  BCF    FF2.7
14A6:  BTFSC  FF2.7
14A8:  BRA    14A4
.................... #endif 
....................  
....................   i2c_start(); 
*
1182:  BSF    F92.3
1184:  MOVLW  05
1186:  MOVWF  00
1188:  DECFSZ 00,F
118A:  BRA    1188
118C:  BSF    F92.2
118E:  MOVLW  06
1190:  MOVWF  00
1192:  DECFSZ 00,F
1194:  BRA    1192
1196:  BCF    F89.3
1198:  BCF    F92.3
119A:  MOVLW  05
119C:  MOVWF  00
119E:  DECFSZ 00,F
11A0:  BRA    119E
11A2:  BCF    F89.2
11A4:  BCF    F92.2
*
14AA:  BSF    F92.3
14AC:  MOVLW  05
14AE:  MOVWF  00
14B0:  DECFSZ 00,F
14B2:  BRA    14B0
14B4:  BSF    F92.2
14B6:  MOVLW  06
14B8:  MOVWF  00
14BA:  DECFSZ 00,F
14BC:  BRA    14BA
14BE:  BCF    F89.3
14C0:  BCF    F92.3
14C2:  MOVLW  05
14C4:  MOVWF  00
14C6:  DECFSZ 00,F
14C8:  BRA    14C6
14CA:  BCF    F89.2
14CC:  BCF    F92.2
....................   i2c_write(0xD0); 
*
11A6:  MOVLW  D0
11A8:  MOVWF  x90
11AA:  RCALL  0F8A
*
14CE:  MOVLW  D0
14D0:  MOVWF  x90
14D2:  RCALL  0F8A
....................   i2c_write(0x03); 
*
11AC:  MOVLW  03
11AE:  MOVWF  x90
11B0:  RCALL  0F8A
*
14D4:  MOVLW  03
14D6:  MOVWF  x90
14D8:  RCALL  0F8A
....................   i2c_start(); 
*
11B2:  BSF    F92.3
11B4:  MOVLW  05
11B6:  MOVWF  00
11B8:  DECFSZ 00,F
11BA:  BRA    11B8
11BC:  BSF    F92.2
11BE:  MOVLW  06
11C0:  MOVWF  00
11C2:  DECFSZ 00,F
11C4:  BRA    11C2
11C6:  BTFSS  F80.2
11C8:  BRA    11C6
11CA:  BCF    F89.3
11CC:  BCF    F92.3
11CE:  MOVLW  05
11D0:  MOVWF  00
11D2:  DECFSZ 00,F
11D4:  BRA    11D2
11D6:  BCF    F89.2
11D8:  BCF    F92.2
*
14DA:  BSF    F92.3
14DC:  MOVLW  05
14DE:  MOVWF  00
14E0:  DECFSZ 00,F
14E2:  BRA    14E0
14E4:  BSF    F92.2
14E6:  MOVLW  06
14E8:  MOVWF  00
14EA:  DECFSZ 00,F
14EC:  BRA    14EA
14EE:  BTFSS  F80.2
14F0:  BRA    14EE
14F2:  BCF    F89.3
14F4:  BCF    F92.3
14F6:  MOVLW  05
14F8:  MOVWF  00
14FA:  DECFSZ 00,F
14FC:  BRA    14FA
14FE:  BCF    F89.2
1500:  BCF    F92.2
....................   i2c_write(0xD1); 
*
11DA:  MOVLW  D1
11DC:  MOVWF  x90
11DE:  RCALL  0F8A
*
1502:  MOVLW  D1
1504:  MOVWF  x90
1506:  RCALL  0F8A
....................   dow  = ds1307_bcd2bin(i2c_read() & 0x7f); 
*
11E0:  MOVLW  01
11E2:  MOVWF  00
11E4:  RCALL  0FF6
11E6:  MOVF   01,W
11E8:  ANDLW  7F
11EA:  MOVWF  x8C
11EC:  MOVWF  x91
11EE:  RCALL  105C
11F0:  MOVFF  01,89
*
1508:  MOVLW  01
150A:  MOVWF  00
150C:  RCALL  0FF6
150E:  MOVF   01,W
1510:  ANDLW  7F
1512:  MOVWF  x8C
1514:  MOVWF  x91
1516:  RCALL  105C
1518:  MOVFF  01,81
....................   day  = ds1307_bcd2bin(i2c_read() & 0x3f); 
*
11F4:  MOVLW  01
11F6:  MOVWF  00
11F8:  RCALL  0FF6
11FA:  MOVF   01,W
11FC:  ANDLW  3F
11FE:  MOVWF  x8C
1200:  MOVWF  x91
1202:  RCALL  105C
1204:  MOVFF  01,86
*
151C:  MOVLW  01
151E:  MOVWF  00
1520:  RCALL  0FF6
1522:  MOVF   01,W
1524:  ANDLW  3F
1526:  MOVWF  x8C
1528:  MOVWF  x91
152A:  RCALL  105C
152C:  MOVFF  01,7E
....................   mth  = ds1307_bcd2bin(i2c_read() & 0x1f); 
*
1208:  MOVLW  01
120A:  MOVWF  00
120C:  RCALL  0FF6
120E:  MOVF   01,W
1210:  ANDLW  1F
1212:  MOVWF  x8C
1214:  MOVWF  x91
1216:  RCALL  105C
1218:  MOVFF  01,87
*
1530:  MOVLW  01
1532:  MOVWF  00
1534:  RCALL  0FF6
1536:  MOVF   01,W
1538:  ANDLW  1F
153A:  MOVWF  x8C
153C:  MOVWF  x91
153E:  RCALL  105C
1540:  MOVFF  01,7F
....................   year = ds1307_bcd2bin(i2c_read(0)); 
*
121C:  CLRF   00
121E:  RCALL  0FF6
1220:  MOVFF  01,8C
1224:  MOVFF  01,91
1228:  RCALL  105C
122A:  MOVFF  01,88
*
1544:  CLRF   00
1546:  RCALL  0FF6
1548:  MOVFF  01,8C
154C:  MOVFF  01,91
1550:  RCALL  105C
1552:  MOVFF  01,80
....................   i2c_stop(); 
*
122E:  BCF    F92.3
1230:  NOP   
1232:  BSF    F92.2
1234:  BTFSS  F80.2
1236:  BRA    1234
1238:  MOVLW  05
123A:  MOVWF  00
123C:  DECFSZ 00,F
123E:  BRA    123C
1240:  BRA    1242
1242:  NOP   
1244:  BSF    F92.3
1246:  MOVLW  05
1248:  MOVWF  00
124A:  DECFSZ 00,F
124C:  BRA    124A
*
1556:  BCF    F92.3
1558:  NOP   
155A:  BSF    F92.2
155C:  BTFSS  F80.2
155E:  BRA    155C
1560:  MOVLW  05
1562:  MOVWF  00
1564:  DECFSZ 00,F
1566:  BRA    1564
1568:  BRA    156A
156A:  NOP   
156C:  BSF    F92.3
156E:  MOVLW  05
1570:  MOVWF  00
1572:  DECFSZ 00,F
1574:  BRA    1572
....................  
.................... #ifndef USE_INTERRUPTS 
....................    enable_interrupts(global); 
*
124E:  MOVLW  C0
1250:  IORWF  FF2,F
*
1576:  MOVLW  C0
1578:  IORWF  FF2,F
.................... #endif 
....................  
.................... } 
....................  
.................... void ds1307_get_time(byte &hr, byte &min, byte &sec){ 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    disable_interrupts(global); 
*
12E2:  BCF    FF2.6
12E4:  BCF    FF2.7
12E6:  BTFSC  FF2.7
12E8:  BRA    12E4
*
157A:  BCF    FF2.6
157C:  BCF    FF2.7
157E:  BTFSC  FF2.7
1580:  BRA    157C
.................... #endif 
....................  
....................   i2c_start(); 
*
12EA:  BSF    F92.3
12EC:  MOVLW  05
12EE:  MOVWF  00
12F0:  DECFSZ 00,F
12F2:  BRA    12F0
12F4:  BSF    F92.2
12F6:  MOVLW  06
12F8:  MOVWF  00
12FA:  DECFSZ 00,F
12FC:  BRA    12FA
12FE:  BCF    F89.3
1300:  BCF    F92.3
1302:  MOVLW  05
1304:  MOVWF  00
1306:  DECFSZ 00,F
1308:  BRA    1306
130A:  BCF    F89.2
130C:  BCF    F92.2
*
1582:  BSF    F92.3
1584:  MOVLW  05
1586:  MOVWF  00
1588:  DECFSZ 00,F
158A:  BRA    1588
158C:  BSF    F92.2
158E:  MOVLW  06
1590:  MOVWF  00
1592:  DECFSZ 00,F
1594:  BRA    1592
1596:  BCF    F89.3
1598:  BCF    F92.3
159A:  MOVLW  05
159C:  MOVWF  00
159E:  DECFSZ 00,F
15A0:  BRA    159E
15A2:  BCF    F89.2
15A4:  BCF    F92.2
....................   i2c_write(0xD0); 
*
130E:  MOVLW  D0
1310:  MOVWF  x90
1312:  RCALL  0F8A
*
15A6:  MOVLW  D0
15A8:  MOVWF  x90
15AA:  RCALL  0F8A
....................   i2c_write(0x00); 
*
1314:  CLRF   x90
1316:  RCALL  0F8A
*
15AC:  CLRF   x90
15AE:  RCALL  0F8A
....................   i2c_start(); 
*
1318:  BSF    F92.3
131A:  MOVLW  05
131C:  MOVWF  00
131E:  DECFSZ 00,F
1320:  BRA    131E
1322:  BSF    F92.2
1324:  MOVLW  06
1326:  MOVWF  00
1328:  DECFSZ 00,F
132A:  BRA    1328
132C:  BTFSS  F80.2
132E:  BRA    132C
1330:  BCF    F89.3
1332:  BCF    F92.3
1334:  MOVLW  05
1336:  MOVWF  00
1338:  DECFSZ 00,F
133A:  BRA    1338
133C:  BCF    F89.2
133E:  BCF    F92.2
*
15B0:  BSF    F92.3
15B2:  MOVLW  05
15B4:  MOVWF  00
15B6:  DECFSZ 00,F
15B8:  BRA    15B6
15BA:  BSF    F92.2
15BC:  MOVLW  06
15BE:  MOVWF  00
15C0:  DECFSZ 00,F
15C2:  BRA    15C0
15C4:  BTFSS  F80.2
15C6:  BRA    15C4
15C8:  BCF    F89.3
15CA:  BCF    F92.3
15CC:  MOVLW  05
15CE:  MOVWF  00
15D0:  DECFSZ 00,F
15D2:  BRA    15D0
15D4:  BCF    F89.2
15D6:  BCF    F92.2
....................   i2c_write(0xD1); 
*
1340:  MOVLW  D1
1342:  MOVWF  x90
1344:  RCALL  0F8A
*
15D8:  MOVLW  D1
15DA:  MOVWF  x90
15DC:  RCALL  0F8A
....................   sec = ds1307_bcd2bin(i2c_read() & 0x7f); 
*
1346:  MOVLW  01
1348:  MOVWF  00
134A:  RCALL  0FF6
134C:  MOVF   01,W
134E:  ANDLW  7F
1350:  MOVWF  x8C
1352:  MOVWF  x91
1354:  RCALL  105C
1356:  MOVFF  01,85
*
15DE:  MOVLW  01
15E0:  MOVWF  00
15E2:  RCALL  0FF6
15E4:  MOVF   01,W
15E6:  ANDLW  7F
15E8:  MOVWF  x8C
15EA:  MOVWF  x91
15EC:  RCALL  105C
15EE:  MOVFF  01,82
....................   min = ds1307_bcd2bin(i2c_read() & 0x7f); 
*
135A:  MOVLW  01
135C:  MOVWF  00
135E:  RCALL  0FF6
1360:  MOVF   01,W
1362:  ANDLW  7F
1364:  MOVWF  x8C
1366:  MOVWF  x91
1368:  RCALL  105C
136A:  MOVFF  01,84
*
15F2:  MOVLW  01
15F4:  MOVWF  00
15F6:  RCALL  0FF6
15F8:  MOVF   01,W
15FA:  ANDLW  7F
15FC:  MOVWF  x8C
15FE:  MOVWF  x91
1600:  RCALL  105C
1602:  MOVFF  01,7D
....................   hr  = ds1307_bcd2bin(i2c_read(0) & 0x3f); 
*
136E:  CLRF   00
1370:  RCALL  0FF6
1372:  MOVF   01,W
1374:  ANDLW  3F
1376:  MOVWF  x8C
1378:  MOVWF  x91
137A:  RCALL  105C
137C:  MOVFF  01,83
*
1606:  CLRF   00
1608:  RCALL  0FF6
160A:  MOVF   01,W
160C:  ANDLW  3F
160E:  MOVWF  x8C
1610:  MOVWF  x91
1612:  RCALL  105C
1614:  MOVFF  01,7C
....................   i2c_stop(); 
*
1380:  BCF    F92.3
1382:  NOP   
1384:  BSF    F92.2
1386:  BTFSS  F80.2
1388:  BRA    1386
138A:  MOVLW  05
138C:  MOVWF  00
138E:  DECFSZ 00,F
1390:  BRA    138E
1392:  BRA    1394
1394:  NOP   
1396:  BSF    F92.3
1398:  MOVLW  05
139A:  MOVWF  00
139C:  DECFSZ 00,F
139E:  BRA    139C
*
1618:  BCF    F92.3
161A:  NOP   
161C:  BSF    F92.2
161E:  BTFSS  F80.2
1620:  BRA    161E
1622:  MOVLW  05
1624:  MOVWF  00
1626:  DECFSZ 00,F
1628:  BRA    1626
162A:  BRA    162C
162C:  NOP   
162E:  BSF    F92.3
1630:  MOVLW  05
1632:  MOVWF  00
1634:  DECFSZ 00,F
1636:  BRA    1634
....................  
.................... #ifndef USE_INTERRUPTS 
....................    enable_interrupts(global); 
*
13A0:  MOVLW  C0
13A2:  IORWF  FF2,F
*
1638:  MOVLW  C0
163A:  IORWF  FF2,F
.................... #endif 
....................  
.................... } 
....................  
....................  
.................... char ds1307_read_nvram_byte(char addr){ 
....................  
....................    char retval; 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    disable_interrupts(global); 
.................... #endif 
....................  
....................    i2c_start(); 
....................    i2c_write(0xD0); 
....................    i2c_write(addr); 
....................  
....................    i2c_start(); 
....................    i2c_write(0xD1); 
....................    retval = i2c_read(0); 
....................    i2c_stop(); 
....................  
....................    return(retval); 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    enable_interrupts(global); 
.................... #endif 
....................  
.................... } 
....................  
.................... void ds1307_write_nvram_byte(char addr, char value){ 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    disable_interrupts(global); 
.................... #endif 
....................  
....................    i2c_start(); 
....................    i2c_write(0xD0); 
....................    i2c_write(addr); 
....................    i2c_write(value); 
....................    i2c_stop(); 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    enable_interrupts(global); 
.................... #endif 
....................  
.................... } 
....................  
.................... void ds1307_get_day_of_week(char* ptr){ 
....................  
....................    byte lday; 
....................    byte lmonth; 
....................    byte lyr; 
....................    byte ldow; 
....................    ds1307_get_date(lday,lmonth,lyr,ldow); 
....................    sprintf(ptr,"%s",days_of_week[ldow]); 
.................... } 
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
....................  
.................... byte ds1307_bin2bcd(byte binary_value){ 
....................  
....................   byte temp; 
....................   byte retval; 
....................  
....................   temp = binary_value; 
....................   retval = 0; 
....................   while(1){ 
....................     if(temp >= 10){ 
....................       temp -= 10; 
....................       retval += 0x10; 
....................     }else{ 
....................       retval += temp; 
....................       break; 
....................     } 
....................   } 
....................   return(retval); 
.................... } 
....................  
.................... byte ds1307_bcd2bin(byte bcd_value){ 
....................  
....................   byte temp; 
....................  
....................   temp = bcd_value; 
*
105C:  MOVFF  91,92
....................   temp >>= 1; 
1060:  BCF    FD8.0
1062:  RRCF   x92,F
....................   temp &= 0x78; 
1064:  MOVLW  78
1066:  ANDWF  x92,F
....................   return(temp + (temp >> 2) + (bcd_value & 0x0f)); 
1068:  RRCF   x92,W
106A:  MOVWF  00
106C:  RRCF   00,F
106E:  MOVLW  3F
1070:  ANDWF  00,F
1072:  MOVF   00,W
1074:  ADDWF  x92,W
1076:  MOVWF  x93
1078:  MOVF   x91,W
107A:  ANDLW  0F
107C:  ADDWF  x93,W
107E:  MOVWF  01
.................... } 
1080:  RETLW  00
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #include <24C512.c> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////   Library for a 24LC512 serial EEPROM                             //// 
.................... ////                                                                   //// 
.................... ////   init_ext_eeprom();    Call before the other functions are used  //// 
.................... ////                                                                   //// 
.................... ////   write_ext_eeprom(a, d);  Write the byte d to the address a      //// 
.................... ////                                                                   //// 
.................... ////   d = read_ext_eeprom(a);   Read the byte d from the address a    //// 
.................... ////                                                                   //// 
.................... ////   The main program may define eeprom_sda                          //// 
.................... ////   and eeprom_scl to override the defaults below.                  //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef EEPROM_SDA 
....................  
.................... #define EEPROM_SDA  PIN_A1 
.................... #define EEPROM_SCL  PIN_A0 
....................  
.................... #endif 
....................  
.................... #use i2c(master, sda=EEPROM_SDA, scl=EEPROM_SCL) 
*
08F4:  MOVLW  08
08F6:  MOVWF  01
08F8:  MOVLW  05
08FA:  MOVWF  00
08FC:  DECFSZ 00,F
08FE:  BRA    08FC
0900:  BCF    F89.0
0902:  BCF    F92.0
0904:  MOVLW  06
0906:  MOVWF  00
0908:  DECFSZ 00,F
090A:  BRA    0908
090C:  RLCF   x93,F
090E:  BCF    F89.1
0910:  BTFSC  FD8.0
0912:  BSF    F92.1
0914:  BTFSS  FD8.0
0916:  BCF    F92.1
0918:  BSF    F92.0
091A:  BTFSS  F80.0
091C:  BRA    091A
091E:  DECFSZ 01,F
0920:  BRA    08F8
0922:  MOVLW  05
0924:  MOVWF  00
0926:  DECFSZ 00,F
0928:  BRA    0926
092A:  BCF    F89.0
092C:  BCF    F92.0
092E:  NOP   
0930:  BSF    F92.1
0932:  MOVLW  06
0934:  MOVWF  00
0936:  DECFSZ 00,F
0938:  BRA    0936
093A:  MOVLW  06
093C:  MOVWF  00
093E:  DECFSZ 00,F
0940:  BRA    093E
0942:  BSF    F92.0
0944:  BTFSS  F80.0
0946:  BRA    0944
0948:  CLRF   01
094A:  MOVLW  06
094C:  MOVWF  00
094E:  DECFSZ 00,F
0950:  BRA    094E
0952:  BTFSC  F80.1
0954:  BSF    01.0
0956:  BCF    F89.0
0958:  BCF    F92.0
095A:  BCF    F89.1
095C:  BCF    F92.1
095E:  RETLW  00
0960:  MOVLW  08
0962:  MOVWF  x92
0964:  MOVFF  00,93
0968:  BSF    F92.1
096A:  MOVLW  06
096C:  MOVWF  00
096E:  DECFSZ 00,F
0970:  BRA    096E
0972:  BSF    F92.0
0974:  BTFSS  F80.0
0976:  BRA    0974
0978:  BTFSC  F80.1
097A:  BSF    FD8.0
097C:  BTFSS  F80.1
097E:  BCF    FD8.0
0980:  RLCF   01,F
0982:  MOVLW  05
0984:  MOVWF  00
0986:  DECFSZ 00,F
0988:  BRA    0986
098A:  BCF    F92.0
098C:  BCF    F89.0
098E:  DECFSZ x92,F
0990:  BRA    0968
0992:  BSF    F92.1
0994:  MOVLW  06
0996:  MOVWF  00
0998:  DECFSZ 00,F
099A:  BRA    0998
099C:  BCF    F89.1
099E:  MOVF   x93,W
09A0:  BTFSS  FD8.2
09A2:  BCF    F92.1
09A4:  NOP   
09A6:  BSF    F92.0
09A8:  BTFSS  F80.0
09AA:  BRA    09A8
09AC:  MOVLW  05
09AE:  MOVWF  00
09B0:  DECFSZ 00,F
09B2:  BRA    09B0
09B4:  BCF    F89.0
09B6:  BCF    F92.0
09B8:  MOVLW  06
09BA:  MOVWF  00
09BC:  DECFSZ 00,F
09BE:  BRA    09BC
09C0:  BCF    F89.1
09C2:  BCF    F92.1
09C4:  GOTO   0A36 (RETURN)
....................  
.................... #define EEPROM_ADDRESS long int 
.................... #define EEPROM_SIZE   65535 
....................  
.................... void init_ext_eeprom() 
.................... { 
....................    output_float(EEPROM_SCL); 
....................    output_float(EEPROM_SDA); 
....................  
.................... } 
....................  
.................... void write_ext_eeprom(long int address, BYTE data) 
.................... { 
....................    short int status; 
....................    i2c_start(); 
*
0E62:  BSF    F92.1
0E64:  MOVLW  05
0E66:  MOVWF  00
0E68:  DECFSZ 00,F
0E6A:  BRA    0E68
0E6C:  BSF    F92.0
0E6E:  MOVLW  06
0E70:  MOVWF  00
0E72:  DECFSZ 00,F
0E74:  BRA    0E72
0E76:  BCF    F89.1
0E78:  BCF    F92.1
0E7A:  MOVLW  05
0E7C:  MOVWF  00
0E7E:  DECFSZ 00,F
0E80:  BRA    0E7E
0E82:  BCF    F89.0
0E84:  BCF    F92.0
....................    i2c_write(0xa0); 
0E86:  MOVLW  A0
0E88:  MOVWF  x93
0E8A:  RCALL  08F4
....................    i2c_write(address>>8); 
0E8C:  MOVFF  8E,91
0E90:  CLRF   x92
0E92:  MOVFF  8E,93
0E96:  RCALL  08F4
....................    i2c_write(address); 
0E98:  MOVFF  8D,93
0E9C:  RCALL  08F4
....................    i2c_write(data); 
0E9E:  MOVFF  8F,93
0EA2:  RCALL  08F4
....................    i2c_stop(); 
0EA4:  BCF    F92.1
0EA6:  NOP   
0EA8:  BSF    F92.0
0EAA:  BTFSS  F80.0
0EAC:  BRA    0EAA
0EAE:  MOVLW  05
0EB0:  MOVWF  00
0EB2:  DECFSZ 00,F
0EB4:  BRA    0EB2
0EB6:  BRA    0EB8
0EB8:  NOP   
0EBA:  BSF    F92.1
0EBC:  MOVLW  05
0EBE:  MOVWF  00
0EC0:  DECFSZ 00,F
0EC2:  BRA    0EC0
....................    i2c_start(); 
0EC4:  BSF    F92.1
0EC6:  MOVLW  05
0EC8:  MOVWF  00
0ECA:  DECFSZ 00,F
0ECC:  BRA    0ECA
0ECE:  BSF    F92.0
0ED0:  MOVLW  06
0ED2:  MOVWF  00
0ED4:  DECFSZ 00,F
0ED6:  BRA    0ED4
0ED8:  BCF    F89.1
0EDA:  BCF    F92.1
0EDC:  MOVLW  05
0EDE:  MOVWF  00
0EE0:  DECFSZ 00,F
0EE2:  BRA    0EE0
0EE4:  BCF    F89.0
0EE6:  BCF    F92.0
....................    status=i2c_write(0xa0); 
0EE8:  MOVLW  A0
0EEA:  MOVWF  x93
0EEC:  RCALL  08F4
0EEE:  MOVF   01,W
0EF0:  BCF    x90.0
0EF2:  BTFSC  01.0
0EF4:  BSF    x90.0
....................    while(status==1) 
....................    { 
0EF6:  BTFSS  x90.0
0EF8:  BRA    0F32
....................       i2c_start(); 
0EFA:  BSF    F92.1
0EFC:  MOVLW  05
0EFE:  MOVWF  00
0F00:  DECFSZ 00,F
0F02:  BRA    0F00
0F04:  BSF    F92.0
0F06:  MOVLW  06
0F08:  MOVWF  00
0F0A:  DECFSZ 00,F
0F0C:  BRA    0F0A
0F0E:  BTFSS  F80.0
0F10:  BRA    0F0E
0F12:  BCF    F89.1
0F14:  BCF    F92.1
0F16:  MOVLW  05
0F18:  MOVWF  00
0F1A:  DECFSZ 00,F
0F1C:  BRA    0F1A
0F1E:  BCF    F89.0
0F20:  BCF    F92.0
....................       status=i2c_write(0xa0); 
0F22:  MOVLW  A0
0F24:  MOVWF  x93
0F26:  RCALL  08F4
0F28:  MOVF   01,W
0F2A:  BCF    x90.0
0F2C:  BTFSC  01.0
0F2E:  BSF    x90.0
....................    } 
0F30:  BRA    0EF6
....................    i2c_stop(); 
0F32:  BCF    F92.1
0F34:  NOP   
0F36:  BSF    F92.0
0F38:  BTFSS  F80.0
0F3A:  BRA    0F38
0F3C:  MOVLW  05
0F3E:  MOVWF  00
0F40:  DECFSZ 00,F
0F42:  BRA    0F40
0F44:  BRA    0F46
0F46:  NOP   
0F48:  BSF    F92.1
0F4A:  MOVLW  05
0F4C:  MOVWF  00
0F4E:  DECFSZ 00,F
0F50:  BRA    0F4E
.................... } 
0F52:  RETLW  00
....................  
.................... BYTE read_ext_eeprom(long int address) { 
....................    BYTE data; 
....................    i2c_start(); 
*
09C8:  BSF    F92.1
09CA:  MOVLW  05
09CC:  MOVWF  00
09CE:  DECFSZ 00,F
09D0:  BRA    09CE
09D2:  BSF    F92.0
09D4:  MOVLW  06
09D6:  MOVWF  00
09D8:  DECFSZ 00,F
09DA:  BRA    09D8
09DC:  BCF    F89.1
09DE:  BCF    F92.1
09E0:  MOVLW  05
09E2:  MOVWF  00
09E4:  DECFSZ 00,F
09E6:  BRA    09E4
09E8:  BCF    F89.0
09EA:  BCF    F92.0
....................    i2c_write(0xa0); 
09EC:  MOVLW  A0
09EE:  MOVWF  x93
09F0:  RCALL  08F4
....................    i2c_write(address>>8); 
09F2:  MOVFF  8F,91
09F6:  CLRF   x92
09F8:  MOVFF  8F,93
09FC:  RCALL  08F4
....................    i2c_write(address); 
09FE:  MOVFF  8E,93
0A02:  RCALL  08F4
....................    i2c_start(); 
0A04:  BSF    F92.1
0A06:  MOVLW  05
0A08:  MOVWF  00
0A0A:  DECFSZ 00,F
0A0C:  BRA    0A0A
0A0E:  BSF    F92.0
0A10:  MOVLW  06
0A12:  MOVWF  00
0A14:  DECFSZ 00,F
0A16:  BRA    0A14
0A18:  BTFSS  F80.0
0A1A:  BRA    0A18
0A1C:  BCF    F89.1
0A1E:  BCF    F92.1
0A20:  MOVLW  05
0A22:  MOVWF  00
0A24:  DECFSZ 00,F
0A26:  BRA    0A24
0A28:  BCF    F89.0
0A2A:  BCF    F92.0
....................    i2c_write(0xa1); 
0A2C:  MOVLW  A1
0A2E:  MOVWF  x93
0A30:  RCALL  08F4
....................    data=i2c_read(0); 
0A32:  CLRF   00
0A34:  BRA    0960
0A36:  MOVFF  01,90
....................    i2c_stop(); 
0A3A:  BCF    F92.1
0A3C:  NOP   
0A3E:  BSF    F92.0
0A40:  BTFSS  F80.0
0A42:  BRA    0A40
0A44:  MOVLW  05
0A46:  MOVWF  00
0A48:  DECFSZ 00,F
0A4A:  BRA    0A48
0A4C:  BRA    0A4E
0A4E:  NOP   
0A50:  BSF    F92.1
0A52:  MOVLW  05
0A54:  MOVWF  00
0A56:  DECFSZ 00,F
0A58:  BRA    0A56
....................    return(data); 
0A5A:  MOVFF  90,01
.................... } 
0A5E:  RETLW  00
....................  
.................... #ROM     0xf00000={0x4523}     //colocar 0 para usuario 1, estan al reves primero esta los dos digitos ultimos y luego los otros 
.................... #ROM     0xf00002={0x5634}     //esto es asignacion de claves para los usuarios 
.................... #define SW PIN A5 
.................... //Vamos a nombrar los registros de proposito GRAL 
.................... int i, b, clave[4], datoi[4], datoe[4], adres,  dato1, dato2, cantidad; 
.................... char datom; 
.................... float valor; 
.................... short flag, espacio_vacio; 
.................... long segundos, auxsegundos; 
.................... int ide, hour, min, day, mth, year, dow, sec, time[8] ; 
.................... int contador; 
....................  
.................... /************************** 
.................... SECCION DE METODOS 
.................... ************************/ 
....................  
.................... void teclado() 
.................... {  
....................      lcd_putc('\f'); 
*
0C62:  MOVLW  0C
0C64:  MOVWF  x93
0C66:  RCALL  0844
....................     segundos=0; 
0C68:  CLRF   x78
0C6A:  CLRF   x77
....................     auxsegundos=0; 
0C6C:  CLRF   x7A
0C6E:  CLRF   x79
....................     b=6; 
0C70:  MOVLW  06
0C72:  MOVWF  x61
....................      for(i=0;i<4; i++) 
0C74:  CLRF   x60
0C76:  MOVF   x60,W
0C78:  SUBLW  03
0C7A:  BTFSS  FD8.0
0C7C:  BRA    0DDC
....................       { 
....................         do{ 
....................             datom=kbd_getc(); // escanea teclado 
0C7E:  RCALL  0B4A
0C80:  MOVFF  01,72
....................             delay_ms(60); 
0C84:  MOVLW  3C
0C86:  MOVWF  x94
0C88:  RCALL  06DC
....................              if(datom!='\0')  //si hay dato valido 
0C8A:  MOVF   x72,F
0C8C:  BTFSC  FD8.2
0C8E:  BRA    0D80
....................               { 
....................                  switch (i+1) 
....................                   { 
0C90:  MOVLW  01
0C92:  ADDWF  x60,W
0C94:  ADDLW  FF
0C96:  ADDLW  FC
0C98:  BTFSC  FD8.0
0C9A:  BRA    0D68
0C9C:  ADDLW  04
0C9E:  GOTO   0DDE
....................                    case 1: 
....................                    lcd_gotoxy(6,1); 
0CA2:  MOVLW  06
0CA4:  MOVWF  x94
0CA6:  MOVLW  01
0CA8:  MOVWF  x95
0CAA:  RCALL  07E8
....................                    lcd_putc(datom); 
0CAC:  MOVFF  72,93
0CB0:  RCALL  0844
....................                    //printf(lcd_putc,datom); 
....................                    clave[0]=datom-0X30; 
0CB2:  MOVLW  30
0CB4:  SUBWF  x72,W
0CB6:  MOVWF  x62
....................                    swap(clave[0]); 
0CB8:  SWAPF  x62,F
....................                    lcd_gotoxy(6,2); 
0CBA:  MOVLW  06
0CBC:  MOVWF  x94
0CBE:  MOVLW  02
0CC0:  MOVWF  x95
0CC2:  RCALL  07E8
....................                    printf(lcd_putc,"*"); 
0CC4:  MOVLW  2A
0CC6:  MOVWF  x93
0CC8:  RCALL  0844
....................                    delay_ms(50); 
0CCA:  MOVLW  32
0CCC:  MOVWF  x94
0CCE:  RCALL  06DC
....................                    break; 
0CD0:  BRA    0D68
....................            
....................                    case 2: 
....................                    lcd_gotoxy(7,1); 
0CD2:  MOVLW  07
0CD4:  MOVWF  x94
0CD6:  MOVLW  01
0CD8:  MOVWF  x95
0CDA:  RCALL  07E8
....................                    lcd_putc(datom); 
0CDC:  MOVFF  72,93
0CE0:  RCALL  0844
....................                   // printf(lcd_putc,datom); 
....................                    clave[1]=datom-0X30; 
0CE2:  MOVLW  30
0CE4:  SUBWF  x72,W
0CE6:  MOVWF  x63
....................                    clave[0]=clave[0]+clave[1]; 
0CE8:  MOVF   x63,W
0CEA:  ADDWF  x62,F
....................                    lcd_gotoxy(7,2); 
0CEC:  MOVLW  07
0CEE:  MOVWF  x94
0CF0:  MOVLW  02
0CF2:  MOVWF  x95
0CF4:  RCALL  07E8
....................                    printf(lcd_putc,"*"); 
0CF6:  MOVLW  2A
0CF8:  MOVWF  x93
0CFA:  RCALL  0844
....................                    delay_ms(50); 
0CFC:  MOVLW  32
0CFE:  MOVWF  x94
0D00:  RCALL  06DC
....................                    break; 
0D02:  BRA    0D68
....................               
....................                    case 3: 
....................                    lcd_gotoxy(8,1); 
0D04:  MOVLW  08
0D06:  MOVWF  x94
0D08:  MOVLW  01
0D0A:  MOVWF  x95
0D0C:  RCALL  07E8
....................                    lcd_putc(datom); 
0D0E:  MOVFF  72,93
0D12:  RCALL  0844
....................                    //printf(lcd_putc,datom); 
....................                    clave[2]=datom-0X30; 
0D14:  MOVLW  30
0D16:  SUBWF  x72,W
0D18:  MOVWF  x64
....................                    swap(clave[2]); 
0D1A:  SWAPF  x64,F
....................                    lcd_gotoxy(8,2); 
0D1C:  MOVLW  08
0D1E:  MOVWF  x94
0D20:  MOVLW  02
0D22:  MOVWF  x95
0D24:  RCALL  07E8
....................                    printf(lcd_putc,"*"); 
0D26:  MOVLW  2A
0D28:  MOVWF  x93
0D2A:  RCALL  0844
....................                    delay_ms(50); 
0D2C:  MOVLW  32
0D2E:  MOVWF  x94
0D30:  RCALL  06DC
....................                    break; 
0D32:  BRA    0D68
....................               
....................                    case 4: 
....................                    lcd_gotoxy(9,1); 
0D34:  MOVLW  09
0D36:  MOVWF  x94
0D38:  MOVLW  01
0D3A:  MOVWF  x95
0D3C:  RCALL  07E8
....................                    lcd_putc(datom); 
0D3E:  MOVFF  72,93
0D42:  RCALL  0844
....................                   // printf(lcd_putc,datom); 
....................                    clave[3]=datom-0X30; 
0D44:  MOVLW  30
0D46:  SUBWF  x72,W
0D48:  MOVWF  x65
....................                    clave[1]=clave[2]+clave[3]; 
0D4A:  MOVF   x65,W
0D4C:  ADDWF  x64,W
0D4E:  MOVWF  x63
....................                    lcd_gotoxy(9,2); 
0D50:  MOVLW  09
0D52:  MOVWF  x94
0D54:  MOVLW  02
0D56:  MOVWF  x95
0D58:  RCALL  07E8
....................                    printf(lcd_putc,"*"); 
0D5A:  MOVLW  2A
0D5C:  MOVWF  x93
0D5E:  RCALL  0844
....................                    delay_ms(50); 
0D60:  MOVLW  32
0D62:  MOVWF  x94
0D64:  RCALL  06DC
....................                    break; 
0D66:  BRA    0D68
....................                  }  
....................                   i++; 
0D68:  INCF   x60,F
....................                   delay_ms(500); 
0D6A:  MOVLW  02
0D6C:  MOVWF  x8C
0D6E:  MOVLW  FA
0D70:  MOVWF  x94
0D72:  RCALL  06DC
0D74:  DECFSZ x8C,F
0D76:  BRA    0D6E
....................                   auxsegundos=0; 
0D78:  CLRF   x7A
0D7A:  CLRF   x79
....................                   segundos=0; 
0D7C:  CLRF   x78
0D7E:  CLRF   x77
....................            } 
....................            auxsegundos++; 
0D80:  INCF   x79,F
0D82:  BTFSC  FD8.2
0D84:  INCF   x7A,F
....................            if(auxsegundos > 20) 
0D86:  MOVF   x7A,F
0D88:  BNZ   0D90
0D8A:  MOVF   x79,W
0D8C:  SUBLW  14
0D8E:  BC    0D9A
....................             { 
....................               segundos++; 
0D90:  INCF   x77,F
0D92:  BTFSC  FD8.2
0D94:  INCF   x78,F
....................               auxsegundos=0; 
0D96:  CLRF   x7A
0D98:  CLRF   x79
....................             } 
....................          
....................       
....................     
....................     }while(i<4 && segundos<6); 
0D9A:  MOVF   x60,W
0D9C:  SUBLW  03
0D9E:  BNC   0DAC
0DA0:  MOVF   x78,F
0DA2:  BNZ   0DAC
0DA4:  MOVF   x77,W
0DA6:  SUBLW  05
0DA8:  BTFSC  FD8.0
0DAA:  BRA    0C7E
....................       clave[i]='#'; 
0DAC:  CLRF   03
0DAE:  MOVF   x60,W
0DB0:  ADDLW  62
0DB2:  MOVWF  FE9
0DB4:  MOVLW  00
0DB6:  ADDWFC 03,W
0DB8:  MOVWF  FEA
0DBA:  MOVLW  23
0DBC:  MOVWF  FEF
....................       lcd_gotoxy(b,1); 
0DBE:  MOVFF  61,94
0DC2:  MOVLW  01
0DC4:  MOVWF  x95
0DC6:  RCALL  07E8
....................       printf(lcd_putc,"*") ; 
0DC8:  MOVLW  2A
0DCA:  MOVWF  x93
0DCC:  RCALL  0844
....................       b++; 
0DCE:  INCF   x61,F
....................       auxsegundos=0; 
0DD0:  CLRF   x7A
0DD2:  CLRF   x79
....................       segundos=0; 
0DD4:  CLRF   x78
0DD6:  CLRF   x77
....................    } 
0DD8:  INCF   x60,F
0DDA:  BRA    0C76
.................... } 
0DDC:  RETLW  00
....................  
....................  
....................  
.................... void un_digito() 
.................... { lcd_putc('\f'); 
*
0E00:  MOVLW  0C
0E02:  MOVWF  x93
0E04:  RCALL  0844
....................   segundos=0; 
0E06:  CLRF   x78
0E08:  CLRF   x77
....................   auxsegundos=0; 
0E0A:  CLRF   x7A
0E0C:  CLRF   x79
....................   flag=false; 
0E0E:  BCF    0E.1
....................   do{ 
....................       datom=kbd_getc(); 
0E10:  RCALL  0B4A
0E12:  MOVFF  01,72
....................       delay_ms(60); 
0E16:  MOVLW  3C
0E18:  MOVWF  x94
0E1A:  RCALL  06DC
....................       if(datom !='\0') 
0E1C:  MOVF   x72,F
0E1E:  BZ    0E38
....................         { 
....................           lcd_gotoxy(8,1);  //coloque el numero digitado  en posicion del LCD 
0E20:  MOVLW  08
0E22:  MOVWF  x94
0E24:  MOVLW  01
0E26:  MOVWF  x95
0E28:  RCALL  07E8
....................           lcd_putc(datom); //visualice datom 
0E2A:  MOVFF  72,93
0E2E:  RCALL  0844
....................           datom=datom-0x30; //quitele ASCII 
0E30:  MOVLW  30
0E32:  SUBWF  x72,F
....................           flag=true; 
0E34:  BSF    0E.1
....................            
....................         }else { 
0E36:  BRA    0E52
....................                auxsegundos++; 
0E38:  INCF   x79,F
0E3A:  BTFSC  FD8.2
0E3C:  INCF   x7A,F
....................                if(auxsegundos>20) 
0E3E:  MOVF   x7A,F
0E40:  BNZ   0E48
0E42:  MOVF   x79,W
0E44:  SUBLW  14
0E46:  BC    0E52
....................                { 
....................                  segundos++; 
0E48:  INCF   x77,F
0E4A:  BTFSC  FD8.2
0E4C:  INCF   x78,F
....................                  auxsegundos=0; 
0E4E:  CLRF   x7A
0E50:  CLRF   x79
....................                 } 
....................        } 
....................          
....................   }while(segundos<6 && flag==false ); 
0E52:  MOVF   x78,F
0E54:  BNZ   0E60
0E56:  MOVF   x77,W
0E58:  SUBLW  05
0E5A:  BNC   0E60
0E5C:  BTFSS  0E.1
0E5E:  BRA    0E10
.................... } 
0E60:  RETLW  00
....................  
.................... void escribir_memoria() 
.................... { 
....................   for(i=0; i<2; i++) 
....................   {  write_eeprom(adres, clave[i]); 
....................      delay_ms(5); 
....................      adres++; 
....................   } 
.................... } 
....................  
.................... void escribir_memoria_ext() 
.................... { 
....................   for(i=0; i<2; i++) 
*
0F54:  CLRF   x60
0F56:  MOVF   x60,W
0F58:  SUBLW  01
0F5A:  BNC   0F88
....................   {  write_ext_eeprom(adres, clave[i]); 
0F5C:  CLRF   03
0F5E:  MOVF   x60,W
0F60:  ADDLW  62
0F62:  MOVWF  FE9
0F64:  MOVLW  00
0F66:  ADDWFC 03,W
0F68:  MOVWF  FEA
0F6A:  MOVFF  FEF,8C
0F6E:  CLRF   x8E
0F70:  MOVFF  6E,8D
0F74:  MOVFF  8C,8F
0F78:  RCALL  0E62
....................      delay_ms(5); 
0F7A:  MOVLW  05
0F7C:  MOVWF  x94
0F7E:  CALL   06DC
....................      adres++; 
0F82:  INCF   x6E,F
....................   } 
0F84:  INCF   x60,F
0F86:  BRA    0F56
.................... } 
0F88:  RETLW  00
....................  
....................  
.................... void leer() 
.................... { 
....................   for(i=0; i<4; i++) 
*
08B8:  CLRF   x60
08BA:  MOVF   x60,W
08BC:  SUBLW  03
08BE:  BNC   08F0
....................   { 
....................     datoi[i]=read_eeprom(i); 
08C0:  CLRF   03
08C2:  MOVF   x60,W
08C4:  ADDLW  66
08C6:  MOVWF  FE9
08C8:  MOVLW  00
08CA:  ADDWFC 03,W
08CC:  MOVWF  FEA
08CE:  MOVFF  FF2,8E
08D2:  BCF    FF2.7
08D4:  MOVFF  60,FA9
08D8:  BCF    FA6.6
08DA:  BCF    FA6.7
08DC:  BSF    FA6.0
08DE:  MOVF   FA8,W
08E0:  BTFSC  x8E.7
08E2:  BSF    FF2.7
08E4:  MOVWF  FEF
....................     delay_ms(1); 
08E6:  MOVLW  01
08E8:  MOVWF  x94
08EA:  RCALL  06DC
....................   } 
08EC:  INCF   x60,F
08EE:  BRA    08BA
.................... } 
08F0:  GOTO   1A52 (RETURN)
....................  
....................  
.................... void leer_men_ext() 
.................... { 
....................   for(i=0; i<4; i++) 
*
0A60:  CLRF   x60
0A62:  MOVF   x60,W
0A64:  SUBLW  03
0A66:  BNC   0A9A
....................   { 
....................     datoe[i]=read_ext_eeprom(i); 
0A68:  CLRF   03
0A6A:  MOVF   x60,W
0A6C:  ADDLW  6A
0A6E:  MOVWF  01
0A70:  MOVLW  00
0A72:  ADDWFC 03,F
0A74:  MOVFF  01,8C
0A78:  MOVFF  03,8D
0A7C:  CLRF   x8F
0A7E:  MOVFF  60,8E
0A82:  RCALL  09C8
0A84:  MOVFF  8D,FEA
0A88:  MOVFF  8C,FE9
0A8C:  MOVFF  01,FEF
....................     delay_ms(1); 
0A90:  MOVLW  01
0A92:  MOVWF  x94
0A94:  RCALL  06DC
....................    } 
0A96:  INCF   x60,F
0A98:  BRA    0A62
.................... } 
0A9A:  GOTO   1A56 (RETURN)
....................  
.................... void hora_fecha(){ 
....................    //ds1307_get_date(day, mth, year, dow); 
....................    ds1307_get_date(time[3], time[4], time[5], time[6]); 
....................    lcd_putc('\f'); 
*
1252:  MOVLW  0C
1254:  MOVWF  x93
1256:  CALL   0844
....................    lcd_gotoxy(1,1); 
125A:  MOVLW  01
125C:  MOVWF  x94
125E:  MOVWF  x95
1260:  CALL   07E8
....................    printf(lcd_putc,"DATE:"); 
1264:  CLRF   x8C
1266:  MOVF   x8C,W
1268:  CALL   0038
126C:  INCF   x8C,F
126E:  MOVWF  00
1270:  MOVWF  x93
1272:  CALL   0844
1276:  MOVLW  05
1278:  SUBWF  x8C,W
127A:  BNZ   1266
....................     
....................    for(i=3;i<6;i++){ 
127C:  MOVLW  03
127E:  MOVWF  x60
1280:  MOVF   x60,W
1282:  SUBLW  05
1284:  BNC   12B6
....................       printf(lcd_putc,"%2d/",time[i]); 
1286:  CLRF   03
1288:  MOVF   x60,W
128A:  ADDLW  83
128C:  MOVWF  FE9
128E:  MOVLW  00
1290:  ADDWFC 03,W
1292:  MOVWF  FEA
1294:  MOVFF  FEF,8C
1298:  MOVFF  8C,8D
129C:  MOVLW  11
129E:  MOVWF  x8E
12A0:  RCALL  10AA
12A2:  MOVLW  2F
12A4:  MOVWF  x93
12A6:  CALL   0844
....................       delay_ms(200); 
12AA:  MOVLW  C8
12AC:  MOVWF  x94
12AE:  CALL   06DC
....................        
....................    } 
12B2:  INCF   x60,F
12B4:  BRA    1280
....................    lcd_gotoxy(16,1); 
12B6:  MOVLW  10
12B8:  MOVWF  x94
12BA:  MOVLW  01
12BC:  MOVWF  x95
12BE:  CALL   07E8
....................    lcd_putc("D "); 
12C2:  CLRF   x8C
12C4:  MOVF   x8C,W
12C6:  CALL   004E
12CA:  IORLW  00
12CC:  BZ    12D8
12CE:  INCF   x8C,F
12D0:  MOVWF  x93
12D2:  CALL   0844
12D6:  BRA    12C4
....................     
....................     for(i=0;i<10;i++){ 
12D8:  CLRF   x60
12DA:  MOVF   x60,W
12DC:  SUBLW  09
12DE:  BTFSS  FD8.0
12E0:  BRA    1432
....................          //ds1307_get_time(hour, min, sec); 
....................          ds1307_get_time(time[0],time[1],time[2]); 
....................          lcd_gotoxy(1,2); 
*
13A4:  MOVLW  01
13A6:  MOVWF  x94
13A8:  MOVLW  02
13AA:  MOVWF  x95
13AC:  CALL   07E8
....................          printf(lcd_putc,"HORA:"); 
13B0:  CLRF   x8C
13B2:  MOVF   x8C,W
13B4:  CALL   0062
13B8:  INCF   x8C,F
13BA:  MOVWF  00
13BC:  MOVWF  x93
13BE:  CALL   0844
13C2:  MOVLW  05
13C4:  SUBWF  x8C,W
13C6:  BNZ   13B2
....................     for(i=0;i<3;i++){ 
13C8:  CLRF   x60
13CA:  MOVF   x60,W
13CC:  SUBLW  02
13CE:  BNC   1400
....................         printf(lcd_putc,"%2d:",time[i]); 
13D0:  CLRF   03
13D2:  MOVF   x60,W
13D4:  ADDLW  83
13D6:  MOVWF  FE9
13D8:  MOVLW  00
13DA:  ADDWFC 03,W
13DC:  MOVWF  FEA
13DE:  MOVFF  FEF,8C
13E2:  MOVFF  8C,8D
13E6:  MOVLW  11
13E8:  MOVWF  x8E
13EA:  RCALL  10AA
13EC:  MOVLW  3A
13EE:  MOVWF  x93
13F0:  CALL   0844
....................         delay_ms(200); 
13F4:  MOVLW  C8
13F6:  MOVWF  x94
13F8:  CALL   06DC
....................     } 
13FC:  INCF   x60,F
13FE:  BRA    13CA
....................      
....................       lcd_gotoxy(16,2); 
1400:  MOVLW  10
1402:  MOVWF  x94
1404:  MOVLW  02
1406:  MOVWF  x95
1408:  CALL   07E8
....................       printf(lcd_putc,"%1d:",time[6]); 
140C:  MOVFF  89,8D
1410:  MOVLW  18
1412:  MOVWF  x8E
1414:  RCALL  10AA
1416:  MOVLW  3A
1418:  MOVWF  x93
141A:  CALL   0844
....................       delay_ms(995); 
141E:  MOVLW  05
1420:  MOVWF  x8C
1422:  MOVLW  C7
1424:  MOVWF  x94
1426:  CALL   06DC
142A:  DECFSZ x8C,F
142C:  BRA    1422
....................     } 
142E:  INCF   x60,F
1430:  BRA    12DA
....................     
.................... } 
1432:  RETLW  00
....................  
.................... void actualizar(){ 
....................     day=0x0A;          //dia27 
....................     mth=0x0A;          //mes 
....................     year=0x15;         //aos21 
....................     dow=0x01;          //dow lun 
....................     hour=0x014;        //hora 7 
....................     min=0x6;           //min   50 
....................     sec=0x00;          //sec 
....................     ds1307_set_date_time(day, mth, year, dow, hour, min,sec); 
....................    } 
....................  
....................  
.................... void buscar_pos(){ 
....................        espacio_vacio=false; 
1434:  BCF    0E.2
....................        adres=0x08; 
1436:  MOVLW  08
1438:  MOVWF  x6E
....................        contador=0; 
143A:  CLRF   x8B
....................       
....................     do{ 
....................          valor=read_ext_eeprom(adres); 
143C:  CLRF   x8F
143E:  MOVFF  6E,8E
1442:  CALL   09C8
1446:  CLRF   x8F
1448:  MOVFF  01,8E
144C:  CALL   0A9E
1450:  MOVFF  03,76
1454:  MOVFF  02,75
1458:  MOVFF  01,74
145C:  MOVFF  00,73
....................          delay_ms(3); 
1460:  MOVLW  03
1462:  MOVWF  x94
1464:  CALL   06DC
....................          
....................         if(valor==0xFF){ 
1468:  MOVFF  76,91
146C:  MOVFF  75,90
1470:  MOVFF  74,8F
1474:  MOVFF  73,8E
1478:  CLRF   x95
147A:  CLRF   x94
147C:  MOVLW  7F
147E:  MOVWF  x93
1480:  MOVLW  86
1482:  MOVWF  x92
1484:  CALL   0AD4
1488:  BNZ   148E
....................             espacio_vacio=true; 
148A:  BSF    0E.2
....................             
....................         }else{ 
148C:  BRA    1492
....................               adres=adres+0x08; 
148E:  MOVLW  08
1490:  ADDWF  x6E,F
....................         } 
....................       contador=contador+1; 
1492:  MOVLW  01
1494:  ADDWF  x8B,F
....................     }while((adres<=0xF0)  && (espacio_vacio==false)); 
1496:  MOVF   x6E,W
1498:  SUBLW  F0
149A:  BNC   14A0
149C:  BTFSS  0E.2
149E:  BRA    143C
....................     //time[0]=contador; 
.................... } 
14A0:  RETLW  00
....................  
.................... void hacer_reporte(){ 
....................    ds1307_get_date(day, mth, year, dow ); 
....................    ds1307_get_time(hour, min, sec); 
....................     time[0]=contador; 
*
163C:  MOVFF  8B,83
....................     time[1]= day; 
1640:  MOVFF  7E,84
....................     time[2]= mth; 
1644:  MOVFF  7F,85
....................     time[3]= year; 
1648:  MOVFF  80,86
....................     time[4]= hour; 
164C:  MOVFF  7C,87
....................     time[5]= min; 
1650:  MOVFF  7D,88
....................     time[6]= sec; 
1654:  MOVFF  82,89
....................     time[7]= ide; 
1658:  MOVFF  7B,8A
.................... } 
165C:  RETLW  00
....................  
....................  
....................  
....................  
.................... void mostrar_reporte(){ 
....................      adres=0x08; 
165E:  MOVLW  08
1660:  MOVWF  x6E
....................      cantidad=0; 
1662:  CLRF   x71
....................  do{ 
....................        for(i=0;i<8;i++){ 
1664:  CLRF   x60
1666:  MOVF   x60,W
1668:  SUBLW  07
166A:  BNC   16A4
....................           time[i]=read_ext_eeprom(adres); 
166C:  CLRF   03
166E:  MOVF   x60,W
1670:  ADDLW  83
1672:  MOVWF  01
1674:  MOVLW  00
1676:  ADDWFC 03,F
1678:  MOVFF  01,8C
167C:  MOVFF  03,8D
1680:  CLRF   x8F
1682:  MOVFF  6E,8E
1686:  CALL   09C8
168A:  MOVFF  8D,FEA
168E:  MOVFF  8C,FE9
1692:  MOVFF  01,FEF
....................           delay_ms(3); 
1696:  MOVLW  03
1698:  MOVWF  x94
169A:  CALL   06DC
....................           adres++; 
169E:  INCF   x6E,F
....................         } 
16A0:  INCF   x60,F
16A2:  BRA    1666
....................              lcd_putc('\f'); 
16A4:  MOVLW  0C
16A6:  MOVWF  x93
16A8:  CALL   0844
....................              lcd_gotoxy(1,1); 
16AC:  MOVLW  01
16AE:  MOVWF  x94
16B0:  MOVWF  x95
16B2:  CALL   07E8
....................              printf(lcd_putc,"##DDMMAAHHMMSSID"); 
16B6:  CLRF   x8C
16B8:  MOVF   x8C,W
16BA:  CALL   0078
16BE:  INCF   x8C,F
16C0:  MOVWF  00
16C2:  MOVWF  x93
16C4:  CALL   0844
16C8:  MOVLW  10
16CA:  SUBWF  x8C,W
16CC:  BNZ   16B8
....................              lcd_gotoxy(1,2); 
16CE:  MOVLW  01
16D0:  MOVWF  x94
16D2:  MOVLW  02
16D4:  MOVWF  x95
16D6:  CALL   07E8
....................              printf(lcd_putc,"%2d",time[0]); 
16DA:  MOVFF  83,8D
16DE:  MOVLW  11
16E0:  MOVWF  x8E
16E2:  RCALL  10AA
....................              lcd_gotoxy(3,2); 
16E4:  MOVLW  03
16E6:  MOVWF  x94
16E8:  MOVLW  02
16EA:  MOVWF  x95
16EC:  CALL   07E8
....................              printf(lcd_putc,"%2d",time[1]); 
16F0:  MOVFF  84,8D
16F4:  MOVLW  11
16F6:  MOVWF  x8E
16F8:  RCALL  10AA
....................              lcd_gotoxy(5,2); 
16FA:  MOVLW  05
16FC:  MOVWF  x94
16FE:  MOVLW  02
1700:  MOVWF  x95
1702:  CALL   07E8
....................              printf(lcd_putc,"%2d",time[2]); 
1706:  MOVFF  85,8D
170A:  MOVLW  11
170C:  MOVWF  x8E
170E:  RCALL  10AA
....................              lcd_gotoxy(7,2); 
1710:  MOVLW  07
1712:  MOVWF  x94
1714:  MOVLW  02
1716:  MOVWF  x95
1718:  CALL   07E8
....................              printf(lcd_putc,"%2d",time[3]); 
171C:  MOVFF  86,8D
1720:  MOVLW  11
1722:  MOVWF  x8E
1724:  RCALL  10AA
....................              lcd_gotoxy(9,2); 
1726:  MOVLW  09
1728:  MOVWF  x94
172A:  MOVLW  02
172C:  MOVWF  x95
172E:  CALL   07E8
....................              printf(lcd_putc,"%2d",time[4]); 
1732:  MOVFF  87,8D
1736:  MOVLW  11
1738:  MOVWF  x8E
173A:  RCALL  10AA
....................              lcd_gotoxy(11,2); 
173C:  MOVLW  0B
173E:  MOVWF  x94
1740:  MOVLW  02
1742:  MOVWF  x95
1744:  CALL   07E8
....................              printf(lcd_putc,"%2d",time[5]); 
1748:  MOVFF  88,8D
174C:  MOVLW  11
174E:  MOVWF  x8E
1750:  RCALL  10AA
....................              lcd_gotoxy(13,2); 
1752:  MOVLW  0D
1754:  MOVWF  x94
1756:  MOVLW  02
1758:  MOVWF  x95
175A:  CALL   07E8
....................              printf(lcd_putc,"%2d",time[6]); 
175E:  MOVFF  89,8D
1762:  MOVLW  11
1764:  MOVWF  x8E
1766:  RCALL  10AA
....................              lcd_gotoxy(15,2); 
1768:  MOVLW  0F
176A:  MOVWF  x94
176C:  MOVLW  02
176E:  MOVWF  x95
1770:  CALL   07E8
....................              printf(lcd_putc,"%2d",time[7]); 
1774:  MOVFF  8A,8D
1778:  MOVLW  11
177A:  MOVWF  x8E
177C:  RCALL  10AA
....................              delay_ms(3000); 
177E:  MOVLW  0C
1780:  MOVWF  x8C
1782:  MOVLW  FA
1784:  MOVWF  x94
1786:  CALL   06DC
178A:  DECFSZ x8C,F
178C:  BRA    1782
....................               
....................        }while(cantidad<=50); 
178E:  MOVF   x71,W
1790:  SUBLW  32
1792:  BTFSC  FD8.0
1794:  BRA    1664
.................... } 
1796:  RETLW  00
....................  
.................... void borrar(){ 
....................    for(i=0;i<80;i++){    
....................       write_ext_eeprom(i, 0xFF); 
....................       delay_ms(2); 
....................     }  
....................   } 
.................... /************************** 
.................... PROGRAMA PRINCIPAL 
.................... ************************/   
....................  
.................... void main() 
.................... {#zero_ram 
1798:  CLRF   FF8
179A:  BCF    FD0.7
179C:  MOVLW  FE
179E:  MOVWF  00
17A0:  MOVLW  08
17A2:  MOVWF  01
17A4:  MOVLW  02
17A6:  MOVWF  FE9
17A8:  MOVLW  00
17AA:  MOVWF  FEA
17AC:  CLRF   FEE
17AE:  DECFSZ 00,F
17B0:  BRA    17AC
17B2:  DECFSZ 01,F
17B4:  BRA    17AC
17B6:  CLRF   FEA
17B8:  CLRF   FE9
17BA:  MOVF   FC1,W
17BC:  ANDLW  C0
17BE:  IORLW  0F
17C0:  MOVWF  FC1
17C2:  MOVLW  07
17C4:  MOVWF  FB4
17C6:  CLRF   05
17C8:  CLRF   06
17CA:  CLRF   0D
17CC:  BCF    0E.0
17CE:  CLRF   0F
17D0:  CLRF   10
17D2:  MOVLW  4C
17D4:  MOVWF  11
17D6:  MOVLW  75
17D8:  MOVWF  12
17DA:  MOVLW  6E
17DC:  MOVWF  13
17DE:  MOVLW  65
17E0:  MOVWF  14
17E2:  MOVLW  73
17E4:  MOVWF  15
17E6:  CLRF   16
17E8:  CLRF   17
17EA:  CLRF   18
17EC:  CLRF   19
17EE:  CLRF   1A
17F0:  CLRF   1B
17F2:  MOVLW  4D
17F4:  MOVWF  1C
17F6:  MOVLW  61
17F8:  MOVWF  1D
17FA:  MOVLW  72
17FC:  MOVWF  1E
17FE:  MOVLW  74
1800:  MOVWF  1F
1802:  MOVLW  65
1804:  MOVWF  20
1806:  MOVLW  73
1808:  MOVWF  21
180A:  CLRF   22
180C:  CLRF   23
180E:  CLRF   24
1810:  CLRF   25
1812:  CLRF   26
1814:  MOVLW  4D
1816:  MOVWF  27
1818:  MOVLW  69
181A:  MOVWF  28
181C:  MOVLW  E9
181E:  MOVWF  29
1820:  MOVLW  72
1822:  MOVWF  2A
1824:  MOVLW  63
1826:  MOVWF  2B
1828:  MOVLW  6F
182A:  MOVWF  2C
182C:  MOVLW  6C
182E:  MOVWF  2D
1830:  MOVLW  65
1832:  MOVWF  2E
1834:  MOVLW  73
1836:  MOVWF  2F
1838:  CLRF   30
183A:  CLRF   31
183C:  MOVLW  4A
183E:  MOVWF  32
1840:  MOVLW  75
1842:  MOVWF  33
1844:  MOVLW  65
1846:  MOVWF  34
1848:  MOVLW  76
184A:  MOVWF  35
184C:  MOVLW  65
184E:  MOVWF  36
1850:  MOVLW  73
1852:  MOVWF  37
1854:  CLRF   38
1856:  CLRF   39
1858:  CLRF   3A
185A:  CLRF   3B
185C:  CLRF   3C
185E:  MOVLW  56
1860:  MOVWF  3D
1862:  MOVLW  69
1864:  MOVWF  3E
1866:  MOVLW  65
1868:  MOVWF  3F
186A:  MOVLW  72
186C:  MOVWF  40
186E:  MOVLW  6E
1870:  MOVWF  41
1872:  MOVLW  65
1874:  MOVWF  42
1876:  MOVLW  73
1878:  MOVWF  43
187A:  CLRF   44
187C:  CLRF   45
187E:  CLRF   46
1880:  CLRF   47
1882:  MOVLW  53
1884:  MOVWF  48
1886:  MOVLW  E1
1888:  MOVWF  49
188A:  MOVLW  62
188C:  MOVWF  4A
188E:  MOVLW  61
1890:  MOVWF  4B
1892:  MOVLW  64
1894:  MOVWF  4C
1896:  MOVLW  6F
1898:  MOVWF  4D
189A:  CLRF   4E
189C:  CLRF   4F
189E:  CLRF   50
18A0:  CLRF   51
18A2:  CLRF   52
18A4:  MOVLW  44
18A6:  MOVWF  53
18A8:  MOVLW  6F
18AA:  MOVWF  54
18AC:  MOVLW  6D
18AE:  MOVWF  55
18B0:  MOVLW  69
18B2:  MOVWF  56
18B4:  MOVLW  6E
18B6:  MOVWF  57
18B8:  MOVLW  67
18BA:  MOVWF  58
18BC:  MOVLW  6F
18BE:  MOVWF  59
18C0:  CLRF   5A
18C2:  CLRF   5B
18C4:  CLRF   5E
.................... inicio:                       //etiquetas siempre a la izquierda 
....................     set_tris_A(0x28);         /*0010 1000 EL 28 SALE ES DIVIDIENDO LOS 8BITS EN 4 DIGITOS Y TOMAR A QUE NUMERO CORRESPONCEN 
18C6:  MOVLW  28
18C8:  MOVWF  F92
....................     RA0 PIN 2  FREE 
....................     RA1 PIN 3  FREE 
....................     RA2 PIN 4  FREE 
....................     RA3 PIN 5  FREE 
....................     RA4 PIN 6  FREE 
....................     RA5 PIN 7  FREE 
....................     RA6 PIN 14 FREE 
....................     RA7 NO EXISTE */ 
....................      
....................     set_tris_B(0x00); /*0000 0000 EL 28 SALE ES DIVIDIENDO LOS 8BITS EN 4 DIGITOS Y TOMAR A QUE NUMERO CORRESPONCEN 
18CA:  MOVLW  00
18CC:  MOVWF  F93
....................     RB0 PIN 33  LED1 
....................     RB1 PIN 34  LED2 
....................     RB2 PIN 35  LED4 
....................     RB3 PIN 36  LED5 
....................     RB4 PIN 37  LED6 
....................     RB5 PIN 38  LED7 
....................     RB6 PIN 39  LED8 
....................     RB7 PIN 40  LED8 */ 
....................      
....................     set_tris_D(0x00); /*0000 0000 EL 28 SALE ES DIVIDIENDO LOS 8BITS EN 4 DIGITOS Y TOMAR A QUE NUMERO CORRESPONCEN 
18CE:  MOVWF  F95
....................     RB0 PIN 33  LED1 
....................     RB1 PIN 34  LED2 
....................     RB2 PIN 35  LED4 
....................     RB3 PIN 36  LED5 
....................     RB4 PIN 37  LED6 
....................     RB5 PIN 38  LED7 
....................     RB6 PIN 39  LED8 
....................     RB7 PIN 40  LED8 */ 
....................      
....................     lcd_init(); 
18D0:  GOTO   0784
....................     kbd_init(); 
18D4:  GOTO   07E4
....................     output_A(0x00);                            //Limpiar el puerto A 
18D8:  CLRF   F92
18DA:  CLRF   F89
....................     output_B(0x00);                           //Limipiar el puerto B 
18DC:  CLRF   F93
18DE:  CLRF   F8A
....................     output_D(0x00);                           //Limipiar el puerto D 
18E0:  CLRF   F95
18E2:  CLRF   F8C
....................    
....................     //actualizar(); 
....................     // borrar(); 
.................... menu: 
....................      lcd_putc('\f');                            //Limpiar pantalla comando 
18E4:  MOVLW  0C
18E6:  MOVWF  x93
18E8:  CALL   0844
....................      lcd_gotoxy(1,1);                           //escribir en a primera fila primera posicion  
18EC:  MOVLW  01
18EE:  MOVWF  x94
18F0:  MOVWF  x95
18F2:  CALL   07E8
....................      lcd_putc("   BIENVENIDOS  ");              //lo que se escribe 
18F6:  CLRF   x8C
18F8:  MOVF   x8C,W
18FA:  CALL   009A
18FE:  IORLW  00
1900:  BZ    190C
1902:  INCF   x8C,F
1904:  MOVWF  x93
1906:  CALL   0844
190A:  BRA    18F8
....................      lcd_gotoxy(1,2);                           //escribir en a primera fila primera posicion  
190C:  MOVLW  01
190E:  MOVWF  x94
1910:  MOVLW  02
1912:  MOVWF  x95
1914:  CALL   07E8
....................      lcd_putc("ARQ. COMP. TARDE"); 
1918:  CLRF   x8C
191A:  MOVF   x8C,W
191C:  CALL   00BC
1920:  IORLW  00
1922:  BZ    192E
1924:  INCF   x8C,F
1926:  MOVWF  x93
1928:  CALL   0844
192C:  BRA    191A
....................      delay_ms(3000); 
192E:  MOVLW  0C
1930:  MOVWF  x8C
1932:  MOVLW  FA
1934:  MOVWF  x94
1936:  CALL   06DC
193A:  DECFSZ x8C,F
193C:  BRA    1932
....................     
....................      lcd_putc('\f');                            //Limpiar pantalla comando 
193E:  MOVLW  0C
1940:  MOVWF  x93
1942:  CALL   0844
....................      lcd_gotoxy(1,1);                           //escribir en a primera fila primera posicion  
1946:  MOVLW  01
1948:  MOVWF  x94
194A:  MOVWF  x95
194C:  CALL   07E8
....................      lcd_putc("MIGUEL MENDEZ");                 //lo que se escribe 
1950:  CLRF   x8C
1952:  MOVF   x8C,W
1954:  CALL   00DE
1958:  IORLW  00
195A:  BZ    1966
195C:  INCF   x8C,F
195E:  MOVWF  x93
1960:  CALL   0844
1964:  BRA    1952
....................      lcd_gotoxy(1,2);                           //escribir en a primera fila primera posicion  
1966:  MOVLW  01
1968:  MOVWF  x94
196A:  MOVLW  02
196C:  MOVWF  x95
196E:  CALL   07E8
....................      lcd_putc(" DAVID MARTINEZ "); 
1972:  CLRF   x8C
1974:  MOVF   x8C,W
1976:  CALL   00FC
197A:  IORLW  00
197C:  BZ    1988
197E:  INCF   x8C,F
1980:  MOVWF  x93
1982:  CALL   0844
1986:  BRA    1974
....................      //printf(lcd_putc,"\f   MIGUEL MENDEZ\n DAVID MARTINEZ ");// /n pase a sigueinet linea 
....................      delay_ms(3000); 
1988:  MOVLW  0C
198A:  MOVWF  x8C
198C:  MOVLW  FA
198E:  MOVWF  x94
1990:  CALL   06DC
1994:  DECFSZ x8C,F
1996:  BRA    198C
....................     
....................      lcd_putc('\f');                           //Limpiar pantalla comando 
1998:  MOVLW  0C
199A:  MOVWF  x93
199C:  CALL   0844
....................      lcd_gotoxy(3,1);                          //escribir en a primera fila primera posicion  
19A0:  MOVLW  03
19A2:  MOVWF  x94
19A4:  MOVLW  01
19A6:  MOVWF  x95
19A8:  CALL   07E8
....................      lcd_putc("GRUPO");                        //lo que se escribe 
19AC:  CLRF   x8C
19AE:  MOVF   x8C,W
19B0:  CALL   011E
19B4:  IORLW  00
19B6:  BZ    19C2
19B8:  INCF   x8C,F
19BA:  MOVWF  x93
19BC:  CALL   0844
19C0:  BRA    19AE
....................      lcd_gotoxy(2,2);                          //escribir en a primera fila primera posicion  
19C2:  MOVLW  02
19C4:  MOVWF  x94
19C6:  MOVWF  x95
19C8:  CALL   07E8
....................      lcd_putc(" NUMERO"); 
19CC:  CLRF   x8C
19CE:  MOVF   x8C,W
19D0:  CALL   0134
19D4:  IORLW  00
19D6:  BZ    19E2
19D8:  INCF   x8C,F
19DA:  MOVWF  x93
19DC:  CALL   0844
19E0:  BRA    19CE
....................      //printf(lcd_putc,"\f        GRUPO   \n       NUMERO    ");// /n pase a sigueinet linea 
....................      delay_ms(3000); 
19E2:  MOVLW  0C
19E4:  MOVWF  x8C
19E6:  MOVLW  FA
19E8:  MOVWF  x94
19EA:  CALL   06DC
19EE:  DECFSZ x8C,F
19F0:  BRA    19E6
....................     
....................      lcd_putc('\f');                          //Limpiar pantalla comando 
19F2:  MOVLW  0C
19F4:  MOVWF  x93
19F6:  CALL   0844
....................      lcd_gotoxy(2,1);                         //escribir en a primera fila primera posicion  
19FA:  MOVLW  02
19FC:  MOVWF  x94
19FE:  MOVLW  01
1A00:  MOVWF  x95
1A02:  CALL   07E8
....................      lcd_putc("POR FAVOR");                   //lo que se escribe 
1A06:  CLRF   x8C
1A08:  MOVF   x8C,W
1A0A:  CALL   014C
1A0E:  IORLW  00
1A10:  BZ    1A1C
1A12:  INCF   x8C,F
1A14:  MOVWF  x93
1A16:  CALL   0844
1A1A:  BRA    1A08
....................      lcd_gotoxy(1,2);                         //escribir en a primera fila primera posicion  
1A1C:  MOVLW  01
1A1E:  MOVWF  x94
1A20:  MOVLW  02
1A22:  MOVWF  x95
1A24:  CALL   07E8
....................      lcd_putc("INGRESE CLAVE"); 
1A28:  CLRF   x8C
1A2A:  MOVF   x8C,W
1A2C:  CALL   0166
1A30:  IORLW  00
1A32:  BZ    1A3E
1A34:  INCF   x8C,F
1A36:  MOVWF  x93
1A38:  CALL   0844
1A3C:  BRA    1A2A
....................      //printf(lcd_putc,"\f    POR FAVOR   \n INGRESE CLAVE");// /n pase a sigueinet linea 
....................      delay_ms(3000); 
1A3E:  MOVLW  0C
1A40:  MOVWF  x8C
1A42:  MOVLW  FA
1A44:  MOVWF  x94
1A46:  CALL   06DC
1A4A:  DECFSZ x8C,F
1A4C:  BRA    1A42
....................     
....................     
....................     
....................      leer();                                    //datoi[0]= clave que le demos datoi[1]=clave que le demos 
1A4E:  GOTO   08B8
....................      leer_men_ext(); 
1A52:  GOTO   0A60
....................      teclado();                                 //clave [0]=0x34, clave[1]=0x78 
1A56:  CALL   0C62
....................       
....................  if(clave[0]==0x12 & clave[1]==0x34) 
1A5A:  MOVF   x62,W
1A5C:  SUBLW  12
1A5E:  BZ    1A64
1A60:  MOVLW  00
1A62:  BRA    1A66
1A64:  MOVLW  01
1A66:  MOVWF  x8C
1A68:  MOVF   x63,W
1A6A:  SUBLW  34
1A6C:  BZ    1A72
1A6E:  MOVLW  00
1A70:  BRA    1A74
1A72:  MOVLW  01
1A74:  ANDWF  x8C,W
1A76:  BTFSC  FD8.2
1A78:  BRA    1C3E
....................    { 
.................... admin:  
....................       lcd_putc('\f');                           //Limpiar pantalla comando 
1A7A:  MOVLW  0C
1A7C:  MOVWF  x93
1A7E:  CALL   0844
....................       lcd_gotoxy(1,1);                          //escribir en a primera fila primera posicion  
1A82:  MOVLW  01
1A84:  MOVWF  x94
1A86:  MOVWF  x95
1A88:  CALL   07E8
....................       lcd_putc("BIENVENIDOS AL");               //lo que se escribe 
1A8C:  CLRF   x8C
1A8E:  MOVF   x8C,W
1A90:  CALL   0184
1A94:  IORLW  00
1A96:  BZ    1AA2
1A98:  INCF   x8C,F
1A9A:  MOVWF  x93
1A9C:  CALL   0844
1AA0:  BRA    1A8E
....................       lcd_gotoxy(4,2);                          //escribir en a primera fila primera posicion  
1AA2:  MOVLW  04
1AA4:  MOVWF  x94
1AA6:  MOVLW  02
1AA8:  MOVWF  x95
1AAA:  CALL   07E8
....................       lcd_putc(" MENU"); 
1AAE:  CLRF   x8C
1AB0:  MOVF   x8C,W
1AB2:  CALL   01A4
1AB6:  IORLW  00
1AB8:  BZ    1AC4
1ABA:  INCF   x8C,F
1ABC:  MOVWF  x93
1ABE:  CALL   0844
1AC2:  BRA    1AB0
....................       //printf(lcd_putc,"\f    POR FAVOR   \n INGRESE CLAVE");// /n pase a sigueinet linea 
....................       delay_ms(3000); 
1AC4:  MOVLW  0C
1AC6:  MOVWF  x8C
1AC8:  MOVLW  FA
1ACA:  MOVWF  x94
1ACC:  CALL   06DC
1AD0:  DECFSZ x8C,F
1AD2:  BRA    1AC8
....................       
....................       lcd_putc('\f');                         //Limpiar pantalla comando 
1AD4:  MOVLW  0C
1AD6:  MOVWF  x93
1AD8:  CALL   0844
....................       lcd_gotoxy(1,1);                        //escribir en a primera fila primera posicion  
1ADC:  MOVLW  01
1ADE:  MOVWF  x94
1AE0:  MOVWF  x95
1AE2:  CALL   07E8
....................       lcd_putc("MARQUE 1 PARA EL");           //lo que se escribe 
1AE6:  CLRF   x8C
1AE8:  MOVF   x8C,W
1AEA:  CALL   01BA
1AEE:  IORLW  00
1AF0:  BZ    1AFC
1AF2:  INCF   x8C,F
1AF4:  MOVWF  x93
1AF6:  CALL   0844
1AFA:  BRA    1AE8
....................       lcd_gotoxy(1,2);                        //escribir en a primera fila primera posicion  
1AFC:  MOVLW  01
1AFE:  MOVWF  x94
1B00:  MOVLW  02
1B02:  MOVWF  x95
1B04:  CALL   07E8
....................       lcd_putc("MENU DE DAVID"); 
1B08:  CLRF   x8C
1B0A:  MOVF   x8C,W
1B0C:  CALL   01DC
1B10:  IORLW  00
1B12:  BZ    1B1E
1B14:  INCF   x8C,F
1B16:  MOVWF  x93
1B18:  CALL   0844
1B1C:  BRA    1B0A
....................       //printf(lcd_putc,"\f    POR FAVOR   \n INGRESE CLAVE");// /n pase a sigueinet linea 
....................       delay_ms(3000); 
1B1E:  MOVLW  0C
1B20:  MOVWF  x8C
1B22:  MOVLW  FA
1B24:  MOVWF  x94
1B26:  CALL   06DC
1B2A:  DECFSZ x8C,F
1B2C:  BRA    1B22
....................     
....................       lcd_putc('\f');                         //Limpiar pantalla comando 
1B2E:  MOVLW  0C
1B30:  MOVWF  x93
1B32:  CALL   0844
....................       lcd_gotoxy(1,1);                        //escribir en a primera fila primera posicion  
1B36:  MOVLW  01
1B38:  MOVWF  x94
1B3A:  MOVWF  x95
1B3C:  CALL   07E8
....................       lcd_putc("MARQUE 2 PARA EL");           //lo que se escribe 
1B40:  CLRF   x8C
1B42:  MOVF   x8C,W
1B44:  CALL   01FA
1B48:  IORLW  00
1B4A:  BZ    1B56
1B4C:  INCF   x8C,F
1B4E:  MOVWF  x93
1B50:  CALL   0844
1B54:  BRA    1B42
....................       lcd_gotoxy(1,2);                        //escribir en a primera fila primera posicion  
1B56:  MOVLW  01
1B58:  MOVWF  x94
1B5A:  MOVLW  02
1B5C:  MOVWF  x95
1B5E:  CALL   07E8
....................       lcd_putc("MENU DE MIGUEL"); 
1B62:  CLRF   x8C
1B64:  MOVF   x8C,W
1B66:  CALL   021C
1B6A:  IORLW  00
1B6C:  BZ    1B78
1B6E:  INCF   x8C,F
1B70:  MOVWF  x93
1B72:  CALL   0844
1B76:  BRA    1B64
....................       //printf(lcd_putc,"\f    POR FAVOR   \n INGRESE CLAVE");// /n pase a sigueinet linea 
....................       delay_ms(3000); 
1B78:  MOVLW  0C
1B7A:  MOVWF  x8C
1B7C:  MOVLW  FA
1B7E:  MOVWF  x94
1B80:  CALL   06DC
1B84:  DECFSZ x8C,F
1B86:  BRA    1B7C
....................      
....................       lcd_putc('\f');                         //Limpiar pantalla comando 
1B88:  MOVLW  0C
1B8A:  MOVWF  x93
1B8C:  CALL   0844
....................       lcd_gotoxy(1,1);                        //escribir en a primera fila primera posicion  
1B90:  MOVLW  01
1B92:  MOVWF  x94
1B94:  MOVWF  x95
1B96:  CALL   07E8
....................       lcd_putc("MARQUE 3 PARA ");             //lo que se escribe 
1B9A:  CLRF   x8C
1B9C:  MOVF   x8C,W
1B9E:  CALL   023C
1BA2:  IORLW  00
1BA4:  BZ    1BB0
1BA6:  INCF   x8C,F
1BA8:  MOVWF  x93
1BAA:  CALL   0844
1BAE:  BRA    1B9C
....................       lcd_gotoxy(1,2);                        //escribir en a primera fila primera posicion  
1BB0:  MOVLW  01
1BB2:  MOVWF  x94
1BB4:  MOVLW  02
1BB6:  MOVWF  x95
1BB8:  CALL   07E8
....................       lcd_putc("SALIR"); 
1BBC:  CLRF   x8C
1BBE:  MOVF   x8C,W
1BC0:  CALL   025C
1BC4:  IORLW  00
1BC6:  BZ    1BD2
1BC8:  INCF   x8C,F
1BCA:  MOVWF  x93
1BCC:  CALL   0844
1BD0:  BRA    1BBE
....................       //printf(lcd_putc,"\f    POR FAVOR   \n INGRESE CLAVE");// /n pase a sigueinet linea 
....................        delay_ms(3000); 
1BD2:  MOVLW  0C
1BD4:  MOVWF  x8C
1BD6:  MOVLW  FA
1BD8:  MOVWF  x94
1BDA:  CALL   06DC
1BDE:  DECFSZ x8C,F
1BE0:  BRA    1BD6
....................     
....................     
....................        //bienvenidos al menu del diseador 
....................        //marque 1 para menu de MIGUEL 
....................        //marque 2 para menu de David 
....................        //marque 3 salir  */ 
....................         
....................         
....................      un_digito(); 
1BE2:  CALL   0E00
....................     if(datom==0x01) 
1BE6:  DECFSZ x72,W
1BE8:  BRA    1BEE
....................      { 
....................         goto David; 
1BEA:  GOTO   24A6
....................      } 
....................      if(datom==0x02) 
1BEE:  MOVF   x72,W
1BF0:  SUBLW  02
1BF2:  BNZ   1BF6
....................      { 
....................         goto Miguel; 
1BF4:  BRA    1C60
....................      } 
....................      if(datom==0x03) 
1BF6:  MOVF   x72,W
1BF8:  SUBLW  03
1BFA:  BNZ   1BFE
....................      { 
....................         reset_cpu();                        //salir 
1BFC:  RESET
....................      } 
....................      lcd_putc('\f');                        //Limpiar pantalla comando 
1BFE:  MOVLW  0C
1C00:  MOVWF  x93
1C02:  CALL   0844
....................      lcd_gotoxy(1,2);                       //escribir en a primera fila primera posicion  
1C06:  MOVLW  01
1C08:  MOVWF  x94
1C0A:  MOVLW  02
1C0C:  MOVWF  x95
1C0E:  CALL   07E8
....................      lcd_putc("ERROR DE NUMERO");           //lo que se escribe 
1C12:  CLRF   x8C
1C14:  MOVF   x8C,W
1C16:  CALL   0272
1C1A:  IORLW  00
1C1C:  BZ    1C28
1C1E:  INCF   x8C,F
1C20:  MOVWF  x93
1C22:  CALL   0844
1C26:  BRA    1C14
....................      delay_ms(3000); 
1C28:  MOVLW  0C
1C2A:  MOVWF  x8C
1C2C:  MOVLW  FA
1C2E:  MOVWF  x94
1C30:  CALL   06DC
1C34:  DECFSZ x8C,F
1C36:  BRA    1C2C
....................      goto admin; 
1C38:  BRA    1A7A
....................      }  
....................      else if(clave[0]==datoe[0] & clave[1]==datoe[1]) 
1C3A:  GOTO   2D08
1C3E:  MOVF   x6A,W
1C40:  SUBWF  x62,W
1C42:  BZ    1C48
1C44:  MOVLW  00
1C46:  BRA    1C4A
1C48:  MOVLW  01
1C4A:  MOVWF  x8C
1C4C:  MOVF   x6B,W
1C4E:  SUBWF  x63,W
1C50:  BZ    1C56
1C52:  MOVLW  00
1C54:  BRA    1C58
1C56:  MOVLW  01
1C58:  ANDWF  x8C,W
1C5A:  BTFSC  FD8.2
1C5C:  GOTO   2484
....................       { 
.................... Miguel:adres=0x00; 
1C60:  CLRF   x6E
....................        /*escribirle al lcd 
....................        bienvenidos al menu del diseador 
....................        marque 1 para cambiar clave 
....................        marque 2 para fecha y hora 
....................        marque 3 para reportes 
....................        marque 4 para motor paso a paso 
....................        marque 5 para servomotor 
....................        marque 6 para cad 
....................        marque 7 para DTMF 
....................        marque 8 para sensores 
....................        marque 9 para salir*/ 
....................       
....................     lcd_putc('\f');                       //Limpiar pantalla comando 
1C62:  MOVLW  0C
1C64:  MOVWF  x93
1C66:  CALL   0844
....................     lcd_gotoxy(1,1);                      //escribir en a primera fila primera posicion  
1C6A:  MOVLW  01
1C6C:  MOVWF  x94
1C6E:  MOVWF  x95
1C70:  CALL   07E8
....................     lcd_putc("MENU USUAR.");              //lo que se escribe 
1C74:  CLRF   x8C
1C76:  MOVF   x8C,W
1C78:  CALL   0292
1C7C:  IORLW  00
1C7E:  BZ    1C8A
1C80:  INCF   x8C,F
1C82:  MOVWF  x93
1C84:  CALL   0844
1C88:  BRA    1C76
....................     lcd_gotoxy(1,2);                      //escribir en a primera fila primera posicion  
1C8A:  MOVLW  01
1C8C:  MOVWF  x94
1C8E:  MOVLW  02
1C90:  MOVWF  x95
1C92:  CALL   07E8
....................     lcd_putc("MIGUEL"); 
1C96:  CLRF   x8C
1C98:  MOVF   x8C,W
1C9A:  CALL   02AE
1C9E:  IORLW  00
1CA0:  BZ    1CAC
1CA2:  INCF   x8C,F
1CA4:  MOVWF  x93
1CA6:  CALL   0844
1CAA:  BRA    1C98
....................     delay_ms(3000);  
1CAC:  MOVLW  0C
1CAE:  MOVWF  x8C
1CB0:  MOVLW  FA
1CB2:  MOVWF  x94
1CB4:  CALL   06DC
1CB8:  DECFSZ x8C,F
1CBA:  BRA    1CB0
....................         
....................     lcd_putc('\f');                       //Limpiar pantalla comando 
1CBC:  MOVLW  0C
1CBE:  MOVWF  x93
1CC0:  CALL   0844
....................     lcd_gotoxy(1,1);                      //escribir en a primera fila primera posicion  
1CC4:  MOVLW  01
1CC6:  MOVWF  x94
1CC8:  MOVWF  x95
1CCA:  CALL   07E8
....................     lcd_putc("MARQUE NUM PARA");          //lo que se escribe 
1CCE:  CLRF   x8C
1CD0:  MOVF   x8C,W
1CD2:  CALL   02C6
1CD6:  IORLW  00
1CD8:  BZ    1CE4
1CDA:  INCF   x8C,F
1CDC:  MOVWF  x93
1CDE:  CALL   0844
1CE2:  BRA    1CD0
....................     lcd_gotoxy(1,2);                      //escribir en a primera fila primera posicion  
1CE4:  MOVLW  01
1CE6:  MOVWF  x94
1CE8:  MOVLW  02
1CEA:  MOVWF  x95
1CEC:  CALL   07E8
....................     lcd_putc("1 CAMBIAR CLAVE"); 
1CF0:  CLRF   x8C
1CF2:  MOVF   x8C,W
1CF4:  CALL   02E6
1CF8:  IORLW  00
1CFA:  BZ    1D06
1CFC:  INCF   x8C,F
1CFE:  MOVWF  x93
1D00:  CALL   0844
1D04:  BRA    1CF2
....................     delay_ms(3000);   
1D06:  MOVLW  0C
1D08:  MOVWF  x8C
1D0A:  MOVLW  FA
1D0C:  MOVWF  x94
1D0E:  CALL   06DC
1D12:  DECFSZ x8C,F
1D14:  BRA    1D0A
....................      
....................     lcd_putc('\f');                      //Limpiar pantalla comando 
1D16:  MOVLW  0C
1D18:  MOVWF  x93
1D1A:  CALL   0844
....................     lcd_gotoxy(1,1);                     //escribir en a primera fila primera posicion  
1D1E:  MOVLW  01
1D20:  MOVWF  x94
1D22:  MOVWF  x95
1D24:  CALL   07E8
....................     lcd_putc("2 FECHA Y HORA");          //lo que se escribe 
1D28:  CLRF   x8C
1D2A:  MOVF   x8C,W
1D2C:  CALL   0306
1D30:  IORLW  00
1D32:  BZ    1D3E
1D34:  INCF   x8C,F
1D36:  MOVWF  x93
1D38:  CALL   0844
1D3C:  BRA    1D2A
....................     lcd_gotoxy(1,2);                     //escribir en a primera fila primera posicion  
1D3E:  MOVLW  01
1D40:  MOVWF  x94
1D42:  MOVLW  02
1D44:  MOVWF  x95
1D46:  CALL   07E8
....................     lcd_putc("3 REPORTES"); 
1D4A:  CLRF   x8C
1D4C:  MOVF   x8C,W
1D4E:  CALL   0326
1D52:  IORLW  00
1D54:  BZ    1D60
1D56:  INCF   x8C,F
1D58:  MOVWF  x93
1D5A:  CALL   0844
1D5E:  BRA    1D4C
....................     delay_ms(3000); 
1D60:  MOVLW  0C
1D62:  MOVWF  x8C
1D64:  MOVLW  FA
1D66:  MOVWF  x94
1D68:  CALL   06DC
1D6C:  DECFSZ x8C,F
1D6E:  BRA    1D64
....................      
....................     lcd_putc('\f');                      //Limpiar pantalla comando 
1D70:  MOVLW  0C
1D72:  MOVWF  x93
1D74:  CALL   0844
....................     lcd_gotoxy(1,1);                     //escribir en a primera fila primera posicion  
1D78:  MOVLW  01
1D7A:  MOVWF  x94
1D7C:  MOVWF  x95
1D7E:  CALL   07E8
....................     lcd_putc("4 MOTOR PASAPAS");        //lo que se escribe 
1D82:  CLRF   x8C
1D84:  MOVF   x8C,W
1D86:  CALL   0342
1D8A:  IORLW  00
1D8C:  BZ    1D98
1D8E:  INCF   x8C,F
1D90:  MOVWF  x93
1D92:  CALL   0844
1D96:  BRA    1D84
....................     lcd_gotoxy(1,2);                     //escribir en a primera fila primera posicion  
1D98:  MOVLW  01
1D9A:  MOVWF  x94
1D9C:  MOVLW  02
1D9E:  MOVWF  x95
1DA0:  CALL   07E8
....................     lcd_putc("5 SERVOMOTOR"); 
1DA4:  CLRF   x8C
1DA6:  MOVF   x8C,W
1DA8:  CALL   0362
1DAC:  IORLW  00
1DAE:  BZ    1DBA
1DB0:  INCF   x8C,F
1DB2:  MOVWF  x93
1DB4:  CALL   0844
1DB8:  BRA    1DA6
....................     delay_ms(3000); 
1DBA:  MOVLW  0C
1DBC:  MOVWF  x8C
1DBE:  MOVLW  FA
1DC0:  MOVWF  x94
1DC2:  CALL   06DC
1DC6:  DECFSZ x8C,F
1DC8:  BRA    1DBE
....................      
....................     lcd_putc('\f');                      //Limpiar pantalla comando 
1DCA:  MOVLW  0C
1DCC:  MOVWF  x93
1DCE:  CALL   0844
....................     lcd_gotoxy(1,1);                     //escribir en a primera fila primera posicion  
1DD2:  MOVLW  01
1DD4:  MOVWF  x94
1DD6:  MOVWF  x95
1DD8:  CALL   07E8
....................     lcd_putc("6 CAD");                   //lo que se escribe 
1DDC:  CLRF   x8C
1DDE:  MOVF   x8C,W
1DE0:  CALL   0380
1DE4:  IORLW  00
1DE6:  BZ    1DF2
1DE8:  INCF   x8C,F
1DEA:  MOVWF  x93
1DEC:  CALL   0844
1DF0:  BRA    1DDE
....................     lcd_gotoxy(1,2);                     //escribir en a primera fila primera posicion  
1DF2:  MOVLW  01
1DF4:  MOVWF  x94
1DF6:  MOVLW  02
1DF8:  MOVWF  x95
1DFA:  CALL   07E8
....................     lcd_putc("7 DTMF"); 
1DFE:  CLRF   x8C
1E00:  MOVF   x8C,W
1E02:  CALL   0396
1E06:  IORLW  00
1E08:  BZ    1E14
1E0A:  INCF   x8C,F
1E0C:  MOVWF  x93
1E0E:  CALL   0844
1E12:  BRA    1E00
....................     delay_ms(3000); 
1E14:  MOVLW  0C
1E16:  MOVWF  x8C
1E18:  MOVLW  FA
1E1A:  MOVWF  x94
1E1C:  CALL   06DC
1E20:  DECFSZ x8C,F
1E22:  BRA    1E18
....................      
....................     lcd_putc('\f');                      //Limpiar pantalla comando 
1E24:  MOVLW  0C
1E26:  MOVWF  x93
1E28:  CALL   0844
....................     lcd_gotoxy(1,1);                     //escribir en a primera fila primera posicion  
1E2C:  MOVLW  01
1E2E:  MOVWF  x94
1E30:  MOVWF  x95
1E32:  CALL   07E8
....................     lcd_putc("8 SENSORES");              //lo que se escribe 
1E36:  CLRF   x8C
1E38:  MOVF   x8C,W
1E3A:  CALL   03AE
1E3E:  IORLW  00
1E40:  BZ    1E4C
1E42:  INCF   x8C,F
1E44:  MOVWF  x93
1E46:  CALL   0844
1E4A:  BRA    1E38
....................     lcd_gotoxy(3,2);                     //escribir en a primera fila primera posicion  
1E4C:  MOVLW  03
1E4E:  MOVWF  x94
1E50:  MOVLW  02
1E52:  MOVWF  x95
1E54:  CALL   07E8
....................     lcd_putc("9 SALIR"); 
1E58:  CLRF   x8C
1E5A:  MOVF   x8C,W
1E5C:  CALL   03CA
1E60:  IORLW  00
1E62:  BZ    1E6E
1E64:  INCF   x8C,F
1E66:  MOVWF  x93
1E68:  CALL   0844
1E6C:  BRA    1E5A
....................     delay_ms(3000); 
1E6E:  MOVLW  0C
1E70:  MOVWF  x8C
1E72:  MOVLW  FA
1E74:  MOVWF  x94
1E76:  CALL   06DC
1E7A:  DECFSZ x8C,F
1E7C:  BRA    1E72
....................      
....................     un_digito(); 
1E7E:  CALL   0E00
....................     if(datom==0x01) 
1E82:  DECFSZ x72,W
1E84:  BRA    2006
....................      { 
....................         lcd_putc('\f');                   //Limpiar pantalla comando 
1E86:  MOVLW  0C
1E88:  MOVWF  x93
1E8A:  CALL   0844
....................         lcd_gotoxy(1,1);                  //escribir en a primera fila primera posicion  
1E8E:  MOVLW  01
1E90:  MOVWF  x94
1E92:  MOVWF  x95
1E94:  CALL   07E8
....................         lcd_putc("MEN CAMBIAR CLAV");     //lo que se escribe 
1E98:  CLRF   x8C
1E9A:  MOVF   x8C,W
1E9C:  CALL   03E2
1EA0:  IORLW  00
1EA2:  BZ    1EAE
1EA4:  INCF   x8C,F
1EA6:  MOVWF  x93
1EA8:  CALL   0844
1EAC:  BRA    1E9A
....................         lcd_gotoxy(3,2);                  //escribir en a primera fila primera posicion  
1EAE:  MOVLW  03
1EB0:  MOVWF  x94
1EB2:  MOVLW  02
1EB4:  MOVWF  x95
1EB6:  CALL   07E8
....................         lcd_putc("DIGITE NU. CLAVE");     //clave[0]= y clave[1]= 
1EBA:  CLRF   x8C
1EBC:  MOVF   x8C,W
1EBE:  CALL   0404
1EC2:  IORLW  00
1EC4:  BZ    1ED0
1EC6:  INCF   x8C,F
1EC8:  MOVWF  x93
1ECA:  CALL   0844
1ECE:  BRA    1EBC
....................         delay_ms(3000); 
1ED0:  MOVLW  0C
1ED2:  MOVWF  x8C
1ED4:  MOVLW  FA
1ED6:  MOVWF  x94
1ED8:  CALL   06DC
1EDC:  DECFSZ x8C,F
1EDE:  BRA    1ED4
....................         teclado(); 
1EE0:  CALL   0C62
....................         
....................         dato1=clave[0]; 
1EE4:  MOVFF  62,6F
....................         dato2=clave[1]; 
1EE8:  MOVFF  63,70
....................         
....................         lcd_putc('\f');                   //Limpiar pantalla comando 
1EEC:  MOVLW  0C
1EEE:  MOVWF  x93
1EF0:  CALL   0844
....................         lcd_gotoxy(1,1);                  //escribir en a primera fila primera posicion  
1EF4:  MOVLW  01
1EF6:  MOVWF  x94
1EF8:  MOVWF  x95
1EFA:  CALL   07E8
....................         lcd_putc("POR FAVOR DIGITE");     //lo que se escribe 
1EFE:  CLRF   x8C
1F00:  MOVF   x8C,W
1F02:  CALL   0426
1F06:  IORLW  00
1F08:  BZ    1F14
1F0A:  INCF   x8C,F
1F0C:  MOVWF  x93
1F0E:  CALL   0844
1F12:  BRA    1F00
....................         lcd_gotoxy(1,2);                  //escribir en a primera fila primera posicion  
1F14:  MOVLW  01
1F16:  MOVWF  x94
1F18:  MOVLW  02
1F1A:  MOVWF  x95
1F1C:  CALL   07E8
....................         lcd_putc("DIGITE NUE.CLAVE");    
1F20:  CLRF   x8C
1F22:  MOVF   x8C,W
1F24:  CALL   0448
1F28:  IORLW  00
1F2A:  BZ    1F36
1F2C:  INCF   x8C,F
1F2E:  MOVWF  x93
1F30:  CALL   0844
1F34:  BRA    1F22
....................         delay_ms(3000); 
1F36:  MOVLW  0C
1F38:  MOVWF  x8C
1F3A:  MOVLW  FA
1F3C:  MOVWF  x94
1F3E:  CALL   06DC
1F42:  DECFSZ x8C,F
1F44:  BRA    1F3A
....................         
....................         teclado(); 
1F46:  CALL   0C62
....................         
....................        if(clave[0]==dato1 & clave[1]==dato2) 
1F4A:  MOVF   x6F,W
1F4C:  SUBWF  x62,W
1F4E:  BZ    1F54
1F50:  MOVLW  00
1F52:  BRA    1F56
1F54:  MOVLW  01
1F56:  MOVWF  x8C
1F58:  MOVF   x70,W
1F5A:  SUBWF  x63,W
1F5C:  BZ    1F62
1F5E:  MOVLW  00
1F60:  BRA    1F64
1F62:  MOVLW  01
1F64:  ANDWF  x8C,W
1F66:  BZ    1FCA
....................        { 
....................          escribir_memoria_ext(); 
1F68:  CALL   0F54
....................          lcd_putc('\f');                   //Limpiar pantalla comando 
1F6C:  MOVLW  0C
1F6E:  MOVWF  x93
1F70:  CALL   0844
....................          lcd_gotoxy(1,1);                  //escribir en a primera fila primera posicion  
1F74:  MOVLW  01
1F76:  MOVWF  x94
1F78:  MOVWF  x95
1F7A:  CALL   07E8
....................          lcd_putc("CLAVE MODIFICADA");     //lo que se escribe 
1F7E:  CLRF   x8C
1F80:  MOVF   x8C,W
1F82:  CALL   046A
1F86:  IORLW  00
1F88:  BZ    1F94
1F8A:  INCF   x8C,F
1F8C:  MOVWF  x93
1F8E:  CALL   0844
1F92:  BRA    1F80
....................          lcd_gotoxy(3,2);                  //escribir en a primera fila primera posicion  
1F94:  MOVLW  03
1F96:  MOVWF  x94
1F98:  MOVLW  02
1F9A:  MOVWF  x95
1F9C:  CALL   07E8
....................          lcd_putc("CON EXITO");    
1FA0:  CLRF   x8C
1FA2:  MOVF   x8C,W
1FA4:  CALL   048C
1FA8:  IORLW  00
1FAA:  BZ    1FB6
1FAC:  INCF   x8C,F
1FAE:  MOVWF  x93
1FB0:  CALL   0844
1FB4:  BRA    1FA2
....................          delay_ms(3000); 
1FB6:  MOVLW  0C
1FB8:  MOVWF  x8C
1FBA:  MOVLW  FA
1FBC:  MOVWF  x94
1FBE:  CALL   06DC
1FC2:  DECFSZ x8C,F
1FC4:  BRA    1FBA
....................          goto Miguel; 
1FC6:  BRA    1C60
....................        } 
....................        else{ 
1FC8:  BRA    2004
....................             lcd_putc('\f');                   //Limpiar pantalla comando 
1FCA:  MOVLW  0C
1FCC:  MOVWF  x93
1FCE:  CALL   0844
....................             lcd_gotoxy(1,1);                  //escribir en a primera fila primera posicion  
1FD2:  MOVLW  01
1FD4:  MOVWF  x94
1FD6:  MOVWF  x95
1FD8:  CALL   07E8
....................             lcd_putc("ERROR DE CLAVE");     //lo que se escribe 
1FDC:  CLRF   x8C
1FDE:  MOVF   x8C,W
1FE0:  CALL   04A6
1FE4:  IORLW  00
1FE6:  BZ    1FF2
1FE8:  INCF   x8C,F
1FEA:  MOVWF  x93
1FEC:  CALL   0844
1FF0:  BRA    1FDE
....................             delay_ms(3000); 
1FF2:  MOVLW  0C
1FF4:  MOVWF  x8C
1FF6:  MOVLW  FA
1FF8:  MOVWF  x94
1FFA:  CALL   06DC
1FFE:  DECFSZ x8C,F
2000:  BRA    1FF6
....................             goto Miguel; 
2002:  BRA    1C60
....................             } 
....................        
....................        
....................      } 
....................      else if(datom==0x02) 
2004:  BRA    2480
2006:  MOVF   x72,W
2008:  SUBLW  02
200A:  BNZ   205C
....................      { 
....................        lcd_putc('\f');                  //Limpiar pantalla comando 
200C:  MOVLW  0C
200E:  MOVWF  x93
2010:  CALL   0844
....................        lcd_gotoxy(1,1);                 //escribir en a primera fila primera posicion  
2014:  MOVLW  01
2016:  MOVWF  x94
2018:  MOVWF  x95
201A:  CALL   07E8
....................        lcd_putc("MEN FECHA Y HORA");    //lo que se escribe 
201E:  CLRF   x8C
2020:  MOVF   x8C,W
2022:  CALL   04C6
2026:  IORLW  00
2028:  BZ    2034
202A:  INCF   x8C,F
202C:  MOVWF  x93
202E:  CALL   0844
2032:  BRA    2020
....................        delay_ms(3000); 
2034:  MOVLW  0C
2036:  MOVWF  x8C
2038:  MOVLW  FA
203A:  MOVWF  x94
203C:  CALL   06DC
2040:  DECFSZ x8C,F
2042:  BRA    2038
....................        hora_fecha(); 
2044:  CALL   117A
....................        delay_ms(10000); 
2048:  MOVLW  28
204A:  MOVWF  x8C
204C:  MOVLW  FA
204E:  MOVWF  x94
2050:  CALL   06DC
2054:  DECFSZ x8C,F
2056:  BRA    204C
....................        goto Miguel; 
2058:  BRA    1C60
....................      } 
....................      else if(datom==0x03)///////////////////////////////////////// 
205A:  BRA    2480
205C:  MOVF   x72,W
205E:  SUBLW  03
2060:  BTFSS  FD8.2
2062:  BRA    2242
....................      { 
....................        ide=0x13; 
2064:  MOVLW  13
2066:  MOVWF  x7B
....................        lcd_putc('\f');                                         //Limpiar pantalla comando 
2068:  MOVLW  0C
206A:  MOVWF  x93
206C:  CALL   0844
....................        lcd_gotoxy(1,1);                                        //escribir en a primera fila primera posicion  
2070:  MOVLW  01
2072:  MOVWF  x94
2074:  MOVWF  x95
2076:  CALL   07E8
....................        lcd_putc("MENU REPORTES");                              //lo que se escribe 
207A:  CLRF   x8C
207C:  MOVF   x8C,W
207E:  CALL   04E8
2082:  IORLW  00
2084:  BZ    2090
2086:  INCF   x8C,F
2088:  MOVWF  x93
208A:  CALL   0844
208E:  BRA    207C
....................        delay_ms(3000); 
2090:  MOVLW  0C
2092:  MOVWF  x8C
2094:  MOVLW  FA
2096:  MOVWF  x94
2098:  CALL   06DC
209C:  DECFSZ x8C,F
209E:  BRA    2094
....................         
....................        lcd_putc('\f');                                         //Limpiar pantalla comando 
20A0:  MOVLW  0C
20A2:  MOVWF  x93
20A4:  CALL   0844
....................        lcd_gotoxy(1,1);                                        //escribir en a primera fila primera posicion  
20A8:  MOVLW  01
20AA:  MOVWF  x94
20AC:  MOVWF  x95
20AE:  CALL   07E8
....................        lcd_putc("1 GENERAR.REPORT");                           //lo que se escribe 
20B2:  CLRF   x8C
20B4:  MOVF   x8C,W
20B6:  CALL   0506
20BA:  IORLW  00
20BC:  BZ    20C8
20BE:  INCF   x8C,F
20C0:  MOVWF  x93
20C2:  CALL   0844
20C6:  BRA    20B4
....................        lcd_gotoxy(1,2);                                        //escribir en a primera fila primera posicion  
20C8:  MOVLW  01
20CA:  MOVWF  x94
20CC:  MOVLW  02
20CE:  MOVWF  x95
20D0:  CALL   07E8
....................        lcd_putc("2 MOSTRAR.REPORT");                           //lo que se escribe 
20D4:  CLRF   x8C
20D6:  MOVF   x8C,W
20D8:  CALL   0528
20DC:  IORLW  00
20DE:  BZ    20EA
20E0:  INCF   x8C,F
20E2:  MOVWF  x93
20E4:  CALL   0844
20E8:  BRA    20D6
....................        delay_ms(3000); 
20EA:  MOVLW  0C
20EC:  MOVWF  x8C
20EE:  MOVLW  FA
20F0:  MOVWF  x94
20F2:  CALL   06DC
20F6:  DECFSZ x8C,F
20F8:  BRA    20EE
....................        un_digito(); 
20FA:  CALL   0E00
....................      if(datom==0x01){ 
20FE:  DECFSZ x72,W
2100:  BRA    21DE
....................          buscar_pos();                                           //CONTADOR, ADDRESS, ESPACIO_VACIO=TRU 
2102:  CALL   1434
....................        if(espacio_vacio==true){ 
2106:  BTFSS  0E.2
2108:  BRA    21A2
....................            
....................             hacer_reporte(); 
210A:  CALL   14A2
....................           for(i=0;i<8;i++){ 
210E:  CLRF   x60
2110:  MOVF   x60,W
2112:  SUBLW  07
2114:  BNC   2144
....................                write_ext_eeprom(adres, time[i]); 
2116:  CLRF   03
2118:  MOVF   x60,W
211A:  ADDLW  83
211C:  MOVWF  FE9
211E:  MOVLW  00
2120:  ADDWFC 03,W
2122:  MOVWF  FEA
2124:  MOVFF  FEF,8C
2128:  CLRF   x8E
212A:  MOVFF  6E,8D
212E:  MOVFF  8C,8F
2132:  CALL   0E62
....................                adres++; 
2136:  INCF   x6E,F
....................                delay_ms(5); 
2138:  MOVLW  05
213A:  MOVWF  x94
213C:  CALL   06DC
....................                 
....................           } 
2140:  INCF   x60,F
2142:  BRA    2110
....................            lcd_putc('\f');                    //Limpiar pantalla comando 
2144:  MOVLW  0C
2146:  MOVWF  x93
2148:  CALL   0844
....................                lcd_gotoxy(1,1);               //escribir en a primera fila primera posicion  
214C:  MOVLW  01
214E:  MOVWF  x94
2150:  MOVWF  x95
2152:  CALL   07E8
....................                lcd_putc("REPORTE GUARDADO");  //lo que se escribe 
2156:  CLRF   x8C
2158:  MOVF   x8C,W
215A:  CALL   054A
215E:  IORLW  00
2160:  BZ    216C
2162:  INCF   x8C,F
2164:  MOVWF  x93
2166:  CALL   0844
216A:  BRA    2158
....................                lcd_gotoxy(1,2);               //escribir en a primera fila primera posicion  
216C:  MOVLW  01
216E:  MOVWF  x94
2170:  MOVLW  02
2172:  MOVWF  x95
2174:  CALL   07E8
....................                lcd_putc("CON EXITO");         //lo que se escribe 
2178:  CLRF   x8C
217A:  MOVF   x8C,W
217C:  CALL   048C
2180:  IORLW  00
2182:  BZ    218E
2184:  INCF   x8C,F
2186:  MOVWF  x93
2188:  CALL   0844
218C:  BRA    217A
....................                delay_ms(3000); 
218E:  MOVLW  0C
2190:  MOVWF  x8C
2192:  MOVLW  FA
2194:  MOVWF  x94
2196:  CALL   06DC
219A:  DECFSZ x8C,F
219C:  BRA    2192
....................                goto Miguel; 
219E:  BRA    1C60
....................         }else{ 
21A0:  BRA    21DC
....................                lcd_putc('\f');               //Limpiar pantalla comando 
21A2:  MOVLW  0C
21A4:  MOVWF  x93
21A6:  CALL   0844
....................                lcd_gotoxy(1,1);              //escribir en a primera fila primera posicion  
21AA:  MOVLW  01
21AC:  MOVWF  x94
21AE:  MOVWF  x95
21B0:  CALL   07E8
....................                lcd_putc("MEMORIA LLENA");    //lo que se escribe 
21B4:  CLRF   x8C
21B6:  MOVF   x8C,W
21B8:  CALL   056C
21BC:  IORLW  00
21BE:  BZ    21CA
21C0:  INCF   x8C,F
21C2:  MOVWF  x93
21C4:  CALL   0844
21C8:  BRA    21B6
....................                delay_ms(3000); 
21CA:  MOVLW  0C
21CC:  MOVWF  x8C
21CE:  MOVLW  FA
21D0:  MOVWF  x94
21D2:  CALL   06DC
21D6:  DECFSZ x8C,F
21D8:  BRA    21CE
....................                goto Miguel; 
21DA:  BRA    1C60
....................                 
....................               } 
....................      }else if (datom==0x02) { 
21DC:  BRA    2240
21DE:  MOVF   x72,W
21E0:  SUBLW  02
21E2:  BNZ   21EC
....................                 mostrar_reporte(); 
21E4:  CALL   165E
....................                 goto Miguel; 
21E8:  BRA    1C60
....................                 } 
....................                  else{ lcd_gotoxy(1,1);               //escribir en a primera fila primera posicion  
21EA:  BRA    2240
21EC:  MOVLW  01
21EE:  MOVWF  x94
21F0:  MOVWF  x95
21F2:  CALL   07E8
....................                        lcd_putc("NUMERO");            //lo que se escribe 
21F6:  CLRF   x8C
21F8:  MOVF   x8C,W
21FA:  CALL   058A
21FE:  IORLW  00
2200:  BZ    220C
2202:  INCF   x8C,F
2204:  MOVWF  x93
2206:  CALL   0844
220A:  BRA    21F8
....................                        lcd_gotoxy(1,2);               //escribir en a primera fila primera posicion  
220C:  MOVLW  01
220E:  MOVWF  x94
2210:  MOVLW  02
2212:  MOVWF  x95
2214:  CALL   07E8
....................                        lcd_putc("ERROR");             //lo que se escribe 
2218:  CLRF   x8C
221A:  MOVF   x8C,W
221C:  CALL   05A2
2220:  IORLW  00
2222:  BZ    222E
2224:  INCF   x8C,F
2226:  MOVWF  x93
2228:  CALL   0844
222C:  BRA    221A
....................                        delay_ms(3000); 
222E:  MOVLW  0C
2230:  MOVWF  x8C
2232:  MOVLW  FA
2234:  MOVWF  x94
2236:  CALL   06DC
223A:  DECFSZ x8C,F
223C:  BRA    2232
....................                        goto Miguel;} 
223E:  BRA    1C60
....................                
....................                 
....................      } 
....................      else if(datom==0x04) 
2240:  BRA    2480
2242:  MOVF   x72,W
2244:  SUBLW  04
2246:  BNZ   22A6
....................      { 
....................       lcd_putc('\f');                        //Limpiar pantalla comando 
2248:  MOVLW  0C
224A:  MOVWF  x93
224C:  CALL   0844
....................        lcd_gotoxy(1,1);                      //escribir en a primera fila primera posicion  
2250:  MOVLW  01
2252:  MOVWF  x94
2254:  MOVWF  x95
2256:  CALL   07E8
....................        lcd_putc("MEN MOTOR PAS A.");         //lo que se escribe 
225A:  CLRF   x8C
225C:  MOVF   x8C,W
225E:  CALL   05B8
2262:  IORLW  00
2264:  BZ    2270
2266:  INCF   x8C,F
2268:  MOVWF  x93
226A:  CALL   0844
226E:  BRA    225C
....................        lcd_gotoxy(3,2);                      //escribir en a primera fila primera posicion  
2270:  MOVLW  03
2272:  MOVWF  x94
2274:  MOVLW  02
2276:  MOVWF  x95
2278:  CALL   07E8
....................        lcd_putc("EN CONSTRUCCION"); 
227C:  CLRF   x8C
227E:  MOVF   x8C,W
2280:  CALL   05DA
2284:  IORLW  00
2286:  BZ    2292
2288:  INCF   x8C,F
228A:  MOVWF  x93
228C:  CALL   0844
2290:  BRA    227E
....................        delay_ms(3000); 
2292:  MOVLW  0C
2294:  MOVWF  x8C
2296:  MOVLW  FA
2298:  MOVWF  x94
229A:  CALL   06DC
229E:  DECFSZ x8C,F
22A0:  BRA    2296
....................        goto Miguel; 
22A2:  BRA    1C60
....................      } 
....................      else if(datom==0x05) 
22A4:  BRA    2480
22A6:  MOVF   x72,W
22A8:  SUBLW  05
22AA:  BNZ   230A
....................      { 
....................        lcd_putc('\f');              //Limpiar pantalla comando 
22AC:  MOVLW  0C
22AE:  MOVWF  x93
22B0:  CALL   0844
....................        lcd_gotoxy(1,1);             //escribir en a primera fila primera posicion  
22B4:  MOVLW  01
22B6:  MOVWF  x94
22B8:  MOVWF  x95
22BA:  CALL   07E8
....................        lcd_putc("MEN SERVOMOTOR");  //lo que se escribe 
22BE:  CLRF   x8C
22C0:  MOVF   x8C,W
22C2:  CALL   05FA
22C6:  IORLW  00
22C8:  BZ    22D4
22CA:  INCF   x8C,F
22CC:  MOVWF  x93
22CE:  CALL   0844
22D2:  BRA    22C0
....................        lcd_gotoxy(3,2);             //escribir en a primera fila primera posicion  
22D4:  MOVLW  03
22D6:  MOVWF  x94
22D8:  MOVLW  02
22DA:  MOVWF  x95
22DC:  CALL   07E8
....................        lcd_putc("EN CONSTRUCCION"); 
22E0:  CLRF   x8C
22E2:  MOVF   x8C,W
22E4:  CALL   05DA
22E8:  IORLW  00
22EA:  BZ    22F6
22EC:  INCF   x8C,F
22EE:  MOVWF  x93
22F0:  CALL   0844
22F4:  BRA    22E2
....................        delay_ms(3000); 
22F6:  MOVLW  0C
22F8:  MOVWF  x8C
22FA:  MOVLW  FA
22FC:  MOVWF  x94
22FE:  CALL   06DC
2302:  DECFSZ x8C,F
2304:  BRA    22FA
....................        goto Miguel; 
2306:  BRA    1C60
....................      } 
....................      else if(datom==0x06) 
2308:  BRA    2480
230A:  MOVF   x72,W
230C:  SUBLW  06
230E:  BNZ   236E
....................      { 
....................        lcd_putc('\f');               //Limpiar pantalla comando 
2310:  MOVLW  0C
2312:  MOVWF  x93
2314:  CALL   0844
....................        lcd_gotoxy(1,1);              //escribir en a primera fila primera posicion  
2318:  MOVLW  01
231A:  MOVWF  x94
231C:  MOVWF  x95
231E:  CALL   07E8
....................        lcd_putc("MENU CAD");         //lo que se escribe 
2322:  CLRF   x8C
2324:  MOVF   x8C,W
2326:  CALL   061A
232A:  IORLW  00
232C:  BZ    2338
232E:  INCF   x8C,F
2330:  MOVWF  x93
2332:  CALL   0844
2336:  BRA    2324
....................        lcd_gotoxy(3,2);              //escribir en a primera fila primera posicion  
2338:  MOVLW  03
233A:  MOVWF  x94
233C:  MOVLW  02
233E:  MOVWF  x95
2340:  CALL   07E8
....................        lcd_putc("EN CONSTRUCCION"); 
2344:  CLRF   x8C
2346:  MOVF   x8C,W
2348:  CALL   05DA
234C:  IORLW  00
234E:  BZ    235A
2350:  INCF   x8C,F
2352:  MOVWF  x93
2354:  CALL   0844
2358:  BRA    2346
....................        delay_ms(3000); 
235A:  MOVLW  0C
235C:  MOVWF  x8C
235E:  MOVLW  FA
2360:  MOVWF  x94
2362:  CALL   06DC
2366:  DECFSZ x8C,F
2368:  BRA    235E
....................        goto Miguel; 
236A:  BRA    1C60
....................      } 
....................      else if(datom==0x07) 
236C:  BRA    2480
236E:  MOVF   x72,W
2370:  SUBLW  07
2372:  BNZ   23D2
....................      { 
....................        lcd_putc('\f');               //Limpiar pantalla comando 
2374:  MOVLW  0C
2376:  MOVWF  x93
2378:  CALL   0844
....................        lcd_gotoxy(1,1);              //escribir en a primera fila primera posicion  
237C:  MOVLW  01
237E:  MOVWF  x94
2380:  MOVWF  x95
2382:  CALL   07E8
....................        lcd_putc("MEN DTMF");         //lo que se escribe 
2386:  CLRF   x8C
2388:  MOVF   x8C,W
238A:  CALL   0634
238E:  IORLW  00
2390:  BZ    239C
2392:  INCF   x8C,F
2394:  MOVWF  x93
2396:  CALL   0844
239A:  BRA    2388
....................        lcd_gotoxy(3,2);              //escribir en a primera fila primera posicion  
239C:  MOVLW  03
239E:  MOVWF  x94
23A0:  MOVLW  02
23A2:  MOVWF  x95
23A4:  CALL   07E8
....................        lcd_putc("EN CONSTRUCCION"); 
23A8:  CLRF   x8C
23AA:  MOVF   x8C,W
23AC:  CALL   05DA
23B0:  IORLW  00
23B2:  BZ    23BE
23B4:  INCF   x8C,F
23B6:  MOVWF  x93
23B8:  CALL   0844
23BC:  BRA    23AA
....................        delay_ms(3000); 
23BE:  MOVLW  0C
23C0:  MOVWF  x8C
23C2:  MOVLW  FA
23C4:  MOVWF  x94
23C6:  CALL   06DC
23CA:  DECFSZ x8C,F
23CC:  BRA    23C2
....................       goto Miguel; 
23CE:  BRA    1C60
....................      } 
....................      else if(datom==0x08) 
23D0:  BRA    2480
23D2:  MOVF   x72,W
23D4:  SUBLW  08
23D6:  BNZ   2436
....................      { 
....................        lcd_putc('\f');              //Limpiar pantalla comando 
23D8:  MOVLW  0C
23DA:  MOVWF  x93
23DC:  CALL   0844
....................        lcd_gotoxy(1,1);             //escribir en a primera fila primera posicion  
23E0:  MOVLW  01
23E2:  MOVWF  x94
23E4:  MOVWF  x95
23E6:  CALL   07E8
....................        lcd_putc("MEN SENSORES");    //lo que se escribe 
23EA:  CLRF   x8C
23EC:  MOVF   x8C,W
23EE:  CALL   064E
23F2:  IORLW  00
23F4:  BZ    2400
23F6:  INCF   x8C,F
23F8:  MOVWF  x93
23FA:  CALL   0844
23FE:  BRA    23EC
....................        lcd_gotoxy(3,2);             //escribir en a primera fila primera posicion  
2400:  MOVLW  03
2402:  MOVWF  x94
2404:  MOVLW  02
2406:  MOVWF  x95
2408:  CALL   07E8
....................        lcd_putc("EN CONSTRUCCION"); 
240C:  CLRF   x8C
240E:  MOVF   x8C,W
2410:  CALL   05DA
2414:  IORLW  00
2416:  BZ    2422
2418:  INCF   x8C,F
241A:  MOVWF  x93
241C:  CALL   0844
2420:  BRA    240E
....................        delay_ms(3000); 
2422:  MOVLW  0C
2424:  MOVWF  x8C
2426:  MOVLW  FA
2428:  MOVWF  x94
242A:  CALL   06DC
242E:  DECFSZ x8C,F
2430:  BRA    2426
....................        goto Miguel; 
2432:  BRA    1C60
....................      } 
....................      else if(datom==0x09) 
2434:  BRA    2480
2436:  MOVF   x72,W
2438:  SUBLW  09
243A:  BNZ   2442
....................      { 
....................       goto admin; 
243C:  GOTO   1A7A
....................      } 
....................      else{ 
2440:  BRA    2480
....................           lcd_putc('\f');                 //Limpiar pantalla comando 
2442:  MOVLW  0C
2444:  MOVWF  x93
2446:  CALL   0844
....................           lcd_gotoxy(1,2);                //escribir en a primera fila primera posicion  
244A:  MOVLW  01
244C:  MOVWF  x94
244E:  MOVLW  02
2450:  MOVWF  x95
2452:  CALL   07E8
....................           lcd_putc("ERROR DE NUMERO");   //lo que se escribe 
2456:  CLRF   x8C
2458:  MOVF   x8C,W
245A:  CALL   0272
245E:  IORLW  00
2460:  BZ    246C
2462:  INCF   x8C,F
2464:  MOVWF  x93
2466:  CALL   0844
246A:  BRA    2458
....................           delay_ms(3000); 
246C:  MOVLW  0C
246E:  MOVWF  x8C
2470:  MOVLW  FA
2472:  MOVWF  x94
2474:  CALL   06DC
2478:  DECFSZ x8C,F
247A:  BRA    2470
....................           goto menu; 
247C:  GOTO   18E4
....................            
....................         } 
....................      } 
....................    
....................     else if(clave[0]==datoe[2] & clave[1]==datoe[3]) 
2480:  GOTO   2D08
2484:  MOVF   x6C,W
2486:  SUBWF  x62,W
2488:  BZ    248E
248A:  MOVLW  00
248C:  BRA    2490
248E:  MOVLW  01
2490:  MOVWF  x8C
2492:  MOVF   x6D,W
2494:  SUBWF  x63,W
2496:  BZ    249C
2498:  MOVLW  00
249A:  BRA    249E
249C:  MOVLW  01
249E:  ANDWF  x8C,W
24A0:  BTFSC  FD8.2
24A2:  GOTO   2CCA
....................     { 
.................... David:adres=0x02; 
24A6:  MOVLW  02
24A8:  MOVWF  x6E
....................        /*escribirle al lcd 
....................        bienvenidos al menu del diseador 
....................        marque 1 para cambiar clave 
....................        marque 2 para fecha y hora 
....................        marque 3 para reportes 
....................        marque 4 para motor paso a paso 
....................        marque 5 para servomotor 
....................        marque 6 para cad 
....................        marque 7 para DTMF 
....................        marque 8 para sensores 
....................        marque 9 para salir*/ 
....................       
....................     lcd_putc('\f');                       //Limpiar pantalla comando 
24AA:  MOVLW  0C
24AC:  MOVWF  x93
24AE:  CALL   0844
....................     lcd_gotoxy(1,1);                      //escribir en a primera fila primera posicion  
24B2:  MOVLW  01
24B4:  MOVWF  x94
24B6:  MOVWF  x95
24B8:  CALL   07E8
....................     lcd_putc("MENU USUAR.");              //lo que se escribe 
24BC:  CLRF   x8C
24BE:  MOVF   x8C,W
24C0:  CALL   0292
24C4:  IORLW  00
24C6:  BZ    24D2
24C8:  INCF   x8C,F
24CA:  MOVWF  x93
24CC:  CALL   0844
24D0:  BRA    24BE
....................     lcd_gotoxy(4,2);                      //escribir en a primera fila primera posicion  
24D2:  MOVLW  04
24D4:  MOVWF  x94
24D6:  MOVLW  02
24D8:  MOVWF  x95
24DA:  CALL   07E8
....................     lcd_putc("DAVID"); 
24DE:  CLRF   x8C
24E0:  MOVF   x8C,W
24E2:  CALL   066C
24E6:  IORLW  00
24E8:  BZ    24F4
24EA:  INCF   x8C,F
24EC:  MOVWF  x93
24EE:  CALL   0844
24F2:  BRA    24E0
....................     delay_ms(3000);  
24F4:  MOVLW  0C
24F6:  MOVWF  x8C
24F8:  MOVLW  FA
24FA:  MOVWF  x94
24FC:  CALL   06DC
2500:  DECFSZ x8C,F
2502:  BRA    24F8
....................         
....................     lcd_putc('\f');                       //Limpiar pantalla comando 
2504:  MOVLW  0C
2506:  MOVWF  x93
2508:  CALL   0844
....................     lcd_gotoxy(1,1);                      //escribir en a primera fila primera posicion  
250C:  MOVLW  01
250E:  MOVWF  x94
2510:  MOVWF  x95
2512:  CALL   07E8
....................     lcd_putc("MARQUE NUM PARA");          //lo que se escribe 
2516:  CLRF   x8C
2518:  MOVF   x8C,W
251A:  CALL   02C6
251E:  IORLW  00
2520:  BZ    252C
2522:  INCF   x8C,F
2524:  MOVWF  x93
2526:  CALL   0844
252A:  BRA    2518
....................     lcd_gotoxy(1,2);                      //escribir en a primera fila primera posicion  
252C:  MOVLW  01
252E:  MOVWF  x94
2530:  MOVLW  02
2532:  MOVWF  x95
2534:  CALL   07E8
....................     lcd_putc("1 CAMBIAR CLAVE"); 
2538:  CLRF   x8C
253A:  MOVF   x8C,W
253C:  CALL   02E6
2540:  IORLW  00
2542:  BZ    254E
2544:  INCF   x8C,F
2546:  MOVWF  x93
2548:  CALL   0844
254C:  BRA    253A
....................     delay_ms(3000);   
254E:  MOVLW  0C
2550:  MOVWF  x8C
2552:  MOVLW  FA
2554:  MOVWF  x94
2556:  CALL   06DC
255A:  DECFSZ x8C,F
255C:  BRA    2552
....................      
....................     lcd_putc('\f');                      //Limpiar pantalla comando 
255E:  MOVLW  0C
2560:  MOVWF  x93
2562:  CALL   0844
....................     lcd_gotoxy(1,1);                     //escribir en a primera fila primera posicion  
2566:  MOVLW  01
2568:  MOVWF  x94
256A:  MOVWF  x95
256C:  CALL   07E8
....................     lcd_putc("2 FECHA Y HORA");          //lo que se escribe 
2570:  CLRF   x8C
2572:  MOVF   x8C,W
2574:  CALL   0306
2578:  IORLW  00
257A:  BZ    2586
257C:  INCF   x8C,F
257E:  MOVWF  x93
2580:  CALL   0844
2584:  BRA    2572
....................     lcd_gotoxy(1,2);                     //escribir en a primera fila primera posicion  
2586:  MOVLW  01
2588:  MOVWF  x94
258A:  MOVLW  02
258C:  MOVWF  x95
258E:  CALL   07E8
....................     lcd_putc("3 REPORTES"); 
2592:  CLRF   x8C
2594:  MOVF   x8C,W
2596:  CALL   0326
259A:  IORLW  00
259C:  BZ    25A8
259E:  INCF   x8C,F
25A0:  MOVWF  x93
25A2:  CALL   0844
25A6:  BRA    2594
....................     delay_ms(3000); 
25A8:  MOVLW  0C
25AA:  MOVWF  x8C
25AC:  MOVLW  FA
25AE:  MOVWF  x94
25B0:  CALL   06DC
25B4:  DECFSZ x8C,F
25B6:  BRA    25AC
....................      
....................     lcd_putc('\f');                     //Limpiar pantalla comando 
25B8:  MOVLW  0C
25BA:  MOVWF  x93
25BC:  CALL   0844
....................     lcd_gotoxy(1,1);                    //escribir en a primera fila primera posicion  
25C0:  MOVLW  01
25C2:  MOVWF  x94
25C4:  MOVWF  x95
25C6:  CALL   07E8
....................     lcd_putc("4 MOTOR PAS A PA");       //lo que se escribe 
25CA:  CLRF   x8C
25CC:  MOVF   x8C,W
25CE:  CALL   0682
25D2:  IORLW  00
25D4:  BZ    25E0
25D6:  INCF   x8C,F
25D8:  MOVWF  x93
25DA:  CALL   0844
25DE:  BRA    25CC
....................     lcd_gotoxy(1,2);                     //escribir en a primera fila primera posicion  
25E0:  MOVLW  01
25E2:  MOVWF  x94
25E4:  MOVLW  02
25E6:  MOVWF  x95
25E8:  CALL   07E8
....................     lcd_putc("5 SERVOMOTOR"); 
25EC:  CLRF   x8C
25EE:  MOVF   x8C,W
25F0:  CALL   0362
25F4:  IORLW  00
25F6:  BZ    2602
25F8:  INCF   x8C,F
25FA:  MOVWF  x93
25FC:  CALL   0844
2600:  BRA    25EE
....................     delay_ms(3000); 
2602:  MOVLW  0C
2604:  MOVWF  x8C
2606:  MOVLW  FA
2608:  MOVWF  x94
260A:  CALL   06DC
260E:  DECFSZ x8C,F
2610:  BRA    2606
....................      
....................     lcd_putc('\f');                      //Limpiar pantalla comando 
2612:  MOVLW  0C
2614:  MOVWF  x93
2616:  CALL   0844
....................     lcd_gotoxy(1,1);                     //escribir en a primera fila primera posicion  
261A:  MOVLW  01
261C:  MOVWF  x94
261E:  MOVWF  x95
2620:  CALL   07E8
....................     lcd_putc("6 CAD");                   //lo que se escribe 
2624:  CLRF   x8C
2626:  MOVF   x8C,W
2628:  CALL   0380
262C:  IORLW  00
262E:  BZ    263A
2630:  INCF   x8C,F
2632:  MOVWF  x93
2634:  CALL   0844
2638:  BRA    2626
....................     lcd_gotoxy(1,2);                     //escribir en a primera fila primera posicion  
263A:  MOVLW  01
263C:  MOVWF  x94
263E:  MOVLW  02
2640:  MOVWF  x95
2642:  CALL   07E8
....................     lcd_putc("7 DTMF"); 
2646:  CLRF   x8C
2648:  MOVF   x8C,W
264A:  CALL   0396
264E:  IORLW  00
2650:  BZ    265C
2652:  INCF   x8C,F
2654:  MOVWF  x93
2656:  CALL   0844
265A:  BRA    2648
....................     delay_ms(3000); 
265C:  MOVLW  0C
265E:  MOVWF  x8C
2660:  MOVLW  FA
2662:  MOVWF  x94
2664:  CALL   06DC
2668:  DECFSZ x8C,F
266A:  BRA    2660
....................      
....................     lcd_putc('\f');                      //Limpiar pantalla comando 
266C:  MOVLW  0C
266E:  MOVWF  x93
2670:  CALL   0844
....................     lcd_gotoxy(1,1);                     //escribir en a primera fila primera posicion  
2674:  MOVLW  01
2676:  MOVWF  x94
2678:  MOVWF  x95
267A:  CALL   07E8
....................     lcd_putc("8 SENSORES");              //lo que se escribe 
267E:  CLRF   x8C
2680:  MOVF   x8C,W
2682:  CALL   03AE
2686:  IORLW  00
2688:  BZ    2694
268A:  INCF   x8C,F
268C:  MOVWF  x93
268E:  CALL   0844
2692:  BRA    2680
....................     lcd_gotoxy(3,2);                     //escribir en a primera fila primera posicion  
2694:  MOVLW  03
2696:  MOVWF  x94
2698:  MOVLW  02
269A:  MOVWF  x95
269C:  CALL   07E8
....................     lcd_putc("9 SALIR"); 
26A0:  CLRF   x8C
26A2:  MOVF   x8C,W
26A4:  CALL   03CA
26A8:  IORLW  00
26AA:  BZ    26B6
26AC:  INCF   x8C,F
26AE:  MOVWF  x93
26B0:  CALL   0844
26B4:  BRA    26A2
....................     delay_ms(3000); 
26B6:  MOVLW  0C
26B8:  MOVWF  x8C
26BA:  MOVLW  FA
26BC:  MOVWF  x94
26BE:  CALL   06DC
26C2:  DECFSZ x8C,F
26C4:  BRA    26BA
....................      
....................     un_digito(); 
26C6:  CALL   0E00
....................     if(datom==0x01) 
26CA:  DECFSZ x72,W
26CC:  BRA    284E
....................      { 
....................        lcd_putc('\f');                   //Limpiar pantalla comando 
26CE:  MOVLW  0C
26D0:  MOVWF  x93
26D2:  CALL   0844
....................        lcd_gotoxy(1,1);                  //escribir en a primera fila primera posicion  
26D6:  MOVLW  01
26D8:  MOVWF  x94
26DA:  MOVWF  x95
26DC:  CALL   07E8
....................        lcd_putc("MEN CAMBIAR CLAV");     //lo que se escribe 
26E0:  CLRF   x8C
26E2:  MOVF   x8C,W
26E4:  CALL   03E2
26E8:  IORLW  00
26EA:  BZ    26F6
26EC:  INCF   x8C,F
26EE:  MOVWF  x93
26F0:  CALL   0844
26F4:  BRA    26E2
....................        lcd_gotoxy(3,2);                  //escribir en a primera fila primera posicion  
26F6:  MOVLW  03
26F8:  MOVWF  x94
26FA:  MOVLW  02
26FC:  MOVWF  x95
26FE:  CALL   07E8
....................        lcd_putc("DIGITE NU. CLAVE");     //clave[0]= y clave[1]= 
2702:  CLRF   x8C
2704:  MOVF   x8C,W
2706:  CALL   0404
270A:  IORLW  00
270C:  BZ    2718
270E:  INCF   x8C,F
2710:  MOVWF  x93
2712:  CALL   0844
2716:  BRA    2704
....................        delay_ms(3000); 
2718:  MOVLW  0C
271A:  MOVWF  x8C
271C:  MOVLW  FA
271E:  MOVWF  x94
2720:  CALL   06DC
2724:  DECFSZ x8C,F
2726:  BRA    271C
....................        teclado(); 
2728:  CALL   0C62
....................         
....................        dato1=clave[0]; 
272C:  MOVFF  62,6F
....................        dato2=clave[1]; 
2730:  MOVFF  63,70
....................         
....................        lcd_putc('\f');                   //Limpiar pantalla comando 
2734:  MOVLW  0C
2736:  MOVWF  x93
2738:  CALL   0844
....................        lcd_gotoxy(1,1);                  //escribir en a primera fila primera posicion  
273C:  MOVLW  01
273E:  MOVWF  x94
2740:  MOVWF  x95
2742:  CALL   07E8
....................        lcd_putc("POR FAVOR DIGITE");     //lo que se escribe 
2746:  CLRF   x8C
2748:  MOVF   x8C,W
274A:  CALL   0426
274E:  IORLW  00
2750:  BZ    275C
2752:  INCF   x8C,F
2754:  MOVWF  x93
2756:  CALL   0844
275A:  BRA    2748
....................        lcd_gotoxy(1,2);                  //escribir en a primera fila primera posicion  
275C:  MOVLW  01
275E:  MOVWF  x94
2760:  MOVLW  02
2762:  MOVWF  x95
2764:  CALL   07E8
....................        lcd_putc("DIGITE NUE.CLAVE");    
2768:  CLRF   x8C
276A:  MOVF   x8C,W
276C:  CALL   0448
2770:  IORLW  00
2772:  BZ    277E
2774:  INCF   x8C,F
2776:  MOVWF  x93
2778:  CALL   0844
277C:  BRA    276A
....................        delay_ms(3000); 
277E:  MOVLW  0C
2780:  MOVWF  x8C
2782:  MOVLW  FA
2784:  MOVWF  x94
2786:  CALL   06DC
278A:  DECFSZ x8C,F
278C:  BRA    2782
....................         
....................        teclado(); 
278E:  CALL   0C62
....................         
....................        if(clave[0]==dato1 & clave[1]==dato2) 
2792:  MOVF   x6F,W
2794:  SUBWF  x62,W
2796:  BZ    279C
2798:  MOVLW  00
279A:  BRA    279E
279C:  MOVLW  01
279E:  MOVWF  x8C
27A0:  MOVF   x70,W
27A2:  SUBWF  x63,W
27A4:  BZ    27AA
27A6:  MOVLW  00
27A8:  BRA    27AC
27AA:  MOVLW  01
27AC:  ANDWF  x8C,W
27AE:  BZ    2812
....................        { 
....................         escribir_memoria_ext(); 
27B0:  CALL   0F54
....................         lcd_putc('\f');                   //Limpiar pantalla comando 
27B4:  MOVLW  0C
27B6:  MOVWF  x93
27B8:  CALL   0844
....................         lcd_gotoxy(1,1);                  //escribir en a primera fila primera posicion  
27BC:  MOVLW  01
27BE:  MOVWF  x94
27C0:  MOVWF  x95
27C2:  CALL   07E8
....................         lcd_putc("CLAVE MODIFICADA");     //lo que se escribe 
27C6:  CLRF   x8C
27C8:  MOVF   x8C,W
27CA:  CALL   046A
27CE:  IORLW  00
27D0:  BZ    27DC
27D2:  INCF   x8C,F
27D4:  MOVWF  x93
27D6:  CALL   0844
27DA:  BRA    27C8
....................         lcd_gotoxy(3,2);                  //escribir en a primera fila primera posicion  
27DC:  MOVLW  03
27DE:  MOVWF  x94
27E0:  MOVLW  02
27E2:  MOVWF  x95
27E4:  CALL   07E8
....................         lcd_putc("CON EXITO");    
27E8:  CLRF   x8C
27EA:  MOVF   x8C,W
27EC:  CALL   048C
27F0:  IORLW  00
27F2:  BZ    27FE
27F4:  INCF   x8C,F
27F6:  MOVWF  x93
27F8:  CALL   0844
27FC:  BRA    27EA
....................         delay_ms(3000); 
27FE:  MOVLW  0C
2800:  MOVWF  x8C
2802:  MOVLW  FA
2804:  MOVWF  x94
2806:  CALL   06DC
280A:  DECFSZ x8C,F
280C:  BRA    2802
....................         goto David; 
280E:  BRA    24A6
....................        } 
....................        else{ 
2810:  BRA    284C
....................        lcd_putc('\f');                   //Limpiar pantalla comando 
2812:  MOVLW  0C
2814:  MOVWF  x93
2816:  CALL   0844
....................        lcd_gotoxy(1,1);                  //escribir en a primera fila primera posicion  
281A:  MOVLW  01
281C:  MOVWF  x94
281E:  MOVWF  x95
2820:  CALL   07E8
....................        lcd_putc("ERROR DE CLAVE");       //lo que se escribe 
2824:  CLRF   x8C
2826:  MOVF   x8C,W
2828:  CALL   04A6
282C:  IORLW  00
282E:  BZ    283A
2830:  INCF   x8C,F
2832:  MOVWF  x93
2834:  CALL   0844
2838:  BRA    2826
....................        delay_ms(3000); 
283A:  MOVLW  0C
283C:  MOVWF  x8C
283E:  MOVLW  FA
2840:  MOVWF  x94
2842:  CALL   06DC
2846:  DECFSZ x8C,F
2848:  BRA    283E
....................        goto David; 
284A:  BRA    24A6
....................        } 
....................         
....................      } 
....................      else if(datom==0x02) 
284C:  BRA    2CC8
284E:  MOVF   x72,W
2850:  SUBLW  02
2852:  BNZ   28A4
....................      { 
....................       lcd_putc('\f');                   //Limpiar pantalla comando 
2854:  MOVLW  0C
2856:  MOVWF  x93
2858:  CALL   0844
....................        lcd_gotoxy(1,1);                 //escribir en a primera fila primera posicion  
285C:  MOVLW  01
285E:  MOVWF  x94
2860:  MOVWF  x95
2862:  CALL   07E8
....................        lcd_putc("MEN FECHA Y HORA");    //lo que se escribe 
2866:  CLRF   x8C
2868:  MOVF   x8C,W
286A:  CALL   04C6
286E:  IORLW  00
2870:  BZ    287C
2872:  INCF   x8C,F
2874:  MOVWF  x93
2876:  CALL   0844
287A:  BRA    2868
....................        delay_ms(3000); 
287C:  MOVLW  0C
287E:  MOVWF  x8C
2880:  MOVLW  FA
2882:  MOVWF  x94
2884:  CALL   06DC
2888:  DECFSZ x8C,F
288A:  BRA    2880
....................        hora_fecha(); 
288C:  CALL   117A
....................        delay_ms(3000); 
2890:  MOVLW  0C
2892:  MOVWF  x8C
2894:  MOVLW  FA
2896:  MOVWF  x94
2898:  CALL   06DC
289C:  DECFSZ x8C,F
289E:  BRA    2894
....................        goto David; 
28A0:  BRA    24A6
....................      } 
....................      else  if(datom==0x03) 
28A2:  BRA    2CC8
28A4:  MOVF   x72,W
28A6:  SUBLW  03
28A8:  BTFSS  FD8.2
28AA:  BRA    2A8A
....................      { 
....................        ide=0x10; 
28AC:  MOVLW  10
28AE:  MOVWF  x7B
....................        lcd_putc('\f');                   //Limpiar pantalla comando 
28B0:  MOVLW  0C
28B2:  MOVWF  x93
28B4:  CALL   0844
....................        lcd_gotoxy(1,1);                  //escribir en a primera fila primera posicion  
28B8:  MOVLW  01
28BA:  MOVWF  x94
28BC:  MOVWF  x95
28BE:  CALL   07E8
....................        lcd_putc("REPORTE");              //lo que se escribe 
28C2:  CLRF   x8C
28C4:  MOVF   x8C,W
28C6:  CALL   06A4
28CA:  IORLW  00
28CC:  BZ    28D8
28CE:  INCF   x8C,F
28D0:  MOVWF  x93
28D2:  CALL   0844
28D6:  BRA    28C4
....................        delay_ms(3000); 
28D8:  MOVLW  0C
28DA:  MOVWF  x8C
28DC:  MOVLW  FA
28DE:  MOVWF  x94
28E0:  CALL   06DC
28E4:  DECFSZ x8C,F
28E6:  BRA    28DC
....................         
....................        lcd_putc('\f');                   //Limpiar pantalla comando 
28E8:  MOVLW  0C
28EA:  MOVWF  x93
28EC:  CALL   0844
....................        lcd_gotoxy(1,1);                  //escribir en a primera fila primera posicion  
28F0:  MOVLW  01
28F2:  MOVWF  x94
28F4:  MOVWF  x95
28F6:  CALL   07E8
....................        lcd_putc("1 GENERAR.REPORT");     //lo que se escribe 
28FA:  CLRF   x8C
28FC:  MOVF   x8C,W
28FE:  CALL   0506
2902:  IORLW  00
2904:  BZ    2910
2906:  INCF   x8C,F
2908:  MOVWF  x93
290A:  CALL   0844
290E:  BRA    28FC
....................        lcd_gotoxy(1,2);                  //escribir en a primera fila primera posicion  
2910:  MOVLW  01
2912:  MOVWF  x94
2914:  MOVLW  02
2916:  MOVWF  x95
2918:  CALL   07E8
....................        lcd_putc("2 MOSTRAR.REPORT");     //lo que se escribe 
291C:  CLRF   x8C
291E:  MOVF   x8C,W
2920:  CALL   0528
2924:  IORLW  00
2926:  BZ    2932
2928:  INCF   x8C,F
292A:  MOVWF  x93
292C:  CALL   0844
2930:  BRA    291E
....................        delay_ms(3000); 
2932:  MOVLW  0C
2934:  MOVWF  x8C
2936:  MOVLW  FA
2938:  MOVWF  x94
293A:  CALL   06DC
293E:  DECFSZ x8C,F
2940:  BRA    2936
....................        un_digito(); 
2942:  CALL   0E00
....................      if(datom==0x01){ 
2946:  DECFSZ x72,W
2948:  BRA    2A26
....................        buscar_pos();                     //CONTADOR, ADDRESS, ESPACIO_VACIO=TRU 
294A:  CALL   1434
....................        if(espacio_vacio==true){ 
294E:  BTFSS  0E.2
2950:  BRA    29EA
....................            
....................           hacer_reporte(); 
2952:  CALL   14A2
....................           for(i=0;i<8;i++){ 
2956:  CLRF   x60
2958:  MOVF   x60,W
295A:  SUBLW  07
295C:  BNC   298C
....................                write_ext_eeprom(adres, time[i]); 
295E:  CLRF   03
2960:  MOVF   x60,W
2962:  ADDLW  83
2964:  MOVWF  FE9
2966:  MOVLW  00
2968:  ADDWFC 03,W
296A:  MOVWF  FEA
296C:  MOVFF  FEF,8C
2970:  CLRF   x8E
2972:  MOVFF  6E,8D
2976:  MOVFF  8C,8F
297A:  CALL   0E62
....................                adres++; 
297E:  INCF   x6E,F
....................                delay_ms(5); 
2980:  MOVLW  05
2982:  MOVWF  x94
2984:  CALL   06DC
....................           } 
2988:  INCF   x60,F
298A:  BRA    2958
....................            lcd_putc('\f');                    //Limpiar pantalla comando 
298C:  MOVLW  0C
298E:  MOVWF  x93
2990:  CALL   0844
....................                lcd_gotoxy(1,1);               //escribir en a primera fila primera posicion  
2994:  MOVLW  01
2996:  MOVWF  x94
2998:  MOVWF  x95
299A:  CALL   07E8
....................                lcd_putc("REPORTE GUARDADO");  //lo que se escribe 
299E:  CLRF   x8C
29A0:  MOVF   x8C,W
29A2:  CALL   054A
29A6:  IORLW  00
29A8:  BZ    29B4
29AA:  INCF   x8C,F
29AC:  MOVWF  x93
29AE:  CALL   0844
29B2:  BRA    29A0
....................                lcd_gotoxy(1,2);               //escribir en a primera fila primera posicion  
29B4:  MOVLW  01
29B6:  MOVWF  x94
29B8:  MOVLW  02
29BA:  MOVWF  x95
29BC:  CALL   07E8
....................                lcd_putc("CON EXITO");         //lo que se escribe 
29C0:  CLRF   x8C
29C2:  MOVF   x8C,W
29C4:  CALL   048C
29C8:  IORLW  00
29CA:  BZ    29D6
29CC:  INCF   x8C,F
29CE:  MOVWF  x93
29D0:  CALL   0844
29D4:  BRA    29C2
....................                delay_ms(3000); 
29D6:  MOVLW  0C
29D8:  MOVWF  x8C
29DA:  MOVLW  FA
29DC:  MOVWF  x94
29DE:  CALL   06DC
29E2:  DECFSZ x8C,F
29E4:  BRA    29DA
....................                goto David; 
29E6:  BRA    24A6
....................         }else{ 
29E8:  BRA    2A24
....................                lcd_putc('\f');               //Limpiar pantalla comando 
29EA:  MOVLW  0C
29EC:  MOVWF  x93
29EE:  CALL   0844
....................                lcd_gotoxy(1,1);              //escribir en a primera fila primera posicion  
29F2:  MOVLW  01
29F4:  MOVWF  x94
29F6:  MOVWF  x95
29F8:  CALL   07E8
....................                lcd_putc("MEMORIA LLENA");    //lo que se escribe 
29FC:  CLRF   x8C
29FE:  MOVF   x8C,W
2A00:  CALL   056C
2A04:  IORLW  00
2A06:  BZ    2A12
2A08:  INCF   x8C,F
2A0A:  MOVWF  x93
2A0C:  CALL   0844
2A10:  BRA    29FE
....................                delay_ms(3000); 
2A12:  MOVLW  0C
2A14:  MOVWF  x8C
2A16:  MOVLW  FA
2A18:  MOVWF  x94
2A1A:  CALL   06DC
2A1E:  DECFSZ x8C,F
2A20:  BRA    2A16
....................                goto David; 
2A22:  BRA    24A6
....................                 
....................               } 
....................      }else if (datom==0x02) { 
2A24:  BRA    2A88
2A26:  MOVF   x72,W
2A28:  SUBLW  02
2A2A:  BNZ   2A34
....................                   mostrar_reporte(); 
2A2C:  CALL   165E
....................                   goto David; 
2A30:  BRA    24A6
....................                 } 
....................                    else{ lcd_gotoxy(1,1);               //escribir en a primera fila primera posicion  
2A32:  BRA    2A88
2A34:  MOVLW  01
2A36:  MOVWF  x94
2A38:  MOVWF  x95
2A3A:  CALL   07E8
....................                        lcd_putc("NUMERO");              //lo que se escribe 
2A3E:  CLRF   x8C
2A40:  MOVF   x8C,W
2A42:  CALL   058A
2A46:  IORLW  00
2A48:  BZ    2A54
2A4A:  INCF   x8C,F
2A4C:  MOVWF  x93
2A4E:  CALL   0844
2A52:  BRA    2A40
....................                        lcd_gotoxy(1,2);                //escribir en a primera fila primera posicion  
2A54:  MOVLW  01
2A56:  MOVWF  x94
2A58:  MOVLW  02
2A5A:  MOVWF  x95
2A5C:  CALL   07E8
....................                        lcd_putc("ERROR");              //lo que se escribe 
2A60:  CLRF   x8C
2A62:  MOVF   x8C,W
2A64:  CALL   05A2
2A68:  IORLW  00
2A6A:  BZ    2A76
2A6C:  INCF   x8C,F
2A6E:  MOVWF  x93
2A70:  CALL   0844
2A74:  BRA    2A62
....................                        delay_ms(3000); 
2A76:  MOVLW  0C
2A78:  MOVWF  x8C
2A7A:  MOVLW  FA
2A7C:  MOVWF  x94
2A7E:  CALL   06DC
2A82:  DECFSZ x8C,F
2A84:  BRA    2A7A
....................                        goto David;} 
2A86:  BRA    24A6
....................                 
....................      } 
....................      else if(datom==0x04) 
2A88:  BRA    2CC8
2A8A:  MOVF   x72,W
2A8C:  SUBLW  04
2A8E:  BNZ   2AEE
....................      { 
....................        lcd_putc('\f');               //Limpiar pantalla comando 
2A90:  MOVLW  0C
2A92:  MOVWF  x93
2A94:  CALL   0844
....................        lcd_gotoxy(1,1);              //escribir en a primera fila primera posicion  
2A98:  MOVLW  01
2A9A:  MOVWF  x94
2A9C:  MOVWF  x95
2A9E:  CALL   07E8
....................        lcd_putc("MEN MOTOR PAS A."); //lo que se escribe 
2AA2:  CLRF   x8C
2AA4:  MOVF   x8C,W
2AA6:  CALL   05B8
2AAA:  IORLW  00
2AAC:  BZ    2AB8
2AAE:  INCF   x8C,F
2AB0:  MOVWF  x93
2AB2:  CALL   0844
2AB6:  BRA    2AA4
....................        lcd_gotoxy(3,2);              //escribir en a primera fila primera posicion  
2AB8:  MOVLW  03
2ABA:  MOVWF  x94
2ABC:  MOVLW  02
2ABE:  MOVWF  x95
2AC0:  CALL   07E8
....................        lcd_putc("EN CONSTRUCCION"); 
2AC4:  CLRF   x8C
2AC6:  MOVF   x8C,W
2AC8:  CALL   05DA
2ACC:  IORLW  00
2ACE:  BZ    2ADA
2AD0:  INCF   x8C,F
2AD2:  MOVWF  x93
2AD4:  CALL   0844
2AD8:  BRA    2AC6
....................        delay_ms(3000); 
2ADA:  MOVLW  0C
2ADC:  MOVWF  x8C
2ADE:  MOVLW  FA
2AE0:  MOVWF  x94
2AE2:  CALL   06DC
2AE6:  DECFSZ x8C,F
2AE8:  BRA    2ADE
....................        goto David; 
2AEA:  BRA    24A6
....................      } 
....................      else if(datom==0x05) 
2AEC:  BRA    2CC8
2AEE:  MOVF   x72,W
2AF0:  SUBLW  05
2AF2:  BNZ   2B52
....................      { 
....................        lcd_putc('\f');              //Limpiar pantalla comando 
2AF4:  MOVLW  0C
2AF6:  MOVWF  x93
2AF8:  CALL   0844
....................        lcd_gotoxy(1,1);             //escribir en a primera fila primera posicion  
2AFC:  MOVLW  01
2AFE:  MOVWF  x94
2B00:  MOVWF  x95
2B02:  CALL   07E8
....................        lcd_putc("MEN SERVOMOTOR");  //lo que se escribe 
2B06:  CLRF   x8C
2B08:  MOVF   x8C,W
2B0A:  CALL   05FA
2B0E:  IORLW  00
2B10:  BZ    2B1C
2B12:  INCF   x8C,F
2B14:  MOVWF  x93
2B16:  CALL   0844
2B1A:  BRA    2B08
....................        lcd_gotoxy(3,2);             //escribir en a primera fila primera posicion  
2B1C:  MOVLW  03
2B1E:  MOVWF  x94
2B20:  MOVLW  02
2B22:  MOVWF  x95
2B24:  CALL   07E8
....................        lcd_putc("EN CONSTRUCCION"); 
2B28:  CLRF   x8C
2B2A:  MOVF   x8C,W
2B2C:  CALL   05DA
2B30:  IORLW  00
2B32:  BZ    2B3E
2B34:  INCF   x8C,F
2B36:  MOVWF  x93
2B38:  CALL   0844
2B3C:  BRA    2B2A
....................        delay_ms(3000); 
2B3E:  MOVLW  0C
2B40:  MOVWF  x8C
2B42:  MOVLW  FA
2B44:  MOVWF  x94
2B46:  CALL   06DC
2B4A:  DECFSZ x8C,F
2B4C:  BRA    2B42
....................        goto David; 
2B4E:  BRA    24A6
....................      } 
....................      else if(datom==0x06) 
2B50:  BRA    2CC8
2B52:  MOVF   x72,W
2B54:  SUBLW  06
2B56:  BNZ   2BB6
....................      { 
....................        lcd_putc('\f');               //Limpiar pantalla comando 
2B58:  MOVLW  0C
2B5A:  MOVWF  x93
2B5C:  CALL   0844
....................        lcd_gotoxy(1,1);              //escribir en a primera fila primera posicion  
2B60:  MOVLW  01
2B62:  MOVWF  x94
2B64:  MOVWF  x95
2B66:  CALL   07E8
....................        lcd_putc("MENU CAD");         //lo que se escribe 
2B6A:  CLRF   x8C
2B6C:  MOVF   x8C,W
2B6E:  CALL   061A
2B72:  IORLW  00
2B74:  BZ    2B80
2B76:  INCF   x8C,F
2B78:  MOVWF  x93
2B7A:  CALL   0844
2B7E:  BRA    2B6C
....................        lcd_gotoxy(3,2);              //escribir en a primera fila primera posicion  
2B80:  MOVLW  03
2B82:  MOVWF  x94
2B84:  MOVLW  02
2B86:  MOVWF  x95
2B88:  CALL   07E8
....................        lcd_putc("EN CONSTRUCCION"); 
2B8C:  CLRF   x8C
2B8E:  MOVF   x8C,W
2B90:  CALL   05DA
2B94:  IORLW  00
2B96:  BZ    2BA2
2B98:  INCF   x8C,F
2B9A:  MOVWF  x93
2B9C:  CALL   0844
2BA0:  BRA    2B8E
....................        delay_ms(3000); 
2BA2:  MOVLW  0C
2BA4:  MOVWF  x8C
2BA6:  MOVLW  FA
2BA8:  MOVWF  x94
2BAA:  CALL   06DC
2BAE:  DECFSZ x8C,F
2BB0:  BRA    2BA6
....................        goto David; 
2BB2:  BRA    24A6
....................      } 
....................      else if(datom==0x07) 
2BB4:  BRA    2CC8
2BB6:  MOVF   x72,W
2BB8:  SUBLW  07
2BBA:  BNZ   2C1A
....................      { 
....................        lcd_putc('\f');               //Limpiar pantalla comando 
2BBC:  MOVLW  0C
2BBE:  MOVWF  x93
2BC0:  CALL   0844
....................        lcd_gotoxy(1,1);              //escribir en a primera fila primera posicion  
2BC4:  MOVLW  01
2BC6:  MOVWF  x94
2BC8:  MOVWF  x95
2BCA:  CALL   07E8
....................        lcd_putc("MEN DTMF");         //lo que se escribe 
2BCE:  CLRF   x8C
2BD0:  MOVF   x8C,W
2BD2:  CALL   0634
2BD6:  IORLW  00
2BD8:  BZ    2BE4
2BDA:  INCF   x8C,F
2BDC:  MOVWF  x93
2BDE:  CALL   0844
2BE2:  BRA    2BD0
....................        lcd_gotoxy(3,2);              //escribir en a primera fila primera posicion  
2BE4:  MOVLW  03
2BE6:  MOVWF  x94
2BE8:  MOVLW  02
2BEA:  MOVWF  x95
2BEC:  CALL   07E8
....................        lcd_putc("EN CONSTRUCCION"); 
2BF0:  CLRF   x8C
2BF2:  MOVF   x8C,W
2BF4:  CALL   05DA
2BF8:  IORLW  00
2BFA:  BZ    2C06
2BFC:  INCF   x8C,F
2BFE:  MOVWF  x93
2C00:  CALL   0844
2C04:  BRA    2BF2
....................        delay_ms(3000); 
2C06:  MOVLW  0C
2C08:  MOVWF  x8C
2C0A:  MOVLW  FA
2C0C:  MOVWF  x94
2C0E:  CALL   06DC
2C12:  DECFSZ x8C,F
2C14:  BRA    2C0A
....................        goto David; 
2C16:  BRA    24A6
....................      } 
....................      else if(datom==0x08) 
2C18:  BRA    2CC8
2C1A:  MOVF   x72,W
2C1C:  SUBLW  08
2C1E:  BNZ   2C7E
....................      { 
....................        lcd_putc('\f');              //Limpiar pantalla comando 
2C20:  MOVLW  0C
2C22:  MOVWF  x93
2C24:  CALL   0844
....................        lcd_gotoxy(1,1);             //escribir en a primera fila primera posicion  
2C28:  MOVLW  01
2C2A:  MOVWF  x94
2C2C:  MOVWF  x95
2C2E:  CALL   07E8
....................        lcd_putc("MEN SENSORES");    //lo que se escribe 
2C32:  CLRF   x8C
2C34:  MOVF   x8C,W
2C36:  CALL   064E
2C3A:  IORLW  00
2C3C:  BZ    2C48
2C3E:  INCF   x8C,F
2C40:  MOVWF  x93
2C42:  CALL   0844
2C46:  BRA    2C34
....................        lcd_gotoxy(3,2);             //escribir en a primera fila primera posicion  
2C48:  MOVLW  03
2C4A:  MOVWF  x94
2C4C:  MOVLW  02
2C4E:  MOVWF  x95
2C50:  CALL   07E8
....................        lcd_putc("EN CONSTRUCCION"); 
2C54:  CLRF   x8C
2C56:  MOVF   x8C,W
2C58:  CALL   05DA
2C5C:  IORLW  00
2C5E:  BZ    2C6A
2C60:  INCF   x8C,F
2C62:  MOVWF  x93
2C64:  CALL   0844
2C68:  BRA    2C56
....................        delay_ms(3000); 
2C6A:  MOVLW  0C
2C6C:  MOVWF  x8C
2C6E:  MOVLW  FA
2C70:  MOVWF  x94
2C72:  CALL   06DC
2C76:  DECFSZ x8C,F
2C78:  BRA    2C6E
....................        goto David; 
2C7A:  BRA    24A6
....................      } 
....................      else if(datom==0x09) 
2C7C:  BRA    2CC8
2C7E:  MOVF   x72,W
2C80:  SUBLW  09
2C82:  BNZ   2C8A
....................      { 
....................       goto admin; 
2C84:  GOTO   1A7A
....................      } 
....................      else{ 
2C88:  BRA    2CC8
....................           lcd_putc('\f');                 //Limpiar pantalla comando 
2C8A:  MOVLW  0C
2C8C:  MOVWF  x93
2C8E:  CALL   0844
....................           lcd_gotoxy(1,2);                //escribir en a primera fila primera posicion  
2C92:  MOVLW  01
2C94:  MOVWF  x94
2C96:  MOVLW  02
2C98:  MOVWF  x95
2C9A:  CALL   07E8
....................           lcd_putc("ERROR DE NUMERO");   //lo que se escribe 
2C9E:  CLRF   x8C
2CA0:  MOVF   x8C,W
2CA2:  CALL   0272
2CA6:  IORLW  00
2CA8:  BZ    2CB4
2CAA:  INCF   x8C,F
2CAC:  MOVWF  x93
2CAE:  CALL   0844
2CB2:  BRA    2CA0
....................           delay_ms(3000); 
2CB4:  MOVLW  0C
2CB6:  MOVWF  x8C
2CB8:  MOVLW  FA
2CBA:  MOVWF  x94
2CBC:  CALL   06DC
2CC0:  DECFSZ x8C,F
2CC2:  BRA    2CB8
....................           goto menu; 
2CC4:  GOTO   18E4
....................       } 
....................      }else{ 
2CC8:  BRA    2D08
....................      lcd_putc('\f');                 //Limpiar pantalla comando 
2CCA:  MOVLW  0C
2CCC:  MOVWF  x93
2CCE:  CALL   0844
....................      lcd_gotoxy(1,2);                //escribir en a primera fila primera posicion  
2CD2:  MOVLW  01
2CD4:  MOVWF  x94
2CD6:  MOVLW  02
2CD8:  MOVWF  x95
2CDA:  CALL   07E8
....................      lcd_putc("CONTRA. ERRONEA");   //lo que se escribe 
2CDE:  CLRF   x8C
2CE0:  MOVF   x8C,W
2CE2:  CALL   06BC
2CE6:  IORLW  00
2CE8:  BZ    2CF4
2CEA:  INCF   x8C,F
2CEC:  MOVWF  x93
2CEE:  CALL   0844
2CF2:  BRA    2CE0
....................      delay_ms(3000); 
2CF4:  MOVLW  0C
2CF6:  MOVWF  x8C
2CF8:  MOVLW  FA
2CFA:  MOVWF  x94
2CFC:  CALL   06DC
2D00:  DECFSZ x8C,F
2D02:  BRA    2CF8
....................      goto menu; 
2D04:  GOTO   18E4
....................      } 
....................    } 
2D08:  SLEEP 

Configuration Fuses:
   Word  1: 0C00   NOIESO NOFCMEN HS PLL1 CPUDIV1 NOUSBDIV
   Word  2: 1E18   NOBROWNOUT NOWDT BORV20 PUT WDT32768 NOVREGEN
   Word  3: 0300   PBADEN CCP2C1 NOMCLR NOLPT1OSC
   Word  4: 0081   STVREN NODEBUG NOLVP NOXINST NOICPRT
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: E00F   NOWRT NOWRTD NOWRTC NOWRTB
   Word  7: 400F   NOEBTR NOEBTRB

ROM data:
F00000: 23 45 34 56 
