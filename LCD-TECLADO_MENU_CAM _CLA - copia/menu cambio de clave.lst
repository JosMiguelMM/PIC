CCS PCH C Compiler, Version 4.093, 51109               14-sept.-21 19:28

               Filename: C:\Proyecto arquitectura c\LCD-TECLADO_MENU_CAM _CLA - copia\menu cambio de clave.lst

               ROM used: 6794 bytes (21%)
                         Largest free fragment is 25974
               RAM used: 41 (2%) at main() level
                         53 (3%) worst case
               Stack:    5 locations

*
0000:  GOTO   0BDE
.................... #include <18F4550.h> 
.................... //////// Standard Header file for the PIC18F4550 device //////////////// 
.................... #device PIC18F4550 
.................... #list 
....................  
.................... #fuses     HS,NOPROTECT,NOBROWNOUT,NOWDT,PUT,NOCPD,NODEBUG,NOLVP,NOMCLR  
.................... #use       delay(clock=20000000) 
*
051A:  CLRF   FEA
051C:  MOVLW  2B
051E:  MOVWF  FE9
0520:  MOVF   FEF,W
0522:  BZ    053E
0524:  MOVLW  06
0526:  MOVWF  01
0528:  CLRF   00
052A:  DECFSZ 00,F
052C:  BRA    052A
052E:  DECFSZ 01,F
0530:  BRA    0528
0532:  MOVLW  7B
0534:  MOVWF  00
0536:  DECFSZ 00,F
0538:  BRA    0536
053A:  DECFSZ FEF,F
053C:  BRA    0524
053E:  RETLW  00
.................... #include   <stdlib.h>           //LIBRERIAS MATEMATICAS IGUAL LA DE ABAJO 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = TRUE, sign = FALSE, point = FALSE; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = FALSE; 
....................          if (c == '+') 
....................          { 
....................             sign = FALSE; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = TRUE; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = TRUE; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = TRUE, sign = FALSE, point = FALSE; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = FALSE; 
....................          if (c == '+') 
....................          { 
....................             sign = FALSE; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = TRUE; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = TRUE; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = TRUE, sign = FALSE, point = FALSE; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = FALSE; 
....................          if (c == '+') 
....................          { 
....................             sign = FALSE; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = TRUE; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = TRUE; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    BYTE t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=TRUE; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = FALSE; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include   <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float32)l); 
....................   res = 32768.0*(float32)l; 
....................   res += (float32)(unsigned int16)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float48)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float48)l); 
....................   res = 32768.0*(float32)l; 
....................   res += (float48)(unsigned int16)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float48)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float64)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float64)l); 
....................   res = 32768.0*(float64)l; 
....................   res += (float64)(unsigned int16)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float64)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y/LN2 - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y/LN2 - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y/LN2 - (float64)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {0.45145214, -9.0558803, 26.940971, -19.860189}; 
.................... float32 const ql[4] = {1.0000000,  -8.1354259, 16.780517, -9.9300943}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................    bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................       res = res*y2 + pl[2]; 
....................       res = res*y2 + pl[3]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + ql[2]; 
....................       r = r*y2 + ql[3]; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................     
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................    
....................       if(bit_test(data2,7)) 
....................          bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................       res = res*y2 + pl[2]; 
....................       res = res*y2 + pl[3]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + ql[2]; 
....................       r = r*y2 + ql[3]; 
....................  
....................       res = y*res/r; 
....................  
....................     data1 = *(((unsigned int8 *)(&x)+5)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+4)); 
....................     if(bit_test (data2,7)) 
....................        bit_set(data1,0); 
....................       
....................     n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................          r = -(float48)-n; 
....................       else 
....................          r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float32 const pl_64[4] = {0.45145214, -9.0558803, 26.940971, -19.860189}; 
.................... float32 const ql_64[4] = {1.0000000,  -8.1354259, 16.780517, -9.9300943}; 
.................... #endif 
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................       bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................     bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................    bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................      bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #define TWOBYPI          0.6366197723675813 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[4] = { 
....................       -0.499999993585, 
....................        0.041666636258, 
....................       -0.0013888361399, 
....................        0.00002476016134 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 3; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[4] = { 
....................       -0.499999993585, 
....................        0.041666636258, 
....................       -0.0013888361399, 
....................        0.00002476016134 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 3; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float48 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p[4] = { 
....................       -0.499999993585, 
....................        0.041666636258, 
....................       -0.0013888361399, 
....................        0.00002476016134 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 3; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #define   LCD_E    PIN_E2 
.................... #define   LCD_CK   PIN_E1 
.................... #define   LCD_DAT  PIN_E0 
.................... #include <LCD4x20_3PIN.c> 
.................... // flex_lcd_3_pins.c 
....................  
.................... //Modificacin de Flex_lcd por Duende_Azul y Akenafab 
.................... //Trabaja con 3 pines y 74VHC164 
.................... //8-Bit Serial-In, Parallel-Out Shift Register 
....................  
.................... //La LCD se usa en modo 4bits 
.................... //Revisar diagrama de conexion Adjunto 
....................  
.................... //No esta habilitada la lectura del LCD 
.................... //RW debe ir a gnd 
....................  
.................... //Definir pines antes de llamar libreria// 
.................... //#define LCD_E     PIN_A0 
.................... //#define LCD_CK    PIN_A1    
.................... //#define LCD_DAT   PIN_A2 
....................  
.................... //======================================== 
.................... int RS_bit; 
.................... #define lcd_type 2        // 0=5x7, 1=5x10, 2=2 lines 
.................... #define lcd_line_two 0x40 // LCD RAM address for the 2nd line 
....................  
....................  
.................... int8 const LCD_INIT_STRING[4] = 
.................... { 
....................  0x20 | (lcd_type << 2), // Func set: 4-bit, 2 lines, 5x8 dots 
....................  0xc,                    // Display on 
....................  1,                      // Clear display 
....................  6                       // Increment cursor 
....................  }; 
.................... BYTE lcdline; 
....................  
.................... //------------------------------------- 
.................... void lcd_send_nibble(int8 nibble, int rs_bit) 
.................... { 
....................  
.................... int x; 
.................... if(RS_bit==1) 
0540:  DECFSZ 33,W
0542:  BRA    0546
....................    nibble=nibble|0x10; 
0544:  BSF    32.4
....................  
.................... for(x=0;x<5;x++){ 
0546:  CLRF   34
0548:  MOVF   34,W
054A:  SUBLW  04
054C:  BNC   0570
....................          output_bit(LCD_DAT,shift_right(&nibble,1,0)); 
054E:  BCF    FD8.0
0550:  RRCF   32,F
0552:  BC    0558
0554:  BCF    F8D.0
0556:  BRA    055A
0558:  BSF    F8D.0
055A:  BCF    F96.0
....................          delay_cycles(1); 
055C:  NOP   
....................          output_low(LCD_CK); 
055E:  BCF    F96.1
0560:  BCF    F8D.1
....................          delay_us(1); 
0562:  BRA    0564
0564:  BRA    0566
0566:  NOP   
....................          output_high(LCD_CK);} 
0568:  BCF    F96.1
056A:  BSF    F8D.1
056C:  INCF   34,F
056E:  BRA    0548
....................  
....................  
....................  
....................  output_high(LCD_E); 
0570:  BCF    F96.2
0572:  BSF    F8D.2
....................  delay_us(2); 
0574:  MOVLW  03
0576:  MOVWF  00
0578:  DECFSZ 00,F
057A:  BRA    0578
....................  output_low(LCD_E); 
057C:  BCF    F96.2
057E:  BCF    F8D.2
.................... } 
0580:  RETLW  00
....................  
.................... //----------------------------------- 
.................... //---------------------------------------- 
.................... // Send a byte to the LCD. 
.................... void lcd_send_byte(int8 address, int8 n) 
.................... { 
.................... //output_low(LCD_RS); 
.................... RS_bit=0; 
0582:  CLRF   0B
.................... delay_us(100); 
0584:  MOVLW  A6
0586:  MOVWF  00
0588:  DECFSZ 00,F
058A:  BRA    0588
058C:  NOP   
....................  
....................  
.................... if(address) 
058E:  MOVF   2F,F
0590:  BZ    0598
....................    //output_high(LCD_RS); 
....................    RS_bit=1; 
0592:  MOVLW  01
0594:  MOVWF  0B
.................... else 
0596:  BRA    059A
....................    //output_low(LCD_RS); 
....................    RS_bit=0; 
0598:  CLRF   0B
....................  
....................  delay_cycles(1); 
059A:  NOP   
....................  
....................  
.................... output_low(LCD_E); 
059C:  BCF    F96.2
059E:  BCF    F8D.2
....................  
.................... lcd_send_nibble(n >> 4,RS_bit); 
05A0:  SWAPF  30,W
05A2:  MOVWF  31
05A4:  MOVLW  0F
05A6:  ANDWF  31,F
05A8:  MOVFF  31,32
05AC:  MOVFF  0B,33
05B0:  RCALL  0540
.................... lcd_send_nibble(n & 0xf,RS_bit); 
05B2:  MOVF   30,W
05B4:  ANDLW  0F
05B6:  MOVWF  31
05B8:  MOVWF  32
05BA:  MOVFF  0B,33
05BE:  RCALL  0540
.................... } 
05C0:  RETLW  00
....................  
.................... //---------------------------- 
.................... void lcd_init(void) 
.................... { 
.................... int8 i; 
....................  
.................... //output_low(LCD_RS); 
.................... RS_bit=0; 
05C2:  CLRF   0B
....................  
.................... output_low(LCD_E); 
05C4:  BCF    F96.2
05C6:  BCF    F8D.2
....................  
.................... delay_ms(20); 
05C8:  MOVLW  14
05CA:  MOVWF  2B
05CC:  RCALL  051A
....................  
.................... for(i=0 ;i < 3; i++) 
05CE:  CLRF   28
05D0:  MOVF   28,W
05D2:  SUBLW  02
05D4:  BNC   05EA
....................    { 
....................     lcd_send_nibble(0x03,RS_bit); 
05D6:  MOVLW  03
05D8:  MOVWF  32
05DA:  MOVFF  0B,33
05DE:  RCALL  0540
....................     delay_ms(5); 
05E0:  MOVLW  05
05E2:  MOVWF  2B
05E4:  RCALL  051A
....................    } 
05E6:  INCF   28,F
05E8:  BRA    05D0
....................  
.................... lcd_send_nibble(0x02,RS_bit); 
05EA:  MOVLW  02
05EC:  MOVWF  32
05EE:  MOVFF  0B,33
05F2:  RCALL  0540
....................  
.................... for(i=0; i < sizeof(LCD_INIT_STRING); i++) 
05F4:  CLRF   28
05F6:  MOVF   28,W
05F8:  SUBLW  03
05FA:  BNC   061E
....................    { 
....................     lcd_send_byte(0, LCD_INIT_STRING[i]); 
05FC:  CLRF   03
05FE:  MOVF   28,W
0600:  MOVFF  FF2,29
0604:  BCF    FF2.7
0606:  RCALL  0004
0608:  BTFSC  29.7
060A:  BSF    FF2.7
060C:  MOVWF  29
060E:  CLRF   2F
0610:  MOVWF  30
0612:  RCALL  0582
....................  
....................     delay_ms(5); 
0614:  MOVLW  05
0616:  MOVWF  2B
0618:  RCALL  051A
....................      
....................    } 
061A:  INCF   28,F
061C:  BRA    05F6
....................  
.................... } 
061E:  GOTO   0C24 (RETURN)
....................  
.................... //---------------------------- 
....................  
.................... void lcd_gotoxy(int8 x, int8 y) 
.................... { 
.................... int8 address; 
....................  
....................    switch(y) { 
*
0626:  MOVLW  01
0628:  SUBWF  2C,W
062A:  ADDLW  FC
062C:  BC    064C
062E:  ADDLW  04
0630:  GOTO   0660
....................      case 1 : address=0x80;break; 
0634:  MOVLW  80
0636:  MOVWF  2D
0638:  BRA    064C
....................      case 2 : address=0xc0;break; 
063A:  MOVLW  C0
063C:  MOVWF  2D
063E:  BRA    064C
....................      case 3 : address=0x94;break; 
0640:  MOVLW  94
0642:  MOVWF  2D
0644:  BRA    064C
....................      case 4 : address=0xd4;break; 
0646:  MOVLW  D4
0648:  MOVWF  2D
064A:  BRA    064C
....................    } 
.................... address += x-1; 
064C:  MOVLW  01
064E:  SUBWF  2B,W
0650:  ADDWF  2D,F
.................... lcd_send_byte(0, 0x80 | address); 
0652:  MOVF   2D,W
0654:  IORLW  80
0656:  MOVWF  2E
0658:  CLRF   2F
065A:  MOVWF  30
065C:  RCALL  0582
.................... } 
065E:  RETLW  00
....................  
.................... //----------------------------- 
.................... void lcd_putc(char c) 
.................... { 
....................  switch(c) 
....................    { 
*
0682:  MOVF   2A,W
0684:  XORLW  0C
0686:  BZ    069E
0688:  XORLW  06
068A:  BZ    06B2
068C:  XORLW  02
068E:  BZ    06C0
0690:  XORLW  6B
0692:  BZ    06CA
0694:  XORLW  04
0696:  BZ    06D4
0698:  XORLW  0F
069A:  BZ    06DE
069C:  BRA    06E8
....................     case '\f':                //limpia pantalla 
....................       lcd_send_byte(0,1); 
069E:  CLRF   2F
06A0:  MOVLW  01
06A2:  MOVWF  30
06A4:  RCALL  0582
....................       lcdline=1; 
06A6:  MOVLW  01
06A8:  MOVWF  0C
....................       delay_ms(8); 
06AA:  MOVLW  08
06AC:  MOVWF  2B
06AE:  RCALL  051A
....................       break; 
06B0:  BRA    06F4
....................  
....................     case '\n':                //cambio de linea 
....................        lcd_gotoxy(1,++lcdline); 
06B2:  INCF   0C,F
06B4:  MOVLW  01
06B6:  MOVWF  2B
06B8:  MOVFF  0C,2C
06BC:  RCALL  0626
....................        break; 
06BE:  BRA    06F4
....................  
....................     case '\b':                //retrocede 1 caracter 
....................        lcd_send_byte(0,0x10); 
06C0:  CLRF   2F
06C2:  MOVLW  10
06C4:  MOVWF  30
06C6:  RCALL  0582
....................        break; 
06C8:  BRA    06F4
....................         
....................     case '\c':                //on display 
....................     lcd_send_byte(0,0x0c); 
06CA:  CLRF   2F
06CC:  MOVLW  0C
06CE:  MOVWF  30
06D0:  RCALL  0582
....................     break; 
06D2:  BRA    06F4
....................     
....................     case '\g':                 
....................     lcd_send_byte(0,0x0f);    // prende cursor y parpadea 
06D4:  CLRF   2F
06D6:  MOVLW  0F
06D8:  MOVWF  30
06DA:  RCALL  0582
....................     break;   
06DC:  BRA    06F4
....................  
....................     case '\h':                //retrocede 1 caracter 
....................     lcd_send_byte(0,0x0f);    // prende cursor y parpadea 
06DE:  CLRF   2F
06E0:  MOVLW  0F
06E2:  MOVWF  30
06E4:  RCALL  0582
....................     break; 
06E6:  BRA    06F4
....................      
....................     default: 
....................        lcd_send_byte(1,c); 
06E8:  MOVLW  01
06EA:  MOVWF  2F
06EC:  MOVFF  2A,30
06F0:  RCALL  0582
....................        break; 
06F2:  BRA    06F4
....................    } 
.................... } 
06F4:  RETLW  00
....................  
.................... //------------------------------ 
....................  
.................... void lcd_cursor_vb(short visible, short blink) {  
....................   lcd_send_byte(0, 0xC|(visible<<1)|blink);  
.................... }  
....................  
....................  
.................... #include <KBD18F.c> 
.................... //////////////////////////////////////////////////////////////////////////////////// 
.................... //                                   KBD.C                                        // 
.................... //               FUNCIONES PARA ESCANEO DE UN TECLADO MATRICIAL                   // 
.................... //                         4X4 HEXADECIMAL, EN EL PORTB                           // 
.................... //       kbd_init()       Debe ser invocada antes que las otras funciones.         // 
.................... //       c=lcd_getc(c)    Si h sido presionada una tecla devuelve el caracter c    // 
.................... //                  y lo salva en el char c, sino se presiona una tecla       // 
.................... //                  retorna el valor /0, esta funcin puede invocarse         // 
.................... //                  frecuentemente para no perder teclas pulsadas.            // 
.................... //        NOTA: REQUIERE COLOCAR RESISTENCIAS (2.2K) EN LOS PINES DE COLUMNAS     // 
.................... //               PINES DE COLUMNAS DE RB0(COL0) A RB3(COL3))                   // 
.................... //               PINES DE FILAS DE RB4(ROW0)) A RB7(ROW3))                    //  
.................... //                  MODIF.: ING. FRANK GIRALDO - UD                       // 
.................... //////////////////////////////////////////////////////////////////////////////////// 
.................... /*//////////////////////////////////////////////////////////////////////////////////  
.................... *    RB0 RB1 RB2 RB3    
.................... *     |   |   |   | 
.................... *     c0  c1  c2  c3   
.................... *   | 1 | 2 | 3 | F | r0 - RB4 
.................... *   | 4 | 5 | 6 | E | r1 - RB5 
.................... *   | 7 | 8 | 9 | D | r2 - RB6 
.................... *   | A | 0 | B | C | r3 - RB7 
.................... * 
.................... *   COLUMNS=OUTs 
.................... *   ROWS=INs 
.................... *   SE HABILITAN PULL-UP INTERNAS  
.................... *   SE REQUIERE COLOCAR RESISTENCIAS (2.2K) EN LOS PINES DE COLUMNAS  
.................... * 
.................... */////////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... #byte portkbd = 0XF81                  //portkbd = portB 
.................... //Keypad connection:   (Column 0 es B0) 
.................... //                Bx: 
.................... #define COL0 (0 << 0) 
.................... #define COL1 (0 << 1) 
.................... #define COL2 (0 << 2) 
.................... #define COL3 (0 << 3) 
.................... #define ROW0 (1 << 4) 
.................... #define ROW1 (1 << 5) 
.................... #define ROW2 (1 << 6) 
.................... #define ROW3 (1 << 7) 
.................... #define ALL_ROWS (ROW3|ROW2|ROW1|ROW0) 
.................... #define ALL_PINS (ALL_ROWS|COL3|COL2|COL1|COL0) 
....................  
.................... char const KEYS[4][4] = {{'1','2','3','A'}, 
....................                          {'4','5','6','B'}, 
....................                          {'7','8','9','C'}, 
....................                          {'*','0','#','D'}}; 
....................  
.................... #define KBD_DEBOUNCE_FACTOR 0.2 
.................... // Modifique el valor de temporizacin antirrebote con (KBD_DEBOUNCE_FACTOR = n/333), 
.................... // en donde n es el nmero de veces por segundo en los que ud. invoca 
.................... //la funcin kbd_getc(). 
.................... // 
....................  
.................... void kbd_init(){ 
.................... } 
*
0622:  GOTO   0C26 (RETURN)
....................  
.................... char kbd_getc( ) 
.................... { 
....................    static BYTE kbd_call_count; 
....................    static short int kbd_down; 
....................    static char last_key; 
....................    static BYTE col; 
....................    BYTE kchar; 
....................    BYTE row; 
....................    port_b_pullups(TRUE); 
*
07E2:  BCF    FF1.7
....................    kchar='\0'; 
07E4:  CLRF   28
....................  
....................    if(++kbd_call_count>KBD_DEBOUNCE_FACTOR) 
07E6:  INCF   0D,F
07E8:  CLRF   2B
07EA:  MOVFF  0D,2A
07EE:  BRA    0732
07F0:  MOVLW  CD
07F2:  MOVWF  2D
07F4:  MOVLW  CC
07F6:  MOVWF  2C
07F8:  MOVLW  4C
07FA:  MOVWF  2B
07FC:  MOVLW  7C
07FE:  MOVWF  2A
0800:  MOVFF  03,31
0804:  MOVFF  02,30
0808:  MOVFF  01,2F
080C:  MOVFF  00,2E
0810:  BRA    076A
0812:  BNC   08CA
....................    { 
....................        switch (col) 
....................        { 
0814:  MOVF   10,W
0816:  ADDLW  FC
0818:  BC    0848
081A:  ADDLW  04
081C:  GOTO   08D8
....................          case 0   : set_tris_b(ALL_PINS&~COL0); 
0820:  MOVLW  F0
0822:  MOVWF  F93
....................                     portkbd=(0b1110); 
0824:  MOVLW  0E
0826:  MOVWF  F81
....................                     break; 
0828:  BRA    0848
....................  
....................          case 1   : set_tris_b(ALL_PINS&~COL1); 
082A:  MOVLW  F0
082C:  MOVWF  F93
....................                     portkbd=(0b1101); 
082E:  MOVLW  0D
0830:  MOVWF  F81
....................                     break; 
0832:  BRA    0848
....................  
....................          case 2   : set_tris_b(ALL_PINS&~COL2); 
0834:  MOVLW  F0
0836:  MOVWF  F93
....................                     portkbd=(0b1011); 
0838:  MOVLW  0B
083A:  MOVWF  F81
....................                     break; 
083C:  BRA    0848
....................  
....................          case 3   : set_tris_b(ALL_PINS&~COL3); 
083E:  MOVLW  F0
0840:  MOVWF  F93
....................                     portkbd=(0b0111); 
0842:  MOVLW  07
0844:  MOVWF  F81
....................                     break; 
0846:  BRA    0848
....................        } 
....................  
....................        if(kbd_down) 
0848:  BTFSS  0E.0
084A:  BRA    085E
....................        { 
....................          if((portkbd & (ALL_ROWS))==(ALL_ROWS)) 
084C:  MOVF   F81,W
084E:  ANDLW  F0
0850:  SUBLW  F0
0852:  BNZ   085C
....................          { 
....................            kbd_down=FALSE; 
0854:  BCF    0E.0
....................            kchar=last_key; 
0856:  MOVFF  0F,28
....................            last_key='\0'; 
085A:  CLRF   0F
....................          } 
....................        } 
....................        else 
085C:  BRA    08C8
....................        { 
....................           if((portkbd & (ALL_ROWS))!=(ALL_ROWS)) 
085E:  MOVF   F81,W
0860:  ANDLW  F0
0862:  SUBLW  F0
0864:  BZ    08BE
....................           { 
....................              if((portkbd & ROW0) == 0) 
0866:  MOVF   F81,W
0868:  ANDLW  10
086A:  BNZ   0870
....................                row = 0; 
086C:  CLRF   29
....................              else if((portkbd & ROW1) == 0) 
086E:  BRA    0892
0870:  MOVF   F81,W
0872:  ANDLW  20
0874:  BNZ   087C
....................                row = 1; 
0876:  MOVLW  01
0878:  MOVWF  29
....................              else if((portkbd & ROW2) == 0) 
087A:  BRA    0892
087C:  MOVF   F81,W
087E:  ANDLW  40
0880:  BNZ   0888
....................                row = 2; 
0882:  MOVLW  02
0884:  MOVWF  29
....................              else if((portkbd & ROW3) == 0) 
0886:  BRA    0892
0888:  MOVF   F81,W
088A:  ANDLW  80
088C:  BNZ   0892
....................                row = 3; 
088E:  MOVLW  03
0890:  MOVWF  29
....................              last_key = KEYS[row][col]; 
0892:  MOVF   29,W
0894:  MULLW  04
0896:  MOVF   FF3,W
0898:  CLRF   2B
089A:  MOVWF  2A
089C:  CLRF   03
089E:  MOVF   10,W
08A0:  ADDWF  2A,W
08A2:  MOVWF  01
08A4:  MOVF   2B,W
08A6:  ADDWFC 03,F
08A8:  MOVF   01,W
08AA:  MOVFF  FF2,2A
08AE:  BCF    FF2.7
08B0:  CALL   0018
08B4:  BTFSC  2A.7
08B6:  BSF    FF2.7
08B8:  MOVWF  0F
....................              kbd_down = TRUE; 
08BA:  BSF    0E.0
....................           } 
....................           else 
08BC:  BRA    08C8
....................           { 
....................              ++col; 
08BE:  INCF   10,F
....................              if(col==4) 
08C0:  MOVF   10,W
08C2:  SUBLW  04
08C4:  BNZ   08C8
....................              col=0; 
08C6:  CLRF   10
....................           } 
....................        } 
....................       kbd_call_count=0; 
08C8:  CLRF   0D
....................    } 
....................   kchar = last_key; 
08CA:  MOVFF  0F,28
....................   set_tris_b(ALL_PINS); 
08CE:  MOVLW  F0
08D0:  MOVWF  F93
....................   return(kchar); 
08D2:  MOVFF  28,01
.................... } 
08D6:  RETLW  00
....................  
.................... /*char dato; 
.................... char tecla() 
.................... { 
....................    dato='\0'; 
....................    while(dato=='\0') 
....................    { 
....................       dato=kbd_getc(); 
....................       delay_ms(100); 
....................    } 
.................... return dato; 
.................... } */ 
....................  
.................... //#include <DS1307.c> 
.................... #ROM     0xf00000={0x4416}     //colocar 0 para usuario 1, estan al reves primero esta los dos digitos ultimos y luego los otros 
.................... #ROM     0xf00002={0x1644}     //esto es asignacion de claves para los usuarios 
.................... #define SW PIN A5 
.................... //Vamos a nombrar los registros de proposito GRAL 
.................... int i, b, dato, clave[4], datoi[4], adres,  dato1, dato2; 
.................... char datom; 
.................... float valor; 
.................... short flag; 
.................... long segundos, auxsegundos; 
.................... //long contador; 
....................  
.................... /************************** 
.................... SECCION DE METODOS 
.................... ************************/ 
....................  
.................... void teclado() 
.................... {  
....................     lcd_putc('\f'); 
*
08FA:  MOVLW  0C
08FC:  MOVWF  2A
08FE:  RCALL  0682
....................     segundos=0; 
0900:  CLRF   25
0902:  CLRF   24
....................     auxsegundos=0; 
0904:  CLRF   27
0906:  CLRF   26
....................     b=6; 
0908:  MOVLW  06
090A:  MOVWF  12
....................      for(i=0;i<4; i++) 
090C:  CLRF   11
090E:  MOVF   11,W
0910:  SUBLW  03
0912:  BTFSS  FD8.0
0914:  BRA    0B04
....................       { 
....................         do{ 
....................             datom=kbd_getc(); // escanea teclado 
0916:  RCALL  07E2
0918:  MOVFF  01,1F
....................             delay_ms(60); 
091C:  MOVLW  3C
091E:  MOVWF  2B
0920:  RCALL  051A
....................              if(datom!='\0')  //si hay dato valido 
0922:  MOVF   1F,F
0924:  BTFSC  FD8.2
0926:  BRA    0AA8
....................               { 
....................                  switch (i+1) 
....................                   { 
0928:  MOVLW  01
092A:  ADDWF  11,W
092C:  ADDLW  FF
092E:  ADDLW  FC
0930:  BTFSC  FD8.0
0932:  BRA    0A90
0934:  ADDLW  04
0936:  GOTO   0B06
....................                    case 1: 
....................                    lcd_gotoxy(6,1); 
093A:  MOVLW  06
093C:  MOVWF  2B
093E:  MOVLW  01
0940:  MOVWF  2C
0942:  RCALL  0626
....................                    printf(lcd_putc,datom); 
0944:  CLRF   FEA
0946:  MOVFF  1F,FE9
094A:  MOVLW  00
094C:  IORWF  FEF,W
094E:  BZ    096E
0950:  MOVFF  FEA,29
0954:  MOVFF  FE9,28
0958:  MOVFF  FEF,2A
095C:  RCALL  0682
095E:  MOVFF  29,FEA
0962:  MOVFF  28,FE9
0966:  INCF   FE9,F
0968:  BTFSC  FD8.2
096A:  INCF   FEA,F
096C:  BRA    094A
....................                    clave[0]=datom-0X30; 
096E:  MOVLW  30
0970:  SUBWF  1F,W
0972:  MOVWF  14
....................                    swap(clave[0]); 
0974:  SWAPF  14,F
....................                    lcd_gotoxy(6,2); 
0976:  MOVLW  06
0978:  MOVWF  2B
097A:  MOVLW  02
097C:  MOVWF  2C
097E:  RCALL  0626
....................                    printf(lcd_putc,"*"); 
0980:  MOVLW  2A
0982:  MOVWF  2A
0984:  RCALL  0682
....................                    delay_ms(50); 
0986:  MOVLW  32
0988:  MOVWF  2B
098A:  RCALL  051A
....................                    break; 
098C:  BRA    0A90
....................            
....................                    case 2: 
....................                    lcd_gotoxy(7,1); 
098E:  MOVLW  07
0990:  MOVWF  2B
0992:  MOVLW  01
0994:  MOVWF  2C
0996:  RCALL  0626
....................                    printf(lcd_putc,datom); 
0998:  CLRF   FEA
099A:  MOVFF  1F,FE9
099E:  MOVLW  00
09A0:  IORWF  FEF,W
09A2:  BZ    09C2
09A4:  MOVFF  FEA,29
09A8:  MOVFF  FE9,28
09AC:  MOVFF  FEF,2A
09B0:  RCALL  0682
09B2:  MOVFF  29,FEA
09B6:  MOVFF  28,FE9
09BA:  INCF   FE9,F
09BC:  BTFSC  FD8.2
09BE:  INCF   FEA,F
09C0:  BRA    099E
....................                    clave[1]=datom-0X30; 
09C2:  MOVLW  30
09C4:  SUBWF  1F,W
09C6:  MOVWF  15
....................                    clave[0]=clave[0]+clave[1]; 
09C8:  MOVF   15,W
09CA:  ADDWF  14,F
....................                    lcd_gotoxy(7,2); 
09CC:  MOVLW  07
09CE:  MOVWF  2B
09D0:  MOVLW  02
09D2:  MOVWF  2C
09D4:  RCALL  0626
....................                    printf(lcd_putc,"*"); 
09D6:  MOVLW  2A
09D8:  MOVWF  2A
09DA:  RCALL  0682
....................                    delay_ms(50); 
09DC:  MOVLW  32
09DE:  MOVWF  2B
09E0:  RCALL  051A
....................                    break; 
09E2:  BRA    0A90
....................               
....................                    case 3: 
....................                    lcd_gotoxy(8,1); 
09E4:  MOVLW  08
09E6:  MOVWF  2B
09E8:  MOVLW  01
09EA:  MOVWF  2C
09EC:  RCALL  0626
....................                    printf(lcd_putc,datom); 
09EE:  CLRF   FEA
09F0:  MOVFF  1F,FE9
09F4:  MOVLW  00
09F6:  IORWF  FEF,W
09F8:  BZ    0A18
09FA:  MOVFF  FEA,29
09FE:  MOVFF  FE9,28
0A02:  MOVFF  FEF,2A
0A06:  RCALL  0682
0A08:  MOVFF  29,FEA
0A0C:  MOVFF  28,FE9
0A10:  INCF   FE9,F
0A12:  BTFSC  FD8.2
0A14:  INCF   FEA,F
0A16:  BRA    09F4
....................                    clave[2]=datom-0X30; 
0A18:  MOVLW  30
0A1A:  SUBWF  1F,W
0A1C:  MOVWF  16
....................                    swap(clave[2]); 
0A1E:  SWAPF  16,F
....................                    lcd_gotoxy(8,2); 
0A20:  MOVLW  08
0A22:  MOVWF  2B
0A24:  MOVLW  02
0A26:  MOVWF  2C
0A28:  RCALL  0626
....................                    printf(lcd_putc,"*"); 
0A2A:  MOVLW  2A
0A2C:  MOVWF  2A
0A2E:  RCALL  0682
....................                    delay_ms(50); 
0A30:  MOVLW  32
0A32:  MOVWF  2B
0A34:  RCALL  051A
....................                    break; 
0A36:  BRA    0A90
....................               
....................                    case 4: 
....................                    lcd_gotoxy(9,1); 
0A38:  MOVLW  09
0A3A:  MOVWF  2B
0A3C:  MOVLW  01
0A3E:  MOVWF  2C
0A40:  RCALL  0626
....................                    printf(lcd_putc,datom); 
0A42:  CLRF   FEA
0A44:  MOVFF  1F,FE9
0A48:  MOVLW  00
0A4A:  IORWF  FEF,W
0A4C:  BZ    0A6C
0A4E:  MOVFF  FEA,29
0A52:  MOVFF  FE9,28
0A56:  MOVFF  FEF,2A
0A5A:  RCALL  0682
0A5C:  MOVFF  29,FEA
0A60:  MOVFF  28,FE9
0A64:  INCF   FE9,F
0A66:  BTFSC  FD8.2
0A68:  INCF   FEA,F
0A6A:  BRA    0A48
....................                    clave[3]=datom-0X30; 
0A6C:  MOVLW  30
0A6E:  SUBWF  1F,W
0A70:  MOVWF  17
....................                    clave[1]=clave[2]+clave[3]; 
0A72:  MOVF   17,W
0A74:  ADDWF  16,W
0A76:  MOVWF  15
....................                    lcd_gotoxy(9,2); 
0A78:  MOVLW  09
0A7A:  MOVWF  2B
0A7C:  MOVLW  02
0A7E:  MOVWF  2C
0A80:  RCALL  0626
....................                    printf(lcd_putc,"*"); 
0A82:  MOVLW  2A
0A84:  MOVWF  2A
0A86:  RCALL  0682
....................                    delay_ms(50); 
0A88:  MOVLW  32
0A8A:  MOVWF  2B
0A8C:  RCALL  051A
....................                    break; 
0A8E:  BRA    0A90
....................                  }  
....................                   i++; 
0A90:  INCF   11,F
....................                   delay_ms(500); 
0A92:  MOVLW  02
0A94:  MOVWF  28
0A96:  MOVLW  FA
0A98:  MOVWF  2B
0A9A:  RCALL  051A
0A9C:  DECFSZ 28,F
0A9E:  BRA    0A96
....................                   auxsegundos=0; 
0AA0:  CLRF   27
0AA2:  CLRF   26
....................                   segundos=0; 
0AA4:  CLRF   25
0AA6:  CLRF   24
....................            } 
....................            auxsegundos++; 
0AA8:  INCF   26,F
0AAA:  BTFSC  FD8.2
0AAC:  INCF   27,F
....................            if(auxsegundos > 20) 
0AAE:  MOVF   27,F
0AB0:  BNZ   0AB8
0AB2:  MOVF   26,W
0AB4:  SUBLW  14
0AB6:  BC    0AC2
....................             { 
....................               segundos++; 
0AB8:  INCF   24,F
0ABA:  BTFSC  FD8.2
0ABC:  INCF   25,F
....................               auxsegundos=0; 
0ABE:  CLRF   27
0AC0:  CLRF   26
....................             } 
....................          
....................       
....................     
....................     }while(i<4 && segundos<6); 
0AC2:  MOVF   11,W
0AC4:  SUBLW  03
0AC6:  BNC   0AD4
0AC8:  MOVF   25,F
0ACA:  BNZ   0AD4
0ACC:  MOVF   24,W
0ACE:  SUBLW  05
0AD0:  BTFSC  FD8.0
0AD2:  BRA    0916
....................       clave[i]='#'; 
0AD4:  CLRF   03
0AD6:  MOVF   11,W
0AD8:  ADDLW  14
0ADA:  MOVWF  FE9
0ADC:  MOVLW  00
0ADE:  ADDWFC 03,W
0AE0:  MOVWF  FEA
0AE2:  MOVLW  23
0AE4:  MOVWF  FEF
....................       lcd_gotoxy(b,1); 
0AE6:  MOVFF  12,2B
0AEA:  MOVLW  01
0AEC:  MOVWF  2C
0AEE:  RCALL  0626
....................       printf(lcd_putc,"*") ; 
0AF0:  MOVLW  2A
0AF2:  MOVWF  2A
0AF4:  RCALL  0682
....................       b++; 
0AF6:  INCF   12,F
....................       auxsegundos=0; 
0AF8:  CLRF   27
0AFA:  CLRF   26
....................       segundos=0; 
0AFC:  CLRF   25
0AFE:  CLRF   24
....................    } 
0B00:  INCF   11,F
0B02:  BRA    090E
.................... } 
0B04:  RETLW  00
....................  
....................  
.................... void un_digito() 
.................... { lcd_putc('\f'); 
*
0B28:  MOVLW  0C
0B2A:  MOVWF  2A
0B2C:  RCALL  0682
....................   segundos=0; 
0B2E:  CLRF   25
0B30:  CLRF   24
....................   auxsegundos=0; 
0B32:  CLRF   27
0B34:  CLRF   26
....................   flag=false; 
0B36:  BCF    0E.1
....................   do{ 
....................       datom=kbd_getc(); 
0B38:  RCALL  07E2
0B3A:  MOVFF  01,1F
....................       delay_ms(60); 
0B3E:  MOVLW  3C
0B40:  MOVWF  2B
0B42:  RCALL  051A
....................       if(datom !='\0') 
0B44:  MOVF   1F,F
0B46:  BZ    0B60
....................         { 
....................           lcd_gotoxy(8,1);  //coloque el numero digitado  en posicion del LCD 
0B48:  MOVLW  08
0B4A:  MOVWF  2B
0B4C:  MOVLW  01
0B4E:  MOVWF  2C
0B50:  RCALL  0626
....................           lcd_putc(datom); //visualice datom 
0B52:  MOVFF  1F,2A
0B56:  RCALL  0682
....................           datom=datom-0x30; //quitele ASCII 
0B58:  MOVLW  30
0B5A:  SUBWF  1F,F
....................           flag=true; 
0B5C:  BSF    0E.1
....................            
....................         }else { 
0B5E:  BRA    0B7A
....................                auxsegundos++; 
0B60:  INCF   26,F
0B62:  BTFSC  FD8.2
0B64:  INCF   27,F
....................                if(auxsegundos>20) 
0B66:  MOVF   27,F
0B68:  BNZ   0B70
0B6A:  MOVF   26,W
0B6C:  SUBLW  14
0B6E:  BC    0B7A
....................                { 
....................                  segundos++; 
0B70:  INCF   24,F
0B72:  BTFSC  FD8.2
0B74:  INCF   25,F
....................                  auxsegundos=0; 
0B76:  CLRF   27
0B78:  CLRF   26
....................                 } 
....................        } 
....................          
....................   }while(segundos<6 && flag==false ); 
0B7A:  MOVF   25,F
0B7C:  BNZ   0B88
0B7E:  MOVF   24,W
0B80:  SUBLW  05
0B82:  BNC   0B88
0B84:  BTFSS  0E.1
0B86:  BRA    0B38
.................... } 
0B88:  RETLW  00
....................  
.................... void escribir_memoria() 
.................... { 
....................   for(i=0; i<2; i++) 
0B8A:  CLRF   11
0B8C:  MOVF   11,W
0B8E:  SUBLW  01
0B90:  BNC   0BDC
....................   {  write_eeprom(adres, clave[i]); 
0B92:  CLRF   03
0B94:  MOVF   11,W
0B96:  ADDLW  14
0B98:  MOVWF  FE9
0B9A:  MOVLW  00
0B9C:  ADDWFC 03,W
0B9E:  MOVWF  FEA
0BA0:  MOVFF  FEF,28
0BA4:  MOVFF  1C,FA9
0BA8:  MOVFF  28,FA8
0BAC:  BCF    FA6.6
0BAE:  BCF    FA6.7
0BB0:  BSF    FA6.2
0BB2:  MOVFF  FF2,00
0BB6:  BCF    FF2.7
0BB8:  MOVLB  F
0BBA:  MOVLW  55
0BBC:  MOVWF  FA7
0BBE:  MOVLW  AA
0BC0:  MOVWF  FA7
0BC2:  BSF    FA6.1
0BC4:  BTFSC  FA6.1
0BC6:  BRA    0BC4
0BC8:  BCF    FA6.2
0BCA:  MOVF   00,W
0BCC:  IORWF  FF2,F
....................      delay_ms(5); 
0BCE:  MOVLW  05
0BD0:  MOVWF  2B
0BD2:  MOVLB  0
0BD4:  RCALL  051A
....................      adres++; 
0BD6:  INCF   1C,F
....................   } 
0BD8:  INCF   11,F
0BDA:  BRA    0B8C
.................... } 
0BDC:  RETLW  00
....................  
.................... void leer() 
.................... { 
....................   for(i=0; i<4; i++) 
*
06F6:  CLRF   11
06F8:  MOVF   11,W
06FA:  SUBLW  03
06FC:  BNC   072E
....................   { 
....................     datoi[i]=read_eeprom(i); 
06FE:  CLRF   03
0700:  MOVF   11,W
0702:  ADDLW  18
0704:  MOVWF  FE9
0706:  MOVLW  00
0708:  ADDWFC 03,W
070A:  MOVWF  FEA
070C:  MOVFF  FF2,2A
0710:  BCF    FF2.7
0712:  MOVFF  11,FA9
0716:  BCF    FA6.6
0718:  BCF    FA6.7
071A:  BSF    FA6.0
071C:  MOVF   FA8,W
071E:  BTFSC  2A.7
0720:  BSF    FF2.7
0722:  MOVWF  FEF
....................     delay_ms(1); 
0724:  MOVLW  01
0726:  MOVWF  2B
0728:  RCALL  051A
....................   } 
072A:  INCF   11,F
072C:  BRA    06F8
.................... } 
072E:  GOTO   0D50 (RETURN)
....................  
....................  
....................    
.................... /************************** 
.................... PROGRAMA PRINCIPAL 
.................... ************************/   
....................  
.................... void main() 
.................... {#zero_ram 
*
0BDE:  CLRF   FF8
0BE0:  BCF    FD0.7
0BE2:  MOVLW  FE
0BE4:  MOVWF  00
0BE6:  MOVLW  08
0BE8:  MOVWF  01
0BEA:  MOVLW  02
0BEC:  MOVWF  FE9
0BEE:  MOVLW  00
0BF0:  MOVWF  FEA
0BF2:  CLRF   FEE
0BF4:  DECFSZ 00,F
0BF6:  BRA    0BF2
0BF8:  DECFSZ 01,F
0BFA:  BRA    0BF2
0BFC:  CLRF   FEA
0BFE:  CLRF   FE9
0C00:  MOVF   FC1,W
0C02:  ANDLW  C0
0C04:  IORLW  0F
0C06:  MOVWF  FC1
0C08:  MOVLW  07
0C0A:  MOVWF  FB4
0C0C:  CLRF   05
0C0E:  CLRF   06
0C10:  CLRF   0D
0C12:  BCF    0E.0
0C14:  CLRF   0F
0C16:  CLRF   10
.................... inicio:                       //etiquetas siempre a la izquierda 
....................     set_tris_A(0x28);         /*0010 1000 EL 28 SALE ES DIVIDIENDO LOS 8BITS EN 4 DIGITOS Y TOMAR A QUE NUMERO CORRESPONCEN 
0C18:  MOVLW  28
0C1A:  MOVWF  F92
....................     RA0 PIN 2  FREE 
....................     RA1 PIN 3  FREE 
....................     RA2 PIN 4  FREE 
....................     RA3 PIN 5  FREE 
....................     RA4 PIN 6  FREE 
....................     RA5 PIN 7  FREE 
....................     RA6 PIN 14 FREE 
....................     RA7 NO EXISTE */ 
....................      
....................     set_tris_B(0x00); /*0000 0000 EL 28 SALE ES DIVIDIENDO LOS 8BITS EN 4 DIGITOS Y TOMAR A QUE NUMERO CORRESPONCEN 
0C1C:  MOVLW  00
0C1E:  MOVWF  F93
....................     RB0 PIN 33  LED1 
....................     RB1 PIN 34  LED2 
....................     RB2 PIN 35  LED4 
....................     RB3 PIN 36  LED5 
....................     RB4 PIN 37  LED6 
....................     RB5 PIN 38  LED7 
....................     RB6 PIN 39  LED8 
....................     RB7 PIN 40  LED8 */ 
....................      
....................     set_tris_D(0x00); /*0000 0000 EL 28 SALE ES DIVIDIENDO LOS 8BITS EN 4 DIGITOS Y TOMAR A QUE NUMERO CORRESPONCEN 
0C20:  MOVWF  F95
....................     RB0 PIN 33  LED1 
....................     RB1 PIN 34  LED2 
....................     RB2 PIN 35  LED4 
....................     RB3 PIN 36  LED5 
....................     RB4 PIN 37  LED6 
....................     RB5 PIN 38  LED7 
....................     RB6 PIN 39  LED8 
....................     RB7 PIN 40  LED8 */ 
....................      
....................     lcd_init(); 
0C22:  BRA    05C2
....................     kbd_init(); 
0C24:  BRA    0622
....................     output_A(0x00);                            //Limpiar el puerto A 
0C26:  CLRF   F92
0C28:  CLRF   F89
....................     output_B(0x00);                           //Limipiar el puerto B 
0C2A:  CLRF   F93
0C2C:  CLRF   F8A
....................     output_D(0x00);                           //Limipiar el puerto D 
0C2E:  CLRF   F95
0C30:  CLRF   F8C
....................     
.................... menu: 
....................    lcd_putc('\f');                            //Limpiar pantalla comando 
0C32:  MOVLW  0C
0C34:  MOVWF  2A
0C36:  RCALL  0682
....................    lcd_gotoxy(1,1);                           //escribir en a primera fila primera posicion  
0C38:  MOVLW  01
0C3A:  MOVWF  2B
0C3C:  MOVWF  2C
0C3E:  RCALL  0626
....................    lcd_putc("BIENVENIDOS");              //lo que se escribe 
0C40:  CLRF   28
0C42:  MOVF   28,W
0C44:  CALL   0038
0C48:  IORLW  00
0C4A:  BZ    0C54
0C4C:  INCF   28,F
0C4E:  MOVWF  2A
0C50:  RCALL  0682
0C52:  BRA    0C42
....................    lcd_gotoxy(1,2);                           //escribir en a primera fila primera posicion  
0C54:  MOVLW  01
0C56:  MOVWF  2B
0C58:  MOVLW  02
0C5A:  MOVWF  2C
0C5C:  RCALL  0626
....................    lcd_putc("ARQ. COMP. NOCHE"); 
0C5E:  CLRF   28
0C60:  MOVF   28,W
0C62:  CALL   0054
0C66:  IORLW  00
0C68:  BZ    0C72
0C6A:  INCF   28,F
0C6C:  MOVWF  2A
0C6E:  RCALL  0682
0C70:  BRA    0C60
....................    delay_ms(3000); 
0C72:  MOVLW  0C
0C74:  MOVWF  28
0C76:  MOVLW  FA
0C78:  MOVWF  2B
0C7A:  RCALL  051A
0C7C:  DECFSZ 28,F
0C7E:  BRA    0C76
....................     
....................    lcd_putc('\f');                            //Limpiar pantalla comando 
0C80:  MOVLW  0C
0C82:  MOVWF  2A
0C84:  RCALL  0682
....................    lcd_gotoxy(1,1);                           //escribir en a primera fila primera posicion  
0C86:  MOVLW  01
0C88:  MOVWF  2B
0C8A:  MOVWF  2C
0C8C:  RCALL  0626
....................    lcd_putc("JAMPIER MORENO");                 //lo que se escribe 
0C8E:  CLRF   28
0C90:  MOVF   28,W
0C92:  CALL   0076
0C96:  IORLW  00
0C98:  BZ    0CA2
0C9A:  INCF   28,F
0C9C:  MOVWF  2A
0C9E:  RCALL  0682
0CA0:  BRA    0C90
....................    lcd_gotoxy(1,2);                           //escribir en a primera fila primera posicion  
0CA2:  MOVLW  01
0CA4:  MOVWF  2B
0CA6:  MOVLW  02
0CA8:  MOVWF  2C
0CAA:  RCALL  0626
....................    lcd_putc("BRAYAN FORIGUA"); 
0CAC:  CLRF   28
0CAE:  MOVF   28,W
0CB0:  CALL   0096
0CB4:  IORLW  00
0CB6:  BZ    0CC0
0CB8:  INCF   28,F
0CBA:  MOVWF  2A
0CBC:  RCALL  0682
0CBE:  BRA    0CAE
....................    //printf(lcd_putc,"\f   MIGUEL MENDEZ\n DAVID MARTINEZ ");// /n pase a sigueinet linea 
....................    delay_ms(3000); 
0CC0:  MOVLW  0C
0CC2:  MOVWF  28
0CC4:  MOVLW  FA
0CC6:  MOVWF  2B
0CC8:  RCALL  051A
0CCA:  DECFSZ 28,F
0CCC:  BRA    0CC4
....................     
....................    lcd_putc('\f');                           //Limpiar pantalla comando 
0CCE:  MOVLW  0C
0CD0:  MOVWF  2A
0CD2:  RCALL  0682
....................    lcd_gotoxy(3,1);                          //escribir en a primera fila primera posicion  
0CD4:  MOVLW  03
0CD6:  MOVWF  2B
0CD8:  MOVLW  01
0CDA:  MOVWF  2C
0CDC:  RCALL  0626
....................    lcd_putc("GRUPO");                        //lo que se escribe 
0CDE:  CLRF   28
0CE0:  MOVF   28,W
0CE2:  CALL   00B6
0CE6:  IORLW  00
0CE8:  BZ    0CF2
0CEA:  INCF   28,F
0CEC:  MOVWF  2A
0CEE:  RCALL  0682
0CF0:  BRA    0CE0
....................    lcd_gotoxy(2,2);                          //escribir en a primera fila primera posicion  
0CF2:  MOVLW  02
0CF4:  MOVWF  2B
0CF6:  MOVWF  2C
0CF8:  RCALL  0626
....................    lcd_putc("9"); 
0CFA:  CLRF   28
0CFC:  MOVF   28,W
0CFE:  CALL   00CC
0D02:  IORLW  00
0D04:  BZ    0D0E
0D06:  INCF   28,F
0D08:  MOVWF  2A
0D0A:  RCALL  0682
0D0C:  BRA    0CFC
....................    //printf(lcd_putc,"\f        GRUPO   \n       NUMERO    ");// /n pase a sigueinet linea 
....................    delay_ms(3000); 
0D0E:  MOVLW  0C
0D10:  MOVWF  28
0D12:  MOVLW  FA
0D14:  MOVWF  2B
0D16:  RCALL  051A
0D18:  DECFSZ 28,F
0D1A:  BRA    0D12
....................     
....................    lcd_putc('\f');                          //Limpiar pantalla comando 
0D1C:  MOVLW  0C
0D1E:  MOVWF  2A
0D20:  RCALL  0682
....................    lcd_gotoxy(1,1);                         //escribir en a primera fila primera posicion  
0D22:  MOVLW  01
0D24:  MOVWF  2B
0D26:  MOVWF  2C
0D28:  RCALL  0626
....................    lcd_putc("DIGITE SU CLAVE");                   //lo que se escribe 
0D2A:  CLRF   28
0D2C:  MOVF   28,W
0D2E:  CALL   00DE
0D32:  IORLW  00
0D34:  BZ    0D3E
0D36:  INCF   28,F
0D38:  MOVWF  2A
0D3A:  RCALL  0682
0D3C:  BRA    0D2C
....................     
....................    //printf(lcd_putc,"\f    POR FAVOR   \n INGRESE CLAVE");// /n pase a sigueinet linea 
....................    delay_ms(3000); 
0D3E:  MOVLW  0C
0D40:  MOVWF  28
0D42:  MOVLW  FA
0D44:  MOVWF  2B
0D46:  CALL   051A
0D4A:  DECFSZ 28,F
0D4C:  BRA    0D42
....................     
....................     
....................     
....................    leer();                                  //datoi[0]= clave que le demos datoi[1]=clave que le demos 
0D4E:  BRA    06F6
....................    teclado();                               //clave [0]=0x34, clave[1]=0x78 
0D50:  RCALL  08FA
....................    if(clave[0]==0x12 & clave[1]==0x34) 
0D52:  MOVF   14,W
0D54:  SUBLW  12
0D56:  BZ    0D5C
0D58:  MOVLW  00
0D5A:  BRA    0D5E
0D5C:  MOVLW  01
0D5E:  MOVWF  28
0D60:  MOVF   15,W
0D62:  SUBLW  34
0D64:  BZ    0D6A
0D66:  MOVLW  00
0D68:  BRA    0D6C
0D6A:  MOVLW  01
0D6C:  ANDWF  28,W
0D6E:  BTFSC  FD8.2
0D70:  BRA    0F14
....................    { 
.................... admin:  
....................       lcd_putc('\f');                          //Limpiar pantalla comando 
0D72:  MOVLW  0C
0D74:  MOVWF  2A
0D76:  RCALL  0682
....................       lcd_gotoxy(1,1);                         //escribir en a primera fila primera posicion  
0D78:  MOVLW  01
0D7A:  MOVWF  2B
0D7C:  MOVWF  2C
0D7E:  RCALL  0626
....................       lcd_putc("Bienvenidos al");              //lo que se escribe 
0D80:  CLRF   28
0D82:  MOVF   28,W
0D84:  CALL   00FE
0D88:  IORLW  00
0D8A:  BZ    0D94
0D8C:  INCF   28,F
0D8E:  MOVWF  2A
0D90:  RCALL  0682
0D92:  BRA    0D82
....................       lcd_gotoxy(4,2);                         //escribir en a primera fila primera posicion  
0D94:  MOVLW  04
0D96:  MOVWF  2B
0D98:  MOVLW  02
0D9A:  MOVWF  2C
0D9C:  RCALL  0626
....................       lcd_putc("MenuDelDiseniador"); 
0D9E:  CLRF   28
0DA0:  MOVF   28,W
0DA2:  CALL   011E
0DA6:  IORLW  00
0DA8:  BZ    0DB2
0DAA:  INCF   28,F
0DAC:  MOVWF  2A
0DAE:  RCALL  0682
0DB0:  BRA    0DA0
....................       //printf(lcd_putc,"\f    POR FAVOR   \n INGRESE CLAVE");// /n pase a sigueinet linea 
....................       delay_ms(3000); 
0DB2:  MOVLW  0C
0DB4:  MOVWF  28
0DB6:  MOVLW  FA
0DB8:  MOVWF  2B
0DBA:  CALL   051A
0DBE:  DECFSZ 28,F
0DC0:  BRA    0DB6
....................       
....................       lcd_putc('\f');                         //Limpiar pantalla comando 
0DC2:  MOVLW  0C
0DC4:  MOVWF  2A
0DC6:  RCALL  0682
....................       lcd_gotoxy(1,1);                        //escribir en a primera fila primera posicion  
0DC8:  MOVLW  01
0DCA:  MOVWF  2B
0DCC:  MOVWF  2C
0DCE:  RCALL  0626
....................       lcd_putc("DIGITE 1 PARA");           //lo que se escribe 
0DD0:  CLRF   28
0DD2:  MOVF   28,W
0DD4:  CALL   0140
0DD8:  IORLW  00
0DDA:  BZ    0DE4
0DDC:  INCF   28,F
0DDE:  MOVWF  2A
0DE0:  RCALL  0682
0DE2:  BRA    0DD2
....................       lcd_gotoxy(1,2);                        //escribir en a primera fila primera posicion  
0DE4:  MOVLW  01
0DE6:  MOVWF  2B
0DE8:  MOVLW  02
0DEA:  MOVWF  2C
0DEC:  RCALL  0626
....................       lcd_putc("MENU DE JAMPIER"); 
0DEE:  CLRF   28
0DF0:  MOVF   28,W
0DF2:  CALL   015E
0DF6:  IORLW  00
0DF8:  BZ    0E02
0DFA:  INCF   28,F
0DFC:  MOVWF  2A
0DFE:  RCALL  0682
0E00:  BRA    0DF0
....................       //printf(lcd_putc,"\f    POR FAVOR   \n INGRESE CLAVE");// /n pase a sigueinet linea 
....................       delay_ms(3000); 
0E02:  MOVLW  0C
0E04:  MOVWF  28
0E06:  MOVLW  FA
0E08:  MOVWF  2B
0E0A:  CALL   051A
0E0E:  DECFSZ 28,F
0E10:  BRA    0E06
....................     
....................       lcd_putc('\f');                         //Limpiar pantalla comando 
0E12:  MOVLW  0C
0E14:  MOVWF  2A
0E16:  RCALL  0682
....................       lcd_gotoxy(1,1);                        //escribir en a primera fila primera posicion  
0E18:  MOVLW  01
0E1A:  MOVWF  2B
0E1C:  MOVWF  2C
0E1E:  RCALL  0626
....................       lcd_putc("DIGITE 2 PARA");           //lo que se escribe 
0E20:  CLRF   28
0E22:  MOVF   28,W
0E24:  CALL   017E
0E28:  IORLW  00
0E2A:  BZ    0E34
0E2C:  INCF   28,F
0E2E:  MOVWF  2A
0E30:  RCALL  0682
0E32:  BRA    0E22
....................       lcd_gotoxy(1,2);                        //escribir en a primera fila primera posicion  
0E34:  MOVLW  01
0E36:  MOVWF  2B
0E38:  MOVLW  02
0E3A:  MOVWF  2C
0E3C:  CALL   0626
....................       lcd_putc("MENU DE BRAYAN"); 
0E40:  CLRF   28
0E42:  MOVF   28,W
0E44:  CALL   019C
0E48:  IORLW  00
0E4A:  BZ    0E54
0E4C:  INCF   28,F
0E4E:  MOVWF  2A
0E50:  RCALL  0682
0E52:  BRA    0E42
....................       //printf(lcd_putc,"\f    POR FAVOR   \n INGRESE CLAVE");// /n pase a sigueinet linea 
....................       delay_ms(3000); 
0E54:  MOVLW  0C
0E56:  MOVWF  28
0E58:  MOVLW  FA
0E5A:  MOVWF  2B
0E5C:  CALL   051A
0E60:  DECFSZ 28,F
0E62:  BRA    0E58
....................      
....................       lcd_putc('\f');                         //Limpiar pantalla comando 
0E64:  MOVLW  0C
0E66:  MOVWF  2A
0E68:  RCALL  0682
....................       lcd_gotoxy(1,1);                        //escribir en a primera fila primera posicion  
0E6A:  MOVLW  01
0E6C:  MOVWF  2B
0E6E:  MOVWF  2C
0E70:  CALL   0626
....................       lcd_putc("DIGITE UN ");             //lo que se escribe 
0E74:  CLRF   28
0E76:  MOVF   28,W
0E78:  CALL   01BC
0E7C:  IORLW  00
0E7E:  BZ    0E8A
0E80:  INCF   28,F
0E82:  MOVWF  2A
0E84:  CALL   0682
0E88:  BRA    0E76
....................       lcd_gotoxy(1,2);                        //escribir en a primera fila primera posicion  
0E8A:  MOVLW  01
0E8C:  MOVWF  2B
0E8E:  MOVLW  02
0E90:  MOVWF  2C
0E92:  CALL   0626
....................       lcd_putc("NUMERO DEL 1 AL 3"); 
0E96:  CLRF   28
0E98:  MOVF   28,W
0E9A:  CALL   01D8
0E9E:  IORLW  00
0EA0:  BZ    0EAC
0EA2:  INCF   28,F
0EA4:  MOVWF  2A
0EA6:  CALL   0682
0EAA:  BRA    0E98
....................       //printf(lcd_putc,"\f    POR FAVOR   \n INGRESE CLAVE");// /n pase a sigueinet linea 
....................       delay_ms(3000); 
0EAC:  MOVLW  0C
0EAE:  MOVWF  28
0EB0:  MOVLW  FA
0EB2:  MOVWF  2B
0EB4:  CALL   051A
0EB8:  DECFSZ 28,F
0EBA:  BRA    0EB0
....................     
....................     
....................        //bienvenidos al menu del diseador 
....................        //marque 1 para menu de MIGUEL 
....................        //marque 2 para menu de David 
....................        //marque 3 salir  */ 
....................         
....................         
....................      un_digito(); 
0EBC:  RCALL  0B28
....................     if(datom==0x01) 
0EBE:  DECFSZ 1F,W
0EC0:  BRA    0EC4
....................      { 
....................         goto David; 
0EC2:  BRA    14CA
....................      } 
....................      if(datom==0x02) 
0EC4:  MOVF   1F,W
0EC6:  SUBLW  02
0EC8:  BNZ   0ECC
....................      { 
....................         goto Miguel; 
0ECA:  BRA    0F34
....................      } 
....................      if(datom==0x03) 
0ECC:  MOVF   1F,W
0ECE:  SUBLW  03
0ED0:  BNZ   0ED4
....................      { 
....................         reset_cpu();  //salir 
0ED2:  RESET
....................      } 
....................      lcd_putc('\f');                        //Limpiar pantalla comando 
0ED4:  MOVLW  0C
0ED6:  MOVWF  2A
0ED8:  CALL   0682
....................      lcd_gotoxy(1,2);                       //escribir en a primera fila primera posicion  
0EDC:  MOVLW  01
0EDE:  MOVWF  2B
0EE0:  MOVLW  02
0EE2:  MOVWF  2C
0EE4:  CALL   0626
....................      lcd_putc("ERROR DE NUMERO");           //lo que se escribe 
0EE8:  CLRF   28
0EEA:  MOVF   28,W
0EEC:  CALL   01FA
0EF0:  IORLW  00
0EF2:  BZ    0EFE
0EF4:  INCF   28,F
0EF6:  MOVWF  2A
0EF8:  CALL   0682
0EFC:  BRA    0EEA
....................      delay_ms(3000); 
0EFE:  MOVLW  0C
0F00:  MOVWF  28
0F02:  MOVLW  FA
0F04:  MOVWF  2B
0F06:  CALL   051A
0F0A:  DECFSZ 28,F
0F0C:  BRA    0F02
....................      goto admin; 
0F0E:  BRA    0D72
....................      }  
....................      else if(clave[0]==datoi[1] & clave[1]==datoi[0]) 
0F10:  GOTO   1A88
0F14:  MOVF   19,W
0F16:  SUBWF  14,W
0F18:  BZ    0F1E
0F1A:  MOVLW  00
0F1C:  BRA    0F20
0F1E:  MOVLW  01
0F20:  MOVWF  28
0F22:  MOVF   18,W
0F24:  SUBWF  15,W
0F26:  BZ    0F2C
0F28:  MOVLW  00
0F2A:  BRA    0F2E
0F2C:  MOVLW  01
0F2E:  ANDWF  28,W
0F30:  BTFSC  FD8.2
0F32:  BRA    14AA
....................       { 
.................... Miguel:adres=0x00; 
0F34:  CLRF   1C
....................        /*escribirle al lcd 
....................        bienvenidos al menu del diseador 
....................        marque 1 para cambiar clave 
....................        marque 2 para fecha y hora 
....................        marque 3 para reportes 
....................        marque 4 para motor paso a paso 
....................        marque 5 para servomotor 
....................        marque 6 para cad 
....................        marque 7 para DTMF 
....................        marque 8 para sensores 
....................        marque 9 para salir*/ 
....................       
....................     lcd_putc('\f');                       //Limpiar pantalla comando 
0F36:  MOVLW  0C
0F38:  MOVWF  2A
0F3A:  CALL   0682
....................     lcd_gotoxy(1,1);                      //escribir en a primera fila primera posicion  
0F3E:  MOVLW  01
0F40:  MOVWF  2B
0F42:  MOVWF  2C
0F44:  CALL   0626
....................     lcd_putc("BIENVENIDO AL");              //lo que se escribe 
0F48:  CLRF   28
0F4A:  MOVF   28,W
0F4C:  CALL   021A
0F50:  IORLW  00
0F52:  BZ    0F5E
0F54:  INCF   28,F
0F56:  MOVWF  2A
0F58:  CALL   0682
0F5C:  BRA    0F4A
....................     lcd_gotoxy(1,2);                      //escribir en a primera fila primera posicion  
0F5E:  MOVLW  01
0F60:  MOVWF  2B
0F62:  MOVLW  02
0F64:  MOVWF  2C
0F66:  CALL   0626
....................     lcd_putc("MENU DE JAMPIER"); 
0F6A:  CLRF   28
0F6C:  MOVF   28,W
0F6E:  CALL   015E
0F72:  IORLW  00
0F74:  BZ    0F80
0F76:  INCF   28,F
0F78:  MOVWF  2A
0F7A:  CALL   0682
0F7E:  BRA    0F6C
....................     delay_ms(3000);  
0F80:  MOVLW  0C
0F82:  MOVWF  28
0F84:  MOVLW  FA
0F86:  MOVWF  2B
0F88:  CALL   051A
0F8C:  DECFSZ 28,F
0F8E:  BRA    0F84
....................         
....................     lcd_putc('\f');                       //Limpiar pantalla comando 
0F90:  MOVLW  0C
0F92:  MOVWF  2A
0F94:  CALL   0682
....................     lcd_gotoxy(1,1);                      //escribir en a primera fila primera posicion  
0F98:  MOVLW  01
0F9A:  MOVWF  2B
0F9C:  MOVWF  2C
0F9E:  CALL   0626
....................     lcd_putc("DIGITE 1");          //lo que se escribe 
0FA2:  CLRF   28
0FA4:  MOVF   28,W
0FA6:  CALL   0238
0FAA:  IORLW  00
0FAC:  BZ    0FB8
0FAE:  INCF   28,F
0FB0:  MOVWF  2A
0FB2:  CALL   0682
0FB6:  BRA    0FA4
....................     lcd_gotoxy(1,2);                      //escribir en a primera fila primera posicion  
0FB8:  MOVLW  01
0FBA:  MOVWF  2B
0FBC:  MOVLW  02
0FBE:  MOVWF  2C
0FC0:  CALL   0626
....................     lcd_putc("CAMBIAR clave"); 
0FC4:  CLRF   28
0FC6:  MOVF   28,W
0FC8:  CALL   0252
0FCC:  IORLW  00
0FCE:  BZ    0FDA
0FD0:  INCF   28,F
0FD2:  MOVWF  2A
0FD4:  CALL   0682
0FD8:  BRA    0FC6
....................     delay_ms(3000);   
0FDA:  MOVLW  0C
0FDC:  MOVWF  28
0FDE:  MOVLW  FA
0FE0:  MOVWF  2B
0FE2:  CALL   051A
0FE6:  DECFSZ 28,F
0FE8:  BRA    0FDE
....................      
....................     lcd_putc('\f');                      //Limpiar pantalla comando 
0FEA:  MOVLW  0C
0FEC:  MOVWF  2A
0FEE:  CALL   0682
....................     lcd_gotoxy(1,1);                     //escribir en a primera fila primera posicion  
0FF2:  MOVLW  01
0FF4:  MOVWF  2B
0FF6:  MOVWF  2C
0FF8:  CALL   0626
....................     lcd_putc("DIGITE 9 PARA salir");          //lo que se escribe 
0FFC:  CLRF   28
0FFE:  MOVF   28,W
1000:  CALL   0270
1004:  IORLW  00
1006:  BZ    1012
1008:  INCF   28,F
100A:  MOVWF  2A
100C:  CALL   0682
1010:  BRA    0FFE
....................      
....................     delay_ms(3000); 
1012:  MOVLW  0C
1014:  MOVWF  28
1016:  MOVLW  FA
1018:  MOVWF  2B
101A:  CALL   051A
101E:  DECFSZ 28,F
1020:  BRA    1016
....................     
....................      
....................     un_digito(); 
1022:  RCALL  0B28
....................     if(datom==0x01) 
1024:  DECFSZ 1F,W
1026:  BRA    11A2
....................      { 
....................        lcd_putc('\f');                   //Limpiar pantalla comando 
1028:  MOVLW  0C
102A:  MOVWF  2A
102C:  CALL   0682
....................        lcd_gotoxy(1,1);                  //escribir en a primera fila primera posicion  
1030:  MOVLW  01
1032:  MOVWF  2B
1034:  MOVWF  2C
1036:  CALL   0626
....................        lcd_putc("POR FAVOR DIGITE");     //lo que se escribe 
103A:  CLRF   28
103C:  MOVF   28,W
103E:  CALL   0294
1042:  IORLW  00
1044:  BZ    1050
1046:  INCF   28,F
1048:  MOVWF  2A
104A:  CALL   0682
104E:  BRA    103C
....................        lcd_gotoxy(1,2);                  //escribir en a primera fila primera posicion  
1050:  MOVLW  01
1052:  MOVWF  2B
1054:  MOVLW  02
1056:  MOVWF  2C
1058:  CALL   0626
....................        lcd_putc("NUEVA CLAVE");    
105C:  CLRF   28
105E:  MOVF   28,W
1060:  CALL   02B6
1064:  IORLW  00
1066:  BZ    1072
1068:  INCF   28,F
106A:  MOVWF  2A
106C:  CALL   0682
1070:  BRA    105E
....................        delay_ms(3000); 
1072:  MOVLW  0C
1074:  MOVWF  28
1076:  MOVLW  FA
1078:  MOVWF  2B
107A:  CALL   051A
107E:  DECFSZ 28,F
1080:  BRA    1076
....................        teclado(); 
1082:  RCALL  08FA
....................         
....................        dato1=clave[0]; 
1084:  MOVFF  14,1D
....................        dato2=clave[1]; 
1088:  MOVFF  15,1E
....................         
....................        lcd_putc('\f');                   //Limpiar pantalla comando 
108C:  MOVLW  0C
108E:  MOVWF  2A
1090:  CALL   0682
....................        lcd_gotoxy(1,1);                  //escribir en a primera fila primera posicion  
1094:  MOVLW  01
1096:  MOVWF  2B
1098:  MOVWF  2C
109A:  CALL   0626
....................        lcd_putc("POR FAVOR DIGITE");     //lo que se escribe 
109E:  CLRF   28
10A0:  MOVF   28,W
10A2:  CALL   0294
10A6:  IORLW  00
10A8:  BZ    10B4
10AA:  INCF   28,F
10AC:  MOVWF  2A
10AE:  CALL   0682
10B2:  BRA    10A0
....................        lcd_gotoxy(1,2);                  //escribir en a primera fila primera posicion  
10B4:  MOVLW  01
10B6:  MOVWF  2B
10B8:  MOVLW  02
10BA:  MOVWF  2C
10BC:  CALL   0626
....................        lcd_putc("NUEVA CLAVE");    
10C0:  CLRF   28
10C2:  MOVF   28,W
10C4:  CALL   02B6
10C8:  IORLW  00
10CA:  BZ    10D6
10CC:  INCF   28,F
10CE:  MOVWF  2A
10D0:  CALL   0682
10D4:  BRA    10C2
....................        delay_ms(3000); 
10D6:  MOVLW  0C
10D8:  MOVWF  28
10DA:  MOVLW  FA
10DC:  MOVWF  2B
10DE:  CALL   051A
10E2:  DECFSZ 28,F
10E4:  BRA    10DA
....................         
....................        teclado(); 
10E6:  RCALL  08FA
....................         
....................        if(clave[0]==dato1 & clave[1]==dato2) 
10E8:  MOVF   1D,W
10EA:  SUBWF  14,W
10EC:  BZ    10F2
10EE:  MOVLW  00
10F0:  BRA    10F4
10F2:  MOVLW  01
10F4:  MOVWF  28
10F6:  MOVF   1E,W
10F8:  SUBWF  15,W
10FA:  BZ    1100
10FC:  MOVLW  00
10FE:  BRA    1102
1100:  MOVLW  01
1102:  ANDWF  28,W
1104:  BZ    1166
....................        { 
....................         escribir_memoria(); 
1106:  RCALL  0B8A
....................         lcd_putc('\f');                   //Limpiar pantalla comando 
1108:  MOVLW  0C
110A:  MOVWF  2A
110C:  CALL   0682
....................         lcd_gotoxy(1,1);                  //escribir en a primera fila primera posicion  
1110:  MOVLW  01
1112:  MOVWF  2B
1114:  MOVWF  2C
1116:  CALL   0626
....................         lcd_putc("CLAVE MODIFICADA");     //lo que se escribe 
111A:  CLRF   28
111C:  MOVF   28,W
111E:  CALL   02D2
1122:  IORLW  00
1124:  BZ    1130
1126:  INCF   28,F
1128:  MOVWF  2A
112A:  CALL   0682
112E:  BRA    111C
....................         lcd_gotoxy(3,2);                  //escribir en a primera fila primera posicion  
1130:  MOVLW  03
1132:  MOVWF  2B
1134:  MOVLW  02
1136:  MOVWF  2C
1138:  CALL   0626
....................         lcd_putc("CON EXITO");    
113C:  CLRF   28
113E:  MOVF   28,W
1140:  CALL   02F4
1144:  IORLW  00
1146:  BZ    1152
1148:  INCF   28,F
114A:  MOVWF  2A
114C:  CALL   0682
1150:  BRA    113E
....................         delay_ms(3000); 
1152:  MOVLW  0C
1154:  MOVWF  28
1156:  MOVLW  FA
1158:  MOVWF  2B
115A:  CALL   051A
115E:  DECFSZ 28,F
1160:  BRA    1156
....................         goto Miguel; 
1162:  BRA    0F34
....................        } 
....................        else{ 
1164:  BRA    11A0
....................        lcd_putc('\f');                   //Limpiar pantalla comando 
1166:  MOVLW  0C
1168:  MOVWF  2A
116A:  CALL   0682
....................        lcd_gotoxy(1,1);                  //escribir en a primera fila primera posicion  
116E:  MOVLW  01
1170:  MOVWF  2B
1172:  MOVWF  2C
1174:  CALL   0626
....................        lcd_putc("ERROR DE CLAVE");     //lo que se escribe 
1178:  CLRF   28
117A:  MOVF   28,W
117C:  CALL   030E
1180:  IORLW  00
1182:  BZ    118E
1184:  INCF   28,F
1186:  MOVWF  2A
1188:  CALL   0682
118C:  BRA    117A
....................        delay_ms(3000); 
118E:  MOVLW  0C
1190:  MOVWF  28
1192:  MOVLW  FA
1194:  MOVWF  2B
1196:  CALL   051A
119A:  DECFSZ 28,F
119C:  BRA    1192
....................        goto Miguel; 
119E:  BRA    0F34
....................        } 
....................        
....................        
....................      } 
....................      else if(datom==0x02) 
11A0:  BRA    14A8
11A2:  MOVF   1F,W
11A4:  SUBLW  02
11A6:  BNZ   1206
....................      { 
....................        lcd_putc('\f');                  //Limpiar pantalla comando 
11A8:  MOVLW  0C
11AA:  MOVWF  2A
11AC:  CALL   0682
....................        lcd_gotoxy(1,1);                 //escribir en a primera fila primera posicion  
11B0:  MOVLW  01
11B2:  MOVWF  2B
11B4:  MOVWF  2C
11B6:  CALL   0626
....................        lcd_putc("MEN FECHA Y HORA");    //lo que se escribe 
11BA:  CLRF   28
11BC:  MOVF   28,W
11BE:  CALL   032E
11C2:  IORLW  00
11C4:  BZ    11D0
11C6:  INCF   28,F
11C8:  MOVWF  2A
11CA:  CALL   0682
11CE:  BRA    11BC
....................        lcd_gotoxy(3,2);                 //escribir en a primera fila primera posicion  
11D0:  MOVLW  03
11D2:  MOVWF  2B
11D4:  MOVLW  02
11D6:  MOVWF  2C
11D8:  CALL   0626
....................        lcd_putc("EN CONSTRUCCION"); 
11DC:  CLRF   28
11DE:  MOVF   28,W
11E0:  CALL   0350
11E4:  IORLW  00
11E6:  BZ    11F2
11E8:  INCF   28,F
11EA:  MOVWF  2A
11EC:  CALL   0682
11F0:  BRA    11DE
....................        delay_ms(3000); 
11F2:  MOVLW  0C
11F4:  MOVWF  28
11F6:  MOVLW  FA
11F8:  MOVWF  2B
11FA:  CALL   051A
11FE:  DECFSZ 28,F
1200:  BRA    11F6
....................        goto Miguel; 
1202:  BRA    0F34
....................      } 
....................     else if(datom==0x03) 
1204:  BRA    14A8
1206:  MOVF   1F,W
1208:  SUBLW  03
120A:  BNZ   126A
....................      { 
....................        lcd_putc('\f');                //Limpiar pantalla comando 
120C:  MOVLW  0C
120E:  MOVWF  2A
1210:  CALL   0682
....................        lcd_gotoxy(1,1);               //escribir en a primera fila primera posicion  
1214:  MOVLW  01
1216:  MOVWF  2B
1218:  MOVWF  2C
121A:  CALL   0626
....................        lcd_putc("MENU REPORTES");     //lo que se escribe 
121E:  CLRF   28
1220:  MOVF   28,W
1222:  CALL   0370
1226:  IORLW  00
1228:  BZ    1234
122A:  INCF   28,F
122C:  MOVWF  2A
122E:  CALL   0682
1232:  BRA    1220
....................        lcd_gotoxy(3,2);               //escribir en a primera fila primera posicion  
1234:  MOVLW  03
1236:  MOVWF  2B
1238:  MOVLW  02
123A:  MOVWF  2C
123C:  CALL   0626
....................        lcd_putc("EN CONSTRUCCION"); 
1240:  CLRF   28
1242:  MOVF   28,W
1244:  CALL   0350
1248:  IORLW  00
124A:  BZ    1256
124C:  INCF   28,F
124E:  MOVWF  2A
1250:  CALL   0682
1254:  BRA    1242
....................        delay_ms(3000); 
1256:  MOVLW  0C
1258:  MOVWF  28
125A:  MOVLW  FA
125C:  MOVWF  2B
125E:  CALL   051A
1262:  DECFSZ 28,F
1264:  BRA    125A
....................        goto Miguel; 
1266:  BRA    0F34
....................      } 
....................     else if(datom==0x04) 
1268:  BRA    14A8
126A:  MOVF   1F,W
126C:  SUBLW  04
126E:  BNZ   12CE
....................      { 
....................        lcd_putc('\f');               //Limpiar pantalla comando 
1270:  MOVLW  0C
1272:  MOVWF  2A
1274:  CALL   0682
....................        lcd_gotoxy(1,1);              //escribir en a primera fila primera posicion  
1278:  MOVLW  01
127A:  MOVWF  2B
127C:  MOVWF  2C
127E:  CALL   0626
....................        lcd_putc("MEN MOTOR PAS A."); //lo que se escribe 
1282:  CLRF   28
1284:  MOVF   28,W
1286:  CALL   038E
128A:  IORLW  00
128C:  BZ    1298
128E:  INCF   28,F
1290:  MOVWF  2A
1292:  CALL   0682
1296:  BRA    1284
....................        lcd_gotoxy(3,2);              //escribir en a primera fila primera posicion  
1298:  MOVLW  03
129A:  MOVWF  2B
129C:  MOVLW  02
129E:  MOVWF  2C
12A0:  CALL   0626
....................        lcd_putc("EN CONSTRUCCION"); 
12A4:  CLRF   28
12A6:  MOVF   28,W
12A8:  CALL   0350
12AC:  IORLW  00
12AE:  BZ    12BA
12B0:  INCF   28,F
12B2:  MOVWF  2A
12B4:  CALL   0682
12B8:  BRA    12A6
....................        delay_ms(3000); 
12BA:  MOVLW  0C
12BC:  MOVWF  28
12BE:  MOVLW  FA
12C0:  MOVWF  2B
12C2:  CALL   051A
12C6:  DECFSZ 28,F
12C8:  BRA    12BE
....................        goto Miguel; 
12CA:  BRA    0F34
....................      } 
....................      else if(datom==0x05) 
12CC:  BRA    14A8
12CE:  MOVF   1F,W
12D0:  SUBLW  05
12D2:  BNZ   1332
....................      { 
....................        lcd_putc('\f');              //Limpiar pantalla comando 
12D4:  MOVLW  0C
12D6:  MOVWF  2A
12D8:  CALL   0682
....................        lcd_gotoxy(1,1);             //escribir en a primera fila primera posicion  
12DC:  MOVLW  01
12DE:  MOVWF  2B
12E0:  MOVWF  2C
12E2:  CALL   0626
....................        lcd_putc("MEN SERVOMOTOR");  //lo que se escribe 
12E6:  CLRF   28
12E8:  MOVF   28,W
12EA:  CALL   03B0
12EE:  IORLW  00
12F0:  BZ    12FC
12F2:  INCF   28,F
12F4:  MOVWF  2A
12F6:  CALL   0682
12FA:  BRA    12E8
....................        lcd_gotoxy(3,2);             //escribir en a primera fila primera posicion  
12FC:  MOVLW  03
12FE:  MOVWF  2B
1300:  MOVLW  02
1302:  MOVWF  2C
1304:  CALL   0626
....................        lcd_putc("EN CONSTRUCCION"); 
1308:  CLRF   28
130A:  MOVF   28,W
130C:  CALL   0350
1310:  IORLW  00
1312:  BZ    131E
1314:  INCF   28,F
1316:  MOVWF  2A
1318:  CALL   0682
131C:  BRA    130A
....................        delay_ms(3000); 
131E:  MOVLW  0C
1320:  MOVWF  28
1322:  MOVLW  FA
1324:  MOVWF  2B
1326:  CALL   051A
132A:  DECFSZ 28,F
132C:  BRA    1322
....................        goto Miguel; 
132E:  BRA    0F34
....................      } 
....................    else  if(datom==0x06) 
1330:  BRA    14A8
1332:  MOVF   1F,W
1334:  SUBLW  06
1336:  BNZ   1396
....................      { 
....................        lcd_putc('\f');               //Limpiar pantalla comando 
1338:  MOVLW  0C
133A:  MOVWF  2A
133C:  CALL   0682
....................        lcd_gotoxy(1,1);              //escribir en a primera fila primera posicion  
1340:  MOVLW  01
1342:  MOVWF  2B
1344:  MOVWF  2C
1346:  CALL   0626
....................        lcd_putc("MENU CAD");         //lo que se escribe 
134A:  CLRF   28
134C:  MOVF   28,W
134E:  CALL   03D0
1352:  IORLW  00
1354:  BZ    1360
1356:  INCF   28,F
1358:  MOVWF  2A
135A:  CALL   0682
135E:  BRA    134C
....................        lcd_gotoxy(3,2);              //escribir en a primera fila primera posicion  
1360:  MOVLW  03
1362:  MOVWF  2B
1364:  MOVLW  02
1366:  MOVWF  2C
1368:  CALL   0626
....................        lcd_putc("EN CONSTRUCCION"); 
136C:  CLRF   28
136E:  MOVF   28,W
1370:  CALL   0350
1374:  IORLW  00
1376:  BZ    1382
1378:  INCF   28,F
137A:  MOVWF  2A
137C:  CALL   0682
1380:  BRA    136E
....................        delay_ms(3000); 
1382:  MOVLW  0C
1384:  MOVWF  28
1386:  MOVLW  FA
1388:  MOVWF  2B
138A:  CALL   051A
138E:  DECFSZ 28,F
1390:  BRA    1386
....................        goto Miguel; 
1392:  BRA    0F34
....................      } 
....................     else if(datom==0x07) 
1394:  BRA    14A8
1396:  MOVF   1F,W
1398:  SUBLW  07
139A:  BNZ   13FA
....................      { 
....................        lcd_putc('\f');               //Limpiar pantalla comando 
139C:  MOVLW  0C
139E:  MOVWF  2A
13A0:  CALL   0682
....................        lcd_gotoxy(1,1);              //escribir en a primera fila primera posicion  
13A4:  MOVLW  01
13A6:  MOVWF  2B
13A8:  MOVWF  2C
13AA:  CALL   0626
....................        lcd_putc("MEN DTMF");         //lo que se escribe 
13AE:  CLRF   28
13B0:  MOVF   28,W
13B2:  CALL   03EA
13B6:  IORLW  00
13B8:  BZ    13C4
13BA:  INCF   28,F
13BC:  MOVWF  2A
13BE:  CALL   0682
13C2:  BRA    13B0
....................        lcd_gotoxy(3,2);              //escribir en a primera fila primera posicion  
13C4:  MOVLW  03
13C6:  MOVWF  2B
13C8:  MOVLW  02
13CA:  MOVWF  2C
13CC:  CALL   0626
....................        lcd_putc("EN CONSTRUCCION"); 
13D0:  CLRF   28
13D2:  MOVF   28,W
13D4:  CALL   0350
13D8:  IORLW  00
13DA:  BZ    13E6
13DC:  INCF   28,F
13DE:  MOVWF  2A
13E0:  CALL   0682
13E4:  BRA    13D2
....................        delay_ms(3000); 
13E6:  MOVLW  0C
13E8:  MOVWF  28
13EA:  MOVLW  FA
13EC:  MOVWF  2B
13EE:  CALL   051A
13F2:  DECFSZ 28,F
13F4:  BRA    13EA
....................       goto Miguel; 
13F6:  BRA    0F34
....................      } 
....................     else if(datom==0x08) 
13F8:  BRA    14A8
13FA:  MOVF   1F,W
13FC:  SUBLW  08
13FE:  BNZ   145E
....................      { 
....................        lcd_putc('\f');              //Limpiar pantalla comando 
1400:  MOVLW  0C
1402:  MOVWF  2A
1404:  CALL   0682
....................        lcd_gotoxy(1,1);             //escribir en a primera fila primera posicion  
1408:  MOVLW  01
140A:  MOVWF  2B
140C:  MOVWF  2C
140E:  CALL   0626
....................        lcd_putc("MEN SENSORES");    //lo que se escribe 
1412:  CLRF   28
1414:  MOVF   28,W
1416:  CALL   0404
141A:  IORLW  00
141C:  BZ    1428
141E:  INCF   28,F
1420:  MOVWF  2A
1422:  CALL   0682
1426:  BRA    1414
....................        lcd_gotoxy(3,2);             //escribir en a primera fila primera posicion  
1428:  MOVLW  03
142A:  MOVWF  2B
142C:  MOVLW  02
142E:  MOVWF  2C
1430:  CALL   0626
....................        lcd_putc("EN CONSTRUCCION"); 
1434:  CLRF   28
1436:  MOVF   28,W
1438:  CALL   0350
143C:  IORLW  00
143E:  BZ    144A
1440:  INCF   28,F
1442:  MOVWF  2A
1444:  CALL   0682
1448:  BRA    1436
....................        delay_ms(3000); 
144A:  MOVLW  0C
144C:  MOVWF  28
144E:  MOVLW  FA
1450:  MOVWF  2B
1452:  CALL   051A
1456:  DECFSZ 28,F
1458:  BRA    144E
....................        goto Miguel; 
145A:  BRA    0F34
....................      } 
....................     else if(datom==0x09) 
145C:  BRA    14A8
145E:  MOVF   1F,W
1460:  SUBLW  09
1462:  BNZ   1468
....................      { 
....................       goto admin; 
1464:  BRA    0D72
....................      } 
....................      else{ 
1466:  BRA    14A8
....................           lcd_putc('\f');                 //Limpiar pantalla comando 
1468:  MOVLW  0C
146A:  MOVWF  2A
146C:  CALL   0682
....................           lcd_gotoxy(1,2);                //escribir en a primera fila primera posicion  
1470:  MOVLW  01
1472:  MOVWF  2B
1474:  MOVLW  02
1476:  MOVWF  2C
1478:  CALL   0626
....................           lcd_putc("ERROR DE NUMERO");   //lo que se escribe 
147C:  CLRF   28
147E:  MOVF   28,W
1480:  CALL   01FA
1484:  IORLW  00
1486:  BZ    1492
1488:  INCF   28,F
148A:  MOVWF  2A
148C:  CALL   0682
1490:  BRA    147E
....................           delay_ms(3000); 
1492:  MOVLW  0C
1494:  MOVWF  28
1496:  MOVLW  FA
1498:  MOVWF  2B
149A:  CALL   051A
149E:  DECFSZ 28,F
14A0:  BRA    1496
....................           goto menu; 
14A2:  GOTO   0C32
....................      goto admin; 
14A6:  BRA    0D72
....................      } 
....................      } 
....................    
....................     else if(clave[0]==datoi[3] & clave[1]==datoi[2]) 
14A8:  BRA    1A88
14AA:  MOVF   1B,W
14AC:  SUBWF  14,W
14AE:  BZ    14B4
14B0:  MOVLW  00
14B2:  BRA    14B6
14B4:  MOVLW  01
14B6:  MOVWF  28
14B8:  MOVF   1A,W
14BA:  SUBWF  15,W
14BC:  BZ    14C2
14BE:  MOVLW  00
14C0:  BRA    14C4
14C2:  MOVLW  01
14C4:  ANDWF  28,W
14C6:  BTFSC  FD8.2
14C8:  BRA    1A4A
....................     { 
.................... David:adres=0x02; 
14CA:  MOVLW  02
14CC:  MOVWF  1C
....................        /*escribirle al lcd 
....................        bienvenidos al menu del diseador 
....................        marque 1 para cambiar clave 
....................        marque 2 para fecha y hora 
....................        marque 3 para reportes 
....................        marque 4 para motor paso a paso 
....................        marque 5 para servomotor 
....................        marque 6 para cad 
....................        marque 7 para DTMF 
....................        marque 8 para sensores 
....................        marque 9 para salir*/ 
....................       
....................     lcd_putc('\f');                       //Limpiar pantalla comando 
14CE:  MOVLW  0C
14D0:  MOVWF  2A
14D2:  CALL   0682
....................     lcd_gotoxy(1,1);                      //escribir en a primera fila primera posicion  
14D6:  MOVLW  01
14D8:  MOVWF  2B
14DA:  MOVWF  2C
14DC:  CALL   0626
....................     lcd_putc("Bienvenidos al");              //lo que se escribe 
14E0:  CLRF   28
14E2:  MOVF   28,W
14E4:  CALL   00FE
14E8:  IORLW  00
14EA:  BZ    14F6
14EC:  INCF   28,F
14EE:  MOVWF  2A
14F0:  CALL   0682
14F4:  BRA    14E2
....................     lcd_gotoxy(4,2);                      //escribir en a primera fila primera posicion  
14F6:  MOVLW  04
14F8:  MOVWF  2B
14FA:  MOVLW  02
14FC:  MOVWF  2C
14FE:  CALL   0626
....................     lcd_putc("menu de Santiago"); 
1502:  CLRF   28
1504:  MOVF   28,W
1506:  CALL   0422
150A:  IORLW  00
150C:  BZ    1518
150E:  INCF   28,F
1510:  MOVWF  2A
1512:  CALL   0682
1516:  BRA    1504
....................     delay_ms(3000);  
1518:  MOVLW  0C
151A:  MOVWF  28
151C:  MOVLW  FA
151E:  MOVWF  2B
1520:  CALL   051A
1524:  DECFSZ 28,F
1526:  BRA    151C
....................         
....................     lcd_putc('\f');                       //Limpiar pantalla comando 
1528:  MOVLW  0C
152A:  MOVWF  2A
152C:  CALL   0682
....................     lcd_gotoxy(1,1);                      //escribir en a primera fila primera posicion  
1530:  MOVLW  01
1532:  MOVWF  2B
1534:  MOVWF  2C
1536:  CALL   0626
....................     lcd_putc("marque 1 para");          //lo que se escribe 
153A:  CLRF   28
153C:  MOVF   28,W
153E:  CALL   0444
1542:  IORLW  00
1544:  BZ    1550
1546:  INCF   28,F
1548:  MOVWF  2A
154A:  CALL   0682
154E:  BRA    153C
....................     lcd_gotoxy(1,2);                      //escribir en a primera fila primera posicion  
1550:  MOVLW  01
1552:  MOVWF  2B
1554:  MOVLW  02
1556:  MOVWF  2C
1558:  CALL   0626
....................     lcd_putc("cambiar clave"); 
155C:  CLRF   28
155E:  MOVF   28,W
1560:  CALL   0462
1564:  IORLW  00
1566:  BZ    1572
1568:  INCF   28,F
156A:  MOVWF  2A
156C:  CALL   0682
1570:  BRA    155E
....................     delay_ms(3000);   
1572:  MOVLW  0C
1574:  MOVWF  28
1576:  MOVLW  FA
1578:  MOVWF  2B
157A:  CALL   051A
157E:  DECFSZ 28,F
1580:  BRA    1576
....................      
....................     lcd_putc('\f');                      //Limpiar pantalla comando 
1582:  MOVLW  0C
1584:  MOVWF  2A
1586:  CALL   0682
....................     lcd_gotoxy(1,1);                     //escribir en a primera fila primera posicion  
158A:  MOVLW  01
158C:  MOVWF  2B
158E:  MOVWF  2C
1590:  CALL   0626
....................     lcd_putc("9 para salir");          //lo que se escribe 
1594:  CLRF   28
1596:  MOVF   28,W
1598:  CALL   0480
159C:  IORLW  00
159E:  BZ    15AA
15A0:  INCF   28,F
15A2:  MOVWF  2A
15A4:  CALL   0682
15A8:  BRA    1596
....................      
....................     delay_ms(3000); 
15AA:  MOVLW  0C
15AC:  MOVWF  28
15AE:  MOVLW  FA
15B0:  MOVWF  2B
15B2:  CALL   051A
15B6:  DECFSZ 28,F
15B8:  BRA    15AE
....................      
....................      
....................     un_digito(); 
15BA:  CALL   0B28
....................     if(datom==0x01) 
15BE:  DECFSZ 1F,W
15C0:  BRA    1742
....................      { 
....................        lcd_putc('\f');                   //Limpiar pantalla comando 
15C2:  MOVLW  0C
15C4:  MOVWF  2A
15C6:  CALL   0682
....................        lcd_gotoxy(1,1);                  //escribir en a primera fila primera posicion  
15CA:  MOVLW  01
15CC:  MOVWF  2B
15CE:  MOVWF  2C
15D0:  CALL   0626
....................        lcd_putc("Menu de cambio");     //lo que se escribe 
15D4:  CLRF   28
15D6:  MOVF   28,W
15D8:  CALL   049E
15DC:  IORLW  00
15DE:  BZ    15EA
15E0:  INCF   28,F
15E2:  MOVWF  2A
15E4:  CALL   0682
15E8:  BRA    15D6
....................        lcd_gotoxy(3,2);                  //escribir en a primera fila primera posicion  
15EA:  MOVLW  03
15EC:  MOVWF  2B
15EE:  MOVLW  02
15F0:  MOVWF  2C
15F2:  CALL   0626
....................        lcd_putc("de clave");     //clave[0]= y clave[1]= 
15F6:  CLRF   28
15F8:  MOVF   28,W
15FA:  CALL   04BE
15FE:  IORLW  00
1600:  BZ    160C
1602:  INCF   28,F
1604:  MOVWF  2A
1606:  CALL   0682
160A:  BRA    15F8
....................        delay_ms(3000); 
160C:  MOVLW  0C
160E:  MOVWF  28
1610:  MOVLW  FA
1612:  MOVWF  2B
1614:  CALL   051A
1618:  DECFSZ 28,F
161A:  BRA    1610
....................        teclado(); 
161C:  CALL   08FA
....................         
....................        dato1=clave[0]; 
1620:  MOVFF  14,1D
....................        dato2=clave[1]; 
1624:  MOVFF  15,1E
....................         
....................        lcd_putc('\f');                   //Limpiar pantalla comando 
1628:  MOVLW  0C
162A:  MOVWF  2A
162C:  CALL   0682
....................        lcd_gotoxy(1,1);                  //escribir en a primera fila primera posicion  
1630:  MOVLW  01
1632:  MOVWF  2B
1634:  MOVWF  2C
1636:  CALL   0626
....................        lcd_putc("POR FAVOR DIGITE");     //lo que se escribe 
163A:  CLRF   28
163C:  MOVF   28,W
163E:  CALL   0294
1642:  IORLW  00
1644:  BZ    1650
1646:  INCF   28,F
1648:  MOVWF  2A
164A:  CALL   0682
164E:  BRA    163C
....................        lcd_gotoxy(1,2);                  //escribir en a primera fila primera posicion  
1650:  MOVLW  01
1652:  MOVWF  2B
1654:  MOVLW  02
1656:  MOVWF  2C
1658:  CALL   0626
....................        lcd_putc("DIGITE NUE.CLAVE");    
165C:  CLRF   28
165E:  MOVF   28,W
1660:  CALL   04D8
1664:  IORLW  00
1666:  BZ    1672
1668:  INCF   28,F
166A:  MOVWF  2A
166C:  CALL   0682
1670:  BRA    165E
....................        delay_ms(3000); 
1672:  MOVLW  0C
1674:  MOVWF  28
1676:  MOVLW  FA
1678:  MOVWF  2B
167A:  CALL   051A
167E:  DECFSZ 28,F
1680:  BRA    1676
....................         
....................        teclado(); 
1682:  CALL   08FA
....................         
....................        if(clave[0]==dato1 & clave[1]==dato2) 
1686:  MOVF   1D,W
1688:  SUBWF  14,W
168A:  BZ    1690
168C:  MOVLW  00
168E:  BRA    1692
1690:  MOVLW  01
1692:  MOVWF  28
1694:  MOVF   1E,W
1696:  SUBWF  15,W
1698:  BZ    169E
169A:  MOVLW  00
169C:  BRA    16A0
169E:  MOVLW  01
16A0:  ANDWF  28,W
16A2:  BZ    1706
....................        { 
....................         escribir_memoria(); 
16A4:  CALL   0B8A
....................         lcd_putc('\f');                   //Limpiar pantalla comando 
16A8:  MOVLW  0C
16AA:  MOVWF  2A
16AC:  CALL   0682
....................         lcd_gotoxy(1,1);                  //escribir en a primera fila primera posicion  
16B0:  MOVLW  01
16B2:  MOVWF  2B
16B4:  MOVWF  2C
16B6:  CALL   0626
....................         lcd_putc("CLAVE MODIFICADA");     //lo que se escribe 
16BA:  CLRF   28
16BC:  MOVF   28,W
16BE:  CALL   02D2
16C2:  IORLW  00
16C4:  BZ    16D0
16C6:  INCF   28,F
16C8:  MOVWF  2A
16CA:  CALL   0682
16CE:  BRA    16BC
....................         lcd_gotoxy(3,2);                  //escribir en a primera fila primera posicion  
16D0:  MOVLW  03
16D2:  MOVWF  2B
16D4:  MOVLW  02
16D6:  MOVWF  2C
16D8:  CALL   0626
....................         lcd_putc("CON EXITO");    
16DC:  CLRF   28
16DE:  MOVF   28,W
16E0:  CALL   02F4
16E4:  IORLW  00
16E6:  BZ    16F2
16E8:  INCF   28,F
16EA:  MOVWF  2A
16EC:  CALL   0682
16F0:  BRA    16DE
....................         delay_ms(3000); 
16F2:  MOVLW  0C
16F4:  MOVWF  28
16F6:  MOVLW  FA
16F8:  MOVWF  2B
16FA:  CALL   051A
16FE:  DECFSZ 28,F
1700:  BRA    16F6
....................           goto David; 
1702:  BRA    14CA
....................        } 
....................        else{ 
1704:  BRA    1740
....................        lcd_putc('\f');                   //Limpiar pantalla comando 
1706:  MOVLW  0C
1708:  MOVWF  2A
170A:  CALL   0682
....................        lcd_gotoxy(1,1);                  //escribir en a primera fila primera posicion  
170E:  MOVLW  01
1710:  MOVWF  2B
1712:  MOVWF  2C
1714:  CALL   0626
....................        lcd_putc("ERROR DE CLAVE");     //lo que se escribe 
1718:  CLRF   28
171A:  MOVF   28,W
171C:  CALL   030E
1720:  IORLW  00
1722:  BZ    172E
1724:  INCF   28,F
1726:  MOVWF  2A
1728:  CALL   0682
172C:  BRA    171A
....................        delay_ms(3000); 
172E:  MOVLW  0C
1730:  MOVWF  28
1732:  MOVLW  FA
1734:  MOVWF  2B
1736:  CALL   051A
173A:  DECFSZ 28,F
173C:  BRA    1732
....................        goto David; 
173E:  BRA    14CA
....................        } 
....................         
....................      } 
....................      else if(datom==0x02) 
1740:  BRA    1A48
1742:  MOVF   1F,W
1744:  SUBLW  02
1746:  BNZ   17A6
....................      { 
....................        lcd_putc('\f');                  //Limpiar pantalla comando 
1748:  MOVLW  0C
174A:  MOVWF  2A
174C:  CALL   0682
....................        lcd_gotoxy(1,1);                 //escribir en a primera fila primera posicion  
1750:  MOVLW  01
1752:  MOVWF  2B
1754:  MOVWF  2C
1756:  CALL   0626
....................        lcd_putc("MEN FECHA Y HORA");    //lo que se escribe 
175A:  CLRF   28
175C:  MOVF   28,W
175E:  CALL   032E
1762:  IORLW  00
1764:  BZ    1770
1766:  INCF   28,F
1768:  MOVWF  2A
176A:  CALL   0682
176E:  BRA    175C
....................        lcd_gotoxy(3,2);                 //escribir en a primera fila primera posicion  
1770:  MOVLW  03
1772:  MOVWF  2B
1774:  MOVLW  02
1776:  MOVWF  2C
1778:  CALL   0626
....................        lcd_putc("EN CONSTRUCCION"); 
177C:  CLRF   28
177E:  MOVF   28,W
1780:  CALL   0350
1784:  IORLW  00
1786:  BZ    1792
1788:  INCF   28,F
178A:  MOVWF  2A
178C:  CALL   0682
1790:  BRA    177E
....................        delay_ms(3000); 
1792:  MOVLW  0C
1794:  MOVWF  28
1796:  MOVLW  FA
1798:  MOVWF  2B
179A:  CALL   051A
179E:  DECFSZ 28,F
17A0:  BRA    1796
....................        goto David; 
17A2:  BRA    14CA
....................      } 
....................     else  if(datom==0x03) 
17A4:  BRA    1A48
17A6:  MOVF   1F,W
17A8:  SUBLW  03
17AA:  BNZ   180A
....................      { 
....................        lcd_putc('\f');                //Limpiar pantalla comando 
17AC:  MOVLW  0C
17AE:  MOVWF  2A
17B0:  CALL   0682
....................        lcd_gotoxy(1,1);               //escribir en a primera fila primera posicion  
17B4:  MOVLW  01
17B6:  MOVWF  2B
17B8:  MOVWF  2C
17BA:  CALL   0626
....................        lcd_putc("MENU REPORTES");     //lo que se escribe 
17BE:  CLRF   28
17C0:  MOVF   28,W
17C2:  CALL   0370
17C6:  IORLW  00
17C8:  BZ    17D4
17CA:  INCF   28,F
17CC:  MOVWF  2A
17CE:  CALL   0682
17D2:  BRA    17C0
....................        lcd_gotoxy(3,2);               //escribir en a primera fila primera posicion  
17D4:  MOVLW  03
17D6:  MOVWF  2B
17D8:  MOVLW  02
17DA:  MOVWF  2C
17DC:  CALL   0626
....................        lcd_putc("EN CONSTRUCCION"); 
17E0:  CLRF   28
17E2:  MOVF   28,W
17E4:  CALL   0350
17E8:  IORLW  00
17EA:  BZ    17F6
17EC:  INCF   28,F
17EE:  MOVWF  2A
17F0:  CALL   0682
17F4:  BRA    17E2
....................        delay_ms(3000); 
17F6:  MOVLW  0C
17F8:  MOVWF  28
17FA:  MOVLW  FA
17FC:  MOVWF  2B
17FE:  CALL   051A
1802:  DECFSZ 28,F
1804:  BRA    17FA
....................        goto David;; 
1806:  BRA    14CA
....................      } 
....................     else if(datom==0x04) 
1808:  BRA    1A48
180A:  MOVF   1F,W
180C:  SUBLW  04
180E:  BNZ   186E
....................      { 
....................        lcd_putc('\f');               //Limpiar pantalla comando 
1810:  MOVLW  0C
1812:  MOVWF  2A
1814:  CALL   0682
....................        lcd_gotoxy(1,1);              //escribir en a primera fila primera posicion  
1818:  MOVLW  01
181A:  MOVWF  2B
181C:  MOVWF  2C
181E:  CALL   0626
....................        lcd_putc("MEN MOTOR PAS A."); //lo que se escribe 
1822:  CLRF   28
1824:  MOVF   28,W
1826:  CALL   038E
182A:  IORLW  00
182C:  BZ    1838
182E:  INCF   28,F
1830:  MOVWF  2A
1832:  CALL   0682
1836:  BRA    1824
....................        lcd_gotoxy(3,2);              //escribir en a primera fila primera posicion  
1838:  MOVLW  03
183A:  MOVWF  2B
183C:  MOVLW  02
183E:  MOVWF  2C
1840:  CALL   0626
....................        lcd_putc("EN CONSTRUCCION"); 
1844:  CLRF   28
1846:  MOVF   28,W
1848:  CALL   0350
184C:  IORLW  00
184E:  BZ    185A
1850:  INCF   28,F
1852:  MOVWF  2A
1854:  CALL   0682
1858:  BRA    1846
....................        delay_ms(3000); 
185A:  MOVLW  0C
185C:  MOVWF  28
185E:  MOVLW  FA
1860:  MOVWF  2B
1862:  CALL   051A
1866:  DECFSZ 28,F
1868:  BRA    185E
....................        goto David; 
186A:  BRA    14CA
....................      } 
....................     else if(datom==0x05) 
186C:  BRA    1A48
186E:  MOVF   1F,W
1870:  SUBLW  05
1872:  BNZ   18D2
....................      { 
....................        lcd_putc('\f');              //Limpiar pantalla comando 
1874:  MOVLW  0C
1876:  MOVWF  2A
1878:  CALL   0682
....................        lcd_gotoxy(1,1);             //escribir en a primera fila primera posicion  
187C:  MOVLW  01
187E:  MOVWF  2B
1880:  MOVWF  2C
1882:  CALL   0626
....................        lcd_putc("MEN SERVOMOTOR");  //lo que se escribe 
1886:  CLRF   28
1888:  MOVF   28,W
188A:  CALL   03B0
188E:  IORLW  00
1890:  BZ    189C
1892:  INCF   28,F
1894:  MOVWF  2A
1896:  CALL   0682
189A:  BRA    1888
....................        lcd_gotoxy(3,2);             //escribir en a primera fila primera posicion  
189C:  MOVLW  03
189E:  MOVWF  2B
18A0:  MOVLW  02
18A2:  MOVWF  2C
18A4:  CALL   0626
....................        lcd_putc("EN CONSTRUCCION"); 
18A8:  CLRF   28
18AA:  MOVF   28,W
18AC:  CALL   0350
18B0:  IORLW  00
18B2:  BZ    18BE
18B4:  INCF   28,F
18B6:  MOVWF  2A
18B8:  CALL   0682
18BC:  BRA    18AA
....................        delay_ms(3000); 
18BE:  MOVLW  0C
18C0:  MOVWF  28
18C2:  MOVLW  FA
18C4:  MOVWF  2B
18C6:  CALL   051A
18CA:  DECFSZ 28,F
18CC:  BRA    18C2
....................        goto David; 
18CE:  BRA    14CA
....................      } 
....................     else if(datom==0x06) 
18D0:  BRA    1A48
18D2:  MOVF   1F,W
18D4:  SUBLW  06
18D6:  BNZ   1936
....................      { 
....................        lcd_putc('\f');               //Limpiar pantalla comando 
18D8:  MOVLW  0C
18DA:  MOVWF  2A
18DC:  CALL   0682
....................        lcd_gotoxy(1,1);              //escribir en a primera fila primera posicion  
18E0:  MOVLW  01
18E2:  MOVWF  2B
18E4:  MOVWF  2C
18E6:  CALL   0626
....................        lcd_putc("MENU CAD");         //lo que se escribe 
18EA:  CLRF   28
18EC:  MOVF   28,W
18EE:  CALL   03D0
18F2:  IORLW  00
18F4:  BZ    1900
18F6:  INCF   28,F
18F8:  MOVWF  2A
18FA:  CALL   0682
18FE:  BRA    18EC
....................        lcd_gotoxy(3,2);              //escribir en a primera fila primera posicion  
1900:  MOVLW  03
1902:  MOVWF  2B
1904:  MOVLW  02
1906:  MOVWF  2C
1908:  CALL   0626
....................        lcd_putc("EN CONSTRUCCION"); 
190C:  CLRF   28
190E:  MOVF   28,W
1910:  CALL   0350
1914:  IORLW  00
1916:  BZ    1922
1918:  INCF   28,F
191A:  MOVWF  2A
191C:  CALL   0682
1920:  BRA    190E
....................        delay_ms(3000); 
1922:  MOVLW  0C
1924:  MOVWF  28
1926:  MOVLW  FA
1928:  MOVWF  2B
192A:  CALL   051A
192E:  DECFSZ 28,F
1930:  BRA    1926
....................        goto David; 
1932:  BRA    14CA
....................      } 
....................     else if(datom==0x07) 
1934:  BRA    1A48
1936:  MOVF   1F,W
1938:  SUBLW  07
193A:  BNZ   199A
....................      { 
....................        lcd_putc('\f');               //Limpiar pantalla comando 
193C:  MOVLW  0C
193E:  MOVWF  2A
1940:  CALL   0682
....................        lcd_gotoxy(1,1);              //escribir en a primera fila primera posicion  
1944:  MOVLW  01
1946:  MOVWF  2B
1948:  MOVWF  2C
194A:  CALL   0626
....................        lcd_putc("MEN DTMF");         //lo que se escribe 
194E:  CLRF   28
1950:  MOVF   28,W
1952:  CALL   03EA
1956:  IORLW  00
1958:  BZ    1964
195A:  INCF   28,F
195C:  MOVWF  2A
195E:  CALL   0682
1962:  BRA    1950
....................        lcd_gotoxy(3,2);              //escribir en a primera fila primera posicion  
1964:  MOVLW  03
1966:  MOVWF  2B
1968:  MOVLW  02
196A:  MOVWF  2C
196C:  CALL   0626
....................        lcd_putc("EN CONSTRUCCION"); 
1970:  CLRF   28
1972:  MOVF   28,W
1974:  CALL   0350
1978:  IORLW  00
197A:  BZ    1986
197C:  INCF   28,F
197E:  MOVWF  2A
1980:  CALL   0682
1984:  BRA    1972
....................        delay_ms(3000); 
1986:  MOVLW  0C
1988:  MOVWF  28
198A:  MOVLW  FA
198C:  MOVWF  2B
198E:  CALL   051A
1992:  DECFSZ 28,F
1994:  BRA    198A
....................        goto David; 
1996:  BRA    14CA
....................      } 
....................     else if(datom==0x08) 
1998:  BRA    1A48
199A:  MOVF   1F,W
199C:  SUBLW  08
199E:  BNZ   19FE
....................      { 
....................        lcd_putc('\f');              //Limpiar pantalla comando 
19A0:  MOVLW  0C
19A2:  MOVWF  2A
19A4:  CALL   0682
....................        lcd_gotoxy(1,1);             //escribir en a primera fila primera posicion  
19A8:  MOVLW  01
19AA:  MOVWF  2B
19AC:  MOVWF  2C
19AE:  CALL   0626
....................        lcd_putc("MEN SENSORES");    //lo que se escribe 
19B2:  CLRF   28
19B4:  MOVF   28,W
19B6:  CALL   0404
19BA:  IORLW  00
19BC:  BZ    19C8
19BE:  INCF   28,F
19C0:  MOVWF  2A
19C2:  CALL   0682
19C6:  BRA    19B4
....................        lcd_gotoxy(3,2);             //escribir en a primera fila primera posicion  
19C8:  MOVLW  03
19CA:  MOVWF  2B
19CC:  MOVLW  02
19CE:  MOVWF  2C
19D0:  CALL   0626
....................        lcd_putc("EN CONSTRUCCION"); 
19D4:  CLRF   28
19D6:  MOVF   28,W
19D8:  CALL   0350
19DC:  IORLW  00
19DE:  BZ    19EA
19E0:  INCF   28,F
19E2:  MOVWF  2A
19E4:  CALL   0682
19E8:  BRA    19D6
....................        delay_ms(3000); 
19EA:  MOVLW  0C
19EC:  MOVWF  28
19EE:  MOVLW  FA
19F0:  MOVWF  2B
19F2:  CALL   051A
19F6:  DECFSZ 28,F
19F8:  BRA    19EE
....................        goto David; 
19FA:  BRA    14CA
....................      } 
....................     else if(datom==0x09) 
19FC:  BRA    1A48
19FE:  MOVF   1F,W
1A00:  SUBLW  09
1A02:  BNZ   1A0A
....................      { 
....................       goto admin; 
1A04:  GOTO   0D72
....................      } 
....................      else{ 
1A08:  BRA    1A48
....................           lcd_putc('\f');                 //Limpiar pantalla comando 
1A0A:  MOVLW  0C
1A0C:  MOVWF  2A
1A0E:  CALL   0682
....................           lcd_gotoxy(1,2);                //escribir en a primera fila primera posicion  
1A12:  MOVLW  01
1A14:  MOVWF  2B
1A16:  MOVLW  02
1A18:  MOVWF  2C
1A1A:  CALL   0626
....................           lcd_putc("ERROR DE NUMERO");   //lo que se escribe 
1A1E:  CLRF   28
1A20:  MOVF   28,W
1A22:  CALL   01FA
1A26:  IORLW  00
1A28:  BZ    1A34
1A2A:  INCF   28,F
1A2C:  MOVWF  2A
1A2E:  CALL   0682
1A32:  BRA    1A20
....................           delay_ms(3000); 
1A34:  MOVLW  0C
1A36:  MOVWF  28
1A38:  MOVLW  FA
1A3A:  MOVWF  2B
1A3C:  CALL   051A
1A40:  DECFSZ 28,F
1A42:  BRA    1A38
....................           goto menu; 
1A44:  GOTO   0C32
....................       } 
....................      }else{ 
1A48:  BRA    1A88
....................      lcd_putc('\f');                 //Limpiar pantalla comando 
1A4A:  MOVLW  0C
1A4C:  MOVWF  2A
1A4E:  CALL   0682
....................      lcd_gotoxy(1,2);                //escribir en a primera fila primera posicion  
1A52:  MOVLW  01
1A54:  MOVWF  2B
1A56:  MOVLW  02
1A58:  MOVWF  2C
1A5A:  CALL   0626
....................      lcd_putc("CONTRA. ERRONEA");   //lo que se escribe 
1A5E:  CLRF   28
1A60:  MOVF   28,W
1A62:  CALL   04FA
1A66:  IORLW  00
1A68:  BZ    1A74
1A6A:  INCF   28,F
1A6C:  MOVWF  2A
1A6E:  CALL   0682
1A72:  BRA    1A60
....................      delay_ms(3000); 
1A74:  MOVLW  0C
1A76:  MOVWF  28
1A78:  MOVLW  FA
1A7A:  MOVWF  2B
1A7C:  CALL   051A
1A80:  DECFSZ 28,F
1A82:  BRA    1A78
....................      goto menu; 
1A84:  GOTO   0C32
....................      } 
....................    } 
....................  
1A88:  SLEEP 

Configuration Fuses:
   Word  1: 0C00   NOIESO NOFCMEN HS PLL1 CPUDIV1 NOUSBDIV
   Word  2: 1E18   NOBROWNOUT NOWDT BORV20 PUT WDT32768 NOVREGEN
   Word  3: 0300   PBADEN CCP2C1 NOMCLR NOLPT1OSC
   Word  4: 0081   STVREN NODEBUG NOLVP NOXINST NOICPRT
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: E00F   NOWRT NOWRTD NOWRTC NOWRTB
   Word  7: 400F   NOEBTR NOEBTRB

ROM data:
F00000: 16 44 44 16 
