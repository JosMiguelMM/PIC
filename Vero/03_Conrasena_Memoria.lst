CCS PCH C Compiler, Version 4.093, 51109               28-sept.-21 19:44

               Filename: C:\Proyecto arquitectura c\Vero\03_Conrasena_Memoria.lst

               ROM used: 7246 bytes (22%)
                         Largest free fragment is 25522
               RAM used: 45 (2%) at main() level
                         56 (3%) worst case
               Stack:    5 locations

*
0000:  GOTO   0D98
.................... #include <18F4550.h> 
.................... //////// Standard Header file for the PIC18F4550 device //////////////// 
.................... #device PIC18F4550 
.................... #list 
....................  
.................... #fuses     HS,NOPROTECT,NOBROWNOUT,NOWDT,PUT,NOCPD,NODEBUG,NOLVP,NOMCLR  
.................... #use       delay(clock=20000000) 
*
05B8:  CLRF   FEA
05BA:  MOVLW  2E
05BC:  MOVWF  FE9
05BE:  MOVF   FEF,W
05C0:  BZ    05DC
05C2:  MOVLW  06
05C4:  MOVWF  01
05C6:  CLRF   00
05C8:  DECFSZ 00,F
05CA:  BRA    05C8
05CC:  DECFSZ 01,F
05CE:  BRA    05C6
05D0:  MOVLW  7B
05D2:  MOVWF  00
05D4:  DECFSZ 00,F
05D6:  BRA    05D4
05D8:  DECFSZ FEF,F
05DA:  BRA    05C2
05DC:  RETLW  00
.................... #include   <stdlib.h>           //LIBRERIAS MATEMATICAS IGUAL LA DE ABAJO 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = TRUE, sign = FALSE, point = FALSE; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = FALSE; 
....................          if (c == '+') 
....................          { 
....................             sign = FALSE; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = TRUE; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = TRUE; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = TRUE, sign = FALSE, point = FALSE; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = FALSE; 
....................          if (c == '+') 
....................          { 
....................             sign = FALSE; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = TRUE; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = TRUE; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = TRUE, sign = FALSE, point = FALSE; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = FALSE; 
....................          if (c == '+') 
....................          { 
....................             sign = FALSE; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = TRUE; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = TRUE; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    BYTE t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=TRUE; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = FALSE; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include   <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float32)l); 
....................   res = 32768.0*(float32)l; 
....................   res += (float32)(unsigned int16)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float48)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float48)l); 
....................   res = 32768.0*(float32)l; 
....................   res += (float48)(unsigned int16)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float48)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float64)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float64)l); 
....................   res = 32768.0*(float64)l; 
....................   res += (float64)(unsigned int16)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float64)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y/LN2 - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y/LN2 - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y/LN2 - (float64)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {0.45145214, -9.0558803, 26.940971, -19.860189}; 
.................... float32 const ql[4] = {1.0000000,  -8.1354259, 16.780517, -9.9300943}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................    bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................       res = res*y2 + pl[2]; 
....................       res = res*y2 + pl[3]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + ql[2]; 
....................       r = r*y2 + ql[3]; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................     
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................    
....................       if(bit_test(data2,7)) 
....................          bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................       res = res*y2 + pl[2]; 
....................       res = res*y2 + pl[3]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + ql[2]; 
....................       r = r*y2 + ql[3]; 
....................  
....................       res = y*res/r; 
....................  
....................     data1 = *(((unsigned int8 *)(&x)+5)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+4)); 
....................     if(bit_test (data2,7)) 
....................        bit_set(data1,0); 
....................       
....................     n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................          r = -(float48)-n; 
....................       else 
....................          r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float32 const pl_64[4] = {0.45145214, -9.0558803, 26.940971, -19.860189}; 
.................... float32 const ql_64[4] = {1.0000000,  -8.1354259, 16.780517, -9.9300943}; 
.................... #endif 
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................       bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................     bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................    bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................      bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #define TWOBYPI          0.6366197723675813 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[4] = { 
....................       -0.499999993585, 
....................        0.041666636258, 
....................       -0.0013888361399, 
....................        0.00002476016134 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 3; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[4] = { 
....................       -0.499999993585, 
....................        0.041666636258, 
....................       -0.0013888361399, 
....................        0.00002476016134 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 3; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float48 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p[4] = { 
....................       -0.499999993585, 
....................        0.041666636258, 
....................       -0.0013888361399, 
....................        0.00002476016134 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 3; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #define   LCD_E    PIN_E2 
.................... #define   LCD_CK   PIN_E1 
.................... #define   LCD_DAT  PIN_E0 
.................... #include <LCD4x20_3PIN.c> 
.................... // flex_lcd_3_pins.c 
....................  
.................... //Modificacin de Flex_lcd por Duende_Azul y Akenafab 
.................... //Trabaja con 3 pines y 74VHC164 
.................... //8-Bit Serial-In, Parallel-Out Shift Register 
....................  
.................... //La LCD se usa en modo 4bits 
.................... //Revisar diagrama de conexion Adjunto 
....................  
.................... //No esta habilitada la lectura del LCD 
.................... //RW debe ir a gnd 
....................  
.................... //Definir pines antes de llamar libreria// 
.................... //#define LCD_E     PIN_A0 
.................... //#define LCD_CK    PIN_A1    
.................... //#define LCD_DAT   PIN_A2 
....................  
.................... //======================================== 
.................... int RS_bit; 
.................... #define lcd_type 2        // 0=5x7, 1=5x10, 2=2 lines 
.................... #define lcd_line_two 0x40 // LCD RAM address for the 2nd line 
....................  
....................  
.................... int8 const LCD_INIT_STRING[4] = 
.................... { 
....................  0x20 | (lcd_type << 2), // Func set: 4-bit, 2 lines, 5x8 dots 
....................  0xc,                    // Display on 
....................  1,                      // Clear display 
....................  6                       // Increment cursor 
....................  }; 
.................... BYTE lcdline; 
....................  
.................... //------------------------------------- 
.................... void lcd_send_nibble(int8 nibble, int rs_bit) 
.................... { 
....................  
.................... int x; 
.................... if(RS_bit==1) 
05DE:  DECFSZ 36,W
05E0:  BRA    05E4
....................    nibble=nibble|0x10; 
05E2:  BSF    35.4
....................  
.................... for(x=0;x<5;x++){ 
05E4:  CLRF   37
05E6:  MOVF   37,W
05E8:  SUBLW  04
05EA:  BNC   060E
....................          output_bit(LCD_DAT,shift_right(&nibble,1,0)); 
05EC:  BCF    FD8.0
05EE:  RRCF   35,F
05F0:  BC    05F6
05F2:  BCF    F8D.0
05F4:  BRA    05F8
05F6:  BSF    F8D.0
05F8:  BCF    F96.0
....................          delay_cycles(1); 
05FA:  NOP   
....................          output_low(LCD_CK); 
05FC:  BCF    F96.1
05FE:  BCF    F8D.1
....................          delay_us(1); 
0600:  BRA    0602
0602:  BRA    0604
0604:  NOP   
....................          output_high(LCD_CK);} 
0606:  BCF    F96.1
0608:  BSF    F8D.1
060A:  INCF   37,F
060C:  BRA    05E6
....................  
....................  
....................  
....................  output_high(LCD_E); 
060E:  BCF    F96.2
0610:  BSF    F8D.2
....................  delay_us(2); 
0612:  MOVLW  03
0614:  MOVWF  00
0616:  DECFSZ 00,F
0618:  BRA    0616
....................  output_low(LCD_E); 
061A:  BCF    F96.2
061C:  BCF    F8D.2
.................... } 
061E:  RETLW  00
....................  
.................... //----------------------------------- 
.................... //---------------------------------------- 
.................... // Send a byte to the LCD. 
.................... void lcd_send_byte(int8 address, int8 n) 
.................... { 
.................... //output_low(LCD_RS); 
.................... RS_bit=0; 
0620:  CLRF   0B
.................... delay_us(100); 
0622:  MOVLW  A6
0624:  MOVWF  00
0626:  DECFSZ 00,F
0628:  BRA    0626
062A:  NOP   
....................  
....................  
.................... if(address) 
062C:  MOVF   32,F
062E:  BZ    0636
....................    //output_high(LCD_RS); 
....................    RS_bit=1; 
0630:  MOVLW  01
0632:  MOVWF  0B
.................... else 
0634:  BRA    0638
....................    //output_low(LCD_RS); 
....................    RS_bit=0; 
0636:  CLRF   0B
....................  
....................  delay_cycles(1); 
0638:  NOP   
....................  
....................  
.................... output_low(LCD_E); 
063A:  BCF    F96.2
063C:  BCF    F8D.2
....................  
.................... lcd_send_nibble(n >> 4,RS_bit); 
063E:  SWAPF  33,W
0640:  MOVWF  34
0642:  MOVLW  0F
0644:  ANDWF  34,F
0646:  MOVFF  34,35
064A:  MOVFF  0B,36
064E:  RCALL  05DE
.................... lcd_send_nibble(n & 0xf,RS_bit); 
0650:  MOVF   33,W
0652:  ANDLW  0F
0654:  MOVWF  34
0656:  MOVWF  35
0658:  MOVFF  0B,36
065C:  RCALL  05DE
.................... } 
065E:  RETLW  00
....................  
.................... //---------------------------- 
.................... void lcd_init(void) 
.................... { 
.................... int8 i; 
....................  
.................... //output_low(LCD_RS); 
.................... RS_bit=0; 
0660:  CLRF   0B
....................  
.................... output_low(LCD_E); 
0662:  BCF    F96.2
0664:  BCF    F8D.2
....................  
.................... delay_ms(20); 
0666:  MOVLW  14
0668:  MOVWF  2E
066A:  RCALL  05B8
....................  
.................... for(i=0 ;i < 3; i++) 
066C:  CLRF   2C
066E:  MOVF   2C,W
0670:  SUBLW  02
0672:  BNC   0688
....................    { 
....................     lcd_send_nibble(0x03,RS_bit); 
0674:  MOVLW  03
0676:  MOVWF  35
0678:  MOVFF  0B,36
067C:  RCALL  05DE
....................     delay_ms(5); 
067E:  MOVLW  05
0680:  MOVWF  2E
0682:  RCALL  05B8
....................    } 
0684:  INCF   2C,F
0686:  BRA    066E
....................  
.................... lcd_send_nibble(0x02,RS_bit); 
0688:  MOVLW  02
068A:  MOVWF  35
068C:  MOVFF  0B,36
0690:  RCALL  05DE
....................  
.................... for(i=0; i < sizeof(LCD_INIT_STRING); i++) 
0692:  CLRF   2C
0694:  MOVF   2C,W
0696:  SUBLW  03
0698:  BNC   06BC
....................    { 
....................     lcd_send_byte(0, LCD_INIT_STRING[i]); 
069A:  CLRF   03
069C:  MOVF   2C,W
069E:  MOVFF  FF2,2D
06A2:  BCF    FF2.7
06A4:  RCALL  0004
06A6:  BTFSC  2D.7
06A8:  BSF    FF2.7
06AA:  MOVWF  2D
06AC:  CLRF   32
06AE:  MOVWF  33
06B0:  RCALL  0620
....................  
....................     delay_ms(5); 
06B2:  MOVLW  05
06B4:  MOVWF  2E
06B6:  RCALL  05B8
....................      
....................    } 
06B8:  INCF   2C,F
06BA:  BRA    0694
....................  
.................... } 
06BC:  GOTO   0DDE (RETURN)
....................  
.................... //---------------------------- 
....................  
.................... void lcd_gotoxy(int8 x, int8 y) 
.................... { 
.................... int8 address; 
....................  
....................    switch(y) { 
*
06C4:  MOVLW  01
06C6:  SUBWF  2F,W
06C8:  ADDLW  FC
06CA:  BC    06EA
06CC:  ADDLW  04
06CE:  GOTO   06FE
....................      case 1 : address=0x80;break; 
06D2:  MOVLW  80
06D4:  MOVWF  30
06D6:  BRA    06EA
....................      case 2 : address=0xc0;break; 
06D8:  MOVLW  C0
06DA:  MOVWF  30
06DC:  BRA    06EA
....................      case 3 : address=0x94;break; 
06DE:  MOVLW  94
06E0:  MOVWF  30
06E2:  BRA    06EA
....................      case 4 : address=0xd4;break; 
06E4:  MOVLW  D4
06E6:  MOVWF  30
06E8:  BRA    06EA
....................    } 
.................... address += x-1; 
06EA:  MOVLW  01
06EC:  SUBWF  2E,W
06EE:  ADDWF  30,F
.................... lcd_send_byte(0, 0x80 | address); 
06F0:  MOVF   30,W
06F2:  IORLW  80
06F4:  MOVWF  31
06F6:  CLRF   32
06F8:  MOVWF  33
06FA:  RCALL  0620
.................... } 
06FC:  RETLW  00
....................  
.................... //----------------------------- 
.................... void lcd_putc(char c) 
.................... { 
....................  switch(c) 
....................    { 
*
0720:  MOVF   2D,W
0722:  XORLW  0C
0724:  BZ    073C
0726:  XORLW  06
0728:  BZ    0750
072A:  XORLW  02
072C:  BZ    075E
072E:  XORLW  6B
0730:  BZ    0768
0732:  XORLW  04
0734:  BZ    0772
0736:  XORLW  0F
0738:  BZ    077C
073A:  BRA    0786
....................     case '\f':                //limpia pantalla 
....................       lcd_send_byte(0,1); 
073C:  CLRF   32
073E:  MOVLW  01
0740:  MOVWF  33
0742:  RCALL  0620
....................       lcdline=1; 
0744:  MOVLW  01
0746:  MOVWF  0C
....................       delay_ms(8); 
0748:  MOVLW  08
074A:  MOVWF  2E
074C:  RCALL  05B8
....................       break; 
074E:  BRA    0792
....................  
....................     case '\n':                //cambio de linea 
....................        lcd_gotoxy(1,++lcdline); 
0750:  INCF   0C,F
0752:  MOVLW  01
0754:  MOVWF  2E
0756:  MOVFF  0C,2F
075A:  RCALL  06C4
....................        break; 
075C:  BRA    0792
....................  
....................     case '\b':                //retrocede 1 caracter 
....................        lcd_send_byte(0,0x10); 
075E:  CLRF   32
0760:  MOVLW  10
0762:  MOVWF  33
0764:  RCALL  0620
....................        break; 
0766:  BRA    0792
....................         
....................     case '\c':                //on display 
....................     lcd_send_byte(0,0x0c); 
0768:  CLRF   32
076A:  MOVLW  0C
076C:  MOVWF  33
076E:  RCALL  0620
....................     break; 
0770:  BRA    0792
....................     
....................     case '\g':                 
....................     lcd_send_byte(0,0x0f);    // prende cursor y parpadea 
0772:  CLRF   32
0774:  MOVLW  0F
0776:  MOVWF  33
0778:  RCALL  0620
....................     break;   
077A:  BRA    0792
....................  
....................     case '\h':                //retrocede 1 caracter 
....................     lcd_send_byte(0,0x0f);    // prende cursor y parpadea 
077C:  CLRF   32
077E:  MOVLW  0F
0780:  MOVWF  33
0782:  RCALL  0620
....................     break; 
0784:  BRA    0792
....................      
....................     default: 
....................        lcd_send_byte(1,c); 
0786:  MOVLW  01
0788:  MOVWF  32
078A:  MOVFF  2D,33
078E:  RCALL  0620
....................        break; 
0790:  BRA    0792
....................    } 
.................... } 
0792:  RETLW  00
....................  
.................... //------------------------------ 
....................  
.................... void lcd_cursor_vb(short visible, short blink) {  
....................   lcd_send_byte(0, 0xC|(visible<<1)|blink);  
.................... }  
....................  
....................  
.................... #include <KBD18F.c> 
.................... //////////////////////////////////////////////////////////////////////////////////// 
.................... //                                   KBD.C                                        // 
.................... //               FUNCIONES PARA ESCANEO DE UN TECLADO MATRICIAL                   // 
.................... //                         4X4 HEXADECIMAL, EN EL PORTB                           // 
.................... //       kbd_init()       Debe ser invocada antes que las otras funciones.         // 
.................... //       c=lcd_getc(c)    Si h sido presionada una tecla devuelve el caracter c    // 
.................... //                  y lo salva en el char c, sino se presiona una tecla       // 
.................... //                  retorna el valor /0, esta funcin puede invocarse         // 
.................... //                  frecuentemente para no perder teclas pulsadas.            // 
.................... //        NOTA: REQUIERE COLOCAR RESISTENCIAS (2.2K) EN LOS PINES DE COLUMNAS     // 
.................... //               PINES DE COLUMNAS DE RB0(COL0) A RB3(COL3))                   // 
.................... //               PINES DE FILAS DE RB4(ROW0)) A RB7(ROW3))                    //  
.................... //                  MODIF.: ING. FRANK GIRALDO - UD                       // 
.................... //////////////////////////////////////////////////////////////////////////////////// 
.................... /*//////////////////////////////////////////////////////////////////////////////////  
.................... *    RB0 RB1 RB2 RB3    
.................... *     |   |   |   | 
.................... *     c0  c1  c2  c3   
.................... *   | 1 | 2 | 3 | F | r0 - RB4 
.................... *   | 4 | 5 | 6 | E | r1 - RB5 
.................... *   | 7 | 8 | 9 | D | r2 - RB6 
.................... *   | A | 0 | B | C | r3 - RB7 
.................... * 
.................... *   COLUMNS=OUTs 
.................... *   ROWS=INs 
.................... *   SE HABILITAN PULL-UP INTERNAS  
.................... *   SE REQUIERE COLOCAR RESISTENCIAS (2.2K) EN LOS PINES DE COLUMNAS  
.................... * 
.................... */////////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... #byte portkbd = 0XF81                  //portkbd = portB 
.................... //Keypad connection:   (Column 0 es B0) 
.................... //                Bx: 
.................... #define COL0 (0 << 0) 
.................... #define COL1 (0 << 1) 
.................... #define COL2 (0 << 2) 
.................... #define COL3 (0 << 3) 
.................... #define ROW0 (1 << 4) 
.................... #define ROW1 (1 << 5) 
.................... #define ROW2 (1 << 6) 
.................... #define ROW3 (1 << 7) 
.................... #define ALL_ROWS (ROW3|ROW2|ROW1|ROW0) 
.................... #define ALL_PINS (ALL_ROWS|COL3|COL2|COL1|COL0) 
....................  
.................... char const KEYS[4][4] = {{'1','2','3','A'}, 
....................                          {'4','5','6','B'}, 
....................                          {'7','8','9','C'}, 
....................                          {'*','0','#','D'}}; 
....................  
.................... #define KBD_DEBOUNCE_FACTOR 0.2 
.................... // Modifique el valor de temporizacin antirrebote con (KBD_DEBOUNCE_FACTOR = n/333), 
.................... // en donde n es el nmero de veces por segundo en los que ud. invoca 
.................... //la funcin kbd_getc(). 
.................... // 
....................  
.................... void kbd_init(){ 
.................... } 
*
06C0:  GOTO   0DE0 (RETURN)
....................  
.................... char kbd_getc( ) 
.................... { 
....................    static BYTE kbd_call_count; 
....................    static short int kbd_down; 
....................    static char last_key; 
....................    static BYTE col; 
....................    BYTE kchar; 
....................    BYTE row; 
....................    port_b_pullups(TRUE); 
*
0A2C:  BCF    FF1.7
....................    kchar='\0'; 
0A2E:  CLRF   2C
....................  
....................    if(++kbd_call_count>KBD_DEBOUNCE_FACTOR) 
0A30:  INCF   0D,F
0A32:  CLRF   2F
0A34:  MOVFF  0D,2E
0A38:  BRA    097C
0A3A:  MOVLW  CD
0A3C:  MOVWF  31
0A3E:  MOVLW  CC
0A40:  MOVWF  30
0A42:  MOVLW  4C
0A44:  MOVWF  2F
0A46:  MOVLW  7C
0A48:  MOVWF  2E
0A4A:  MOVFF  03,35
0A4E:  MOVFF  02,34
0A52:  MOVFF  01,33
0A56:  MOVFF  00,32
0A5A:  BRA    09B4
0A5C:  BNC   0B14
....................    { 
....................        switch (col) 
....................        { 
0A5E:  MOVF   10,W
0A60:  ADDLW  FC
0A62:  BC    0A92
0A64:  ADDLW  04
0A66:  GOTO   0B22
....................          case 0   : set_tris_b(ALL_PINS&~COL0); 
0A6A:  MOVLW  F0
0A6C:  MOVWF  F93
....................                     portkbd=(0b1110); 
0A6E:  MOVLW  0E
0A70:  MOVWF  F81
....................                     break; 
0A72:  BRA    0A92
....................  
....................          case 1   : set_tris_b(ALL_PINS&~COL1); 
0A74:  MOVLW  F0
0A76:  MOVWF  F93
....................                     portkbd=(0b1101); 
0A78:  MOVLW  0D
0A7A:  MOVWF  F81
....................                     break; 
0A7C:  BRA    0A92
....................  
....................          case 2   : set_tris_b(ALL_PINS&~COL2); 
0A7E:  MOVLW  F0
0A80:  MOVWF  F93
....................                     portkbd=(0b1011); 
0A82:  MOVLW  0B
0A84:  MOVWF  F81
....................                     break; 
0A86:  BRA    0A92
....................  
....................          case 3   : set_tris_b(ALL_PINS&~COL3); 
0A88:  MOVLW  F0
0A8A:  MOVWF  F93
....................                     portkbd=(0b0111); 
0A8C:  MOVLW  07
0A8E:  MOVWF  F81
....................                     break; 
0A90:  BRA    0A92
....................        } 
....................  
....................        if(kbd_down) 
0A92:  BTFSS  0E.0
0A94:  BRA    0AA8
....................        { 
....................          if((portkbd & (ALL_ROWS))==(ALL_ROWS)) 
0A96:  MOVF   F81,W
0A98:  ANDLW  F0
0A9A:  SUBLW  F0
0A9C:  BNZ   0AA6
....................          { 
....................            kbd_down=FALSE; 
0A9E:  BCF    0E.0
....................            kchar=last_key; 
0AA0:  MOVFF  0F,2C
....................            last_key='\0'; 
0AA4:  CLRF   0F
....................          } 
....................        } 
....................        else 
0AA6:  BRA    0B12
....................        { 
....................           if((portkbd & (ALL_ROWS))!=(ALL_ROWS)) 
0AA8:  MOVF   F81,W
0AAA:  ANDLW  F0
0AAC:  SUBLW  F0
0AAE:  BZ    0B08
....................           { 
....................              if((portkbd & ROW0) == 0) 
0AB0:  MOVF   F81,W
0AB2:  ANDLW  10
0AB4:  BNZ   0ABA
....................                row = 0; 
0AB6:  CLRF   2D
....................              else if((portkbd & ROW1) == 0) 
0AB8:  BRA    0ADC
0ABA:  MOVF   F81,W
0ABC:  ANDLW  20
0ABE:  BNZ   0AC6
....................                row = 1; 
0AC0:  MOVLW  01
0AC2:  MOVWF  2D
....................              else if((portkbd & ROW2) == 0) 
0AC4:  BRA    0ADC
0AC6:  MOVF   F81,W
0AC8:  ANDLW  40
0ACA:  BNZ   0AD2
....................                row = 2; 
0ACC:  MOVLW  02
0ACE:  MOVWF  2D
....................              else if((portkbd & ROW3) == 0) 
0AD0:  BRA    0ADC
0AD2:  MOVF   F81,W
0AD4:  ANDLW  80
0AD6:  BNZ   0ADC
....................                row = 3; 
0AD8:  MOVLW  03
0ADA:  MOVWF  2D
....................              last_key = KEYS[row][col]; 
0ADC:  MOVF   2D,W
0ADE:  MULLW  04
0AE0:  MOVF   FF3,W
0AE2:  CLRF   2F
0AE4:  MOVWF  2E
0AE6:  CLRF   03
0AE8:  MOVF   10,W
0AEA:  ADDWF  2E,W
0AEC:  MOVWF  01
0AEE:  MOVF   2F,W
0AF0:  ADDWFC 03,F
0AF2:  MOVF   01,W
0AF4:  MOVFF  FF2,2E
0AF8:  BCF    FF2.7
0AFA:  CALL   0018
0AFE:  BTFSC  2E.7
0B00:  BSF    FF2.7
0B02:  MOVWF  0F
....................              kbd_down = TRUE; 
0B04:  BSF    0E.0
....................           } 
....................           else 
0B06:  BRA    0B12
....................           { 
....................              ++col; 
0B08:  INCF   10,F
....................              if(col==4) 
0B0A:  MOVF   10,W
0B0C:  SUBLW  04
0B0E:  BNZ   0B12
....................              col=0; 
0B10:  CLRF   10
....................           } 
....................        } 
....................       kbd_call_count=0; 
0B12:  CLRF   0D
....................    } 
....................   kchar = last_key; 
0B14:  MOVFF  0F,2C
....................   set_tris_b(ALL_PINS); 
0B18:  MOVLW  F0
0B1A:  MOVWF  F93
....................   return(kchar); 
0B1C:  MOVFF  2C,01
.................... } 
0B20:  RETLW  00
....................  
.................... /*char dato; 
.................... char tecla() 
.................... { 
....................    dato='\0'; 
....................    while(dato=='\0') 
....................    { 
....................       dato=kbd_getc(); 
....................       delay_ms(100); 
....................    } 
.................... return dato; 
.................... } */ 
....................  
.................... //#include <DS1307.c> 
.................... #include <24C512.c> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////   Library for a 24LC512 serial EEPROM                             //// 
.................... ////                                                                   //// 
.................... ////   init_ext_eeprom();    Call before the other functions are used  //// 
.................... ////                                                                   //// 
.................... ////   write_ext_eeprom(a, d);  Write the byte d to the address a      //// 
.................... ////                                                                   //// 
.................... ////   d = read_ext_eeprom(a);   Read the byte d from the address a    //// 
.................... ////                                                                   //// 
.................... ////   The main program may define eeprom_sda                          //// 
.................... ////   and eeprom_scl to override the defaults below.                  //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef EEPROM_SDA 
....................  
.................... #define EEPROM_SDA  PIN_A1 
.................... #define EEPROM_SCL  PIN_A0 
....................  
.................... #endif 
....................  
.................... #use i2c(master, sda=EEPROM_SDA, scl=EEPROM_SCL) 
*
07D0:  MOVLW  08
07D2:  MOVWF  01
07D4:  MOVLW  05
07D6:  MOVWF  00
07D8:  DECFSZ 00,F
07DA:  BRA    07D8
07DC:  BCF    F89.0
07DE:  BCF    F92.0
07E0:  MOVLW  06
07E2:  MOVWF  00
07E4:  DECFSZ 00,F
07E6:  BRA    07E4
07E8:  RLCF   33,F
07EA:  BCF    F89.1
07EC:  BTFSC  FD8.0
07EE:  BSF    F92.1
07F0:  BTFSS  FD8.0
07F2:  BCF    F92.1
07F4:  BSF    F92.0
07F6:  BTFSS  F80.0
07F8:  BRA    07F6
07FA:  DECFSZ 01,F
07FC:  BRA    07D4
07FE:  MOVLW  05
0800:  MOVWF  00
0802:  DECFSZ 00,F
0804:  BRA    0802
0806:  BCF    F89.0
0808:  BCF    F92.0
080A:  NOP   
080C:  BSF    F92.1
080E:  MOVLW  06
0810:  MOVWF  00
0812:  DECFSZ 00,F
0814:  BRA    0812
0816:  MOVLW  06
0818:  MOVWF  00
081A:  DECFSZ 00,F
081C:  BRA    081A
081E:  BSF    F92.0
0820:  BTFSS  F80.0
0822:  BRA    0820
0824:  CLRF   01
0826:  MOVLW  06
0828:  MOVWF  00
082A:  DECFSZ 00,F
082C:  BRA    082A
082E:  BTFSC  F80.1
0830:  BSF    01.0
0832:  BCF    F89.0
0834:  BCF    F92.0
0836:  BCF    F89.1
0838:  BCF    F92.1
083A:  RETLW  00
083C:  MOVLW  08
083E:  MOVWF  32
0840:  MOVFF  00,33
0844:  BSF    F92.1
0846:  MOVLW  06
0848:  MOVWF  00
084A:  DECFSZ 00,F
084C:  BRA    084A
084E:  BSF    F92.0
0850:  BTFSS  F80.0
0852:  BRA    0850
0854:  BTFSC  F80.1
0856:  BSF    FD8.0
0858:  BTFSS  F80.1
085A:  BCF    FD8.0
085C:  RLCF   01,F
085E:  MOVLW  05
0860:  MOVWF  00
0862:  DECFSZ 00,F
0864:  BRA    0862
0866:  BCF    F92.0
0868:  BCF    F89.0
086A:  DECFSZ 32,F
086C:  BRA    0844
086E:  BSF    F92.1
0870:  MOVLW  06
0872:  MOVWF  00
0874:  DECFSZ 00,F
0876:  BRA    0874
0878:  BCF    F89.1
087A:  MOVF   33,W
087C:  BTFSS  FD8.2
087E:  BCF    F92.1
0880:  NOP   
0882:  BSF    F92.0
0884:  BTFSS  F80.0
0886:  BRA    0884
0888:  MOVLW  05
088A:  MOVWF  00
088C:  DECFSZ 00,F
088E:  BRA    088C
0890:  BCF    F89.0
0892:  BCF    F92.0
0894:  MOVLW  06
0896:  MOVWF  00
0898:  DECFSZ 00,F
089A:  BRA    0898
089C:  BCF    F89.1
089E:  BCF    F92.1
08A0:  GOTO   0912 (RETURN)
....................  
.................... #define EEPROM_ADDRESS long int 
.................... #define EEPROM_SIZE   65535 
....................  
.................... void init_ext_eeprom() 
.................... { 
....................    output_float(EEPROM_SCL); 
....................    output_float(EEPROM_SDA); 
....................  
.................... } 
....................  
.................... void write_ext_eeprom(long int address, BYTE data) 
.................... { 
....................    short int status; 
....................    i2c_start(); 
....................    i2c_write(0xa0); 
....................    i2c_write(address>>8); 
....................    i2c_write(address); 
....................    i2c_write(data); 
....................    i2c_stop(); 
....................    i2c_start(); 
....................    status=i2c_write(0xa0); 
....................    while(status==1) 
....................    { 
....................       i2c_start(); 
....................       status=i2c_write(0xa0); 
....................    } 
....................    i2c_stop(); 
.................... } 
....................  
.................... BYTE read_ext_eeprom(long int address) { 
....................    BYTE data; 
....................    i2c_start(); 
08A4:  BSF    F92.1
08A6:  MOVLW  05
08A8:  MOVWF  00
08AA:  DECFSZ 00,F
08AC:  BRA    08AA
08AE:  BSF    F92.0
08B0:  MOVLW  06
08B2:  MOVWF  00
08B4:  DECFSZ 00,F
08B6:  BRA    08B4
08B8:  BCF    F89.1
08BA:  BCF    F92.1
08BC:  MOVLW  05
08BE:  MOVWF  00
08C0:  DECFSZ 00,F
08C2:  BRA    08C0
08C4:  BCF    F89.0
08C6:  BCF    F92.0
....................    i2c_write(0xa0); 
08C8:  MOVLW  A0
08CA:  MOVWF  33
08CC:  RCALL  07D0
....................    i2c_write(address>>8); 
08CE:  MOVFF  2F,31
08D2:  CLRF   32
08D4:  MOVFF  2F,33
08D8:  RCALL  07D0
....................    i2c_write(address); 
08DA:  MOVFF  2E,33
08DE:  RCALL  07D0
....................    i2c_start(); 
08E0:  BSF    F92.1
08E2:  MOVLW  05
08E4:  MOVWF  00
08E6:  DECFSZ 00,F
08E8:  BRA    08E6
08EA:  BSF    F92.0
08EC:  MOVLW  06
08EE:  MOVWF  00
08F0:  DECFSZ 00,F
08F2:  BRA    08F0
08F4:  BTFSS  F80.0
08F6:  BRA    08F4
08F8:  BCF    F89.1
08FA:  BCF    F92.1
08FC:  MOVLW  05
08FE:  MOVWF  00
0900:  DECFSZ 00,F
0902:  BRA    0900
0904:  BCF    F89.0
0906:  BCF    F92.0
....................    i2c_write(0xa1); 
0908:  MOVLW  A1
090A:  MOVWF  33
090C:  RCALL  07D0
....................    data=i2c_read(0); 
090E:  CLRF   00
0910:  BRA    083C
0912:  MOVFF  01,30
....................    i2c_stop(); 
0916:  BCF    F92.1
0918:  NOP   
091A:  BSF    F92.0
091C:  BTFSS  F80.0
091E:  BRA    091C
0920:  MOVLW  05
0922:  MOVWF  00
0924:  DECFSZ 00,F
0926:  BRA    0924
0928:  BRA    092A
092A:  NOP   
092C:  BSF    F92.1
092E:  MOVLW  05
0930:  MOVWF  00
0932:  DECFSZ 00,F
0934:  BRA    0932
....................    return(data); 
0936:  MOVFF  30,01
.................... } 
093A:  GOTO   0962 (RETURN)
....................  
.................... #ROM     0xf00000={0x4523}     //colocar 0 para usuario 1, estan al reves primero esta los dos digitos ultimos y luego los otros 
.................... #ROM     0xf00002={0x5634}     //esto es asignacion de claves para los usuarios 
....................  
.................... int i, b, dato, clave[4], datoi[4], datoe[4], adres,  dato1, dato2; 
.................... char datom; 
.................... float valor; 
.................... short flag; 
.................... long segundos, auxsegundos; 
....................  
.................... void teclado() 
.................... {  
....................      lcd_putc('\f'); 
*
0B44:  MOVLW  0C
0B46:  MOVWF  2D
0B48:  RCALL  0720
....................     segundos=0; 
0B4A:  CLRF   29
0B4C:  CLRF   28
....................     auxsegundos=0; 
0B4E:  CLRF   2B
0B50:  CLRF   2A
....................     b=6; 
0B52:  MOVLW  06
0B54:  MOVWF  12
....................      for(i=0;i<4; i++) 
0B56:  CLRF   11
0B58:  MOVF   11,W
0B5A:  SUBLW  03
0B5C:  BTFSS  FD8.0
0B5E:  BRA    0CBE
....................       { 
....................         do{ 
....................             datom=kbd_getc(); // escanea teclado 
0B60:  RCALL  0A2C
0B62:  MOVFF  01,23
....................             delay_ms(60); 
0B66:  MOVLW  3C
0B68:  MOVWF  2E
0B6A:  RCALL  05B8
....................              if(datom!='\0')  //si hay dato valido 
0B6C:  MOVF   23,F
0B6E:  BTFSC  FD8.2
0B70:  BRA    0C62
....................               { 
....................                  switch (i+1) 
....................                   { 
0B72:  MOVLW  01
0B74:  ADDWF  11,W
0B76:  ADDLW  FF
0B78:  ADDLW  FC
0B7A:  BTFSC  FD8.0
0B7C:  BRA    0C4A
0B7E:  ADDLW  04
0B80:  GOTO   0CC0
....................                    case 1: 
....................                    lcd_gotoxy(6,2); 
0B84:  MOVLW  06
0B86:  MOVWF  2E
0B88:  MOVLW  02
0B8A:  MOVWF  2F
0B8C:  RCALL  06C4
....................                    lcd_putc(datom); 
0B8E:  MOVFF  23,2D
0B92:  RCALL  0720
....................                    //printf(lcd_putc,datom); 
....................                    clave[0]=datom-0X30; 
0B94:  MOVLW  30
0B96:  SUBWF  23,W
0B98:  MOVWF  14
....................                    swap(clave[0]); 
0B9A:  SWAPF  14,F
....................                    lcd_gotoxy(6,1); 
0B9C:  MOVLW  06
0B9E:  MOVWF  2E
0BA0:  MOVLW  01
0BA2:  MOVWF  2F
0BA4:  RCALL  06C4
....................                    printf(lcd_putc,"*"); 
0BA6:  MOVLW  2A
0BA8:  MOVWF  2D
0BAA:  RCALL  0720
....................                    delay_ms(50); 
0BAC:  MOVLW  32
0BAE:  MOVWF  2E
0BB0:  RCALL  05B8
....................                    break; 
0BB2:  BRA    0C4A
....................            
....................                    case 2: 
....................                     lcd_gotoxy(7,2); 
0BB4:  MOVLW  07
0BB6:  MOVWF  2E
0BB8:  MOVLW  02
0BBA:  MOVWF  2F
0BBC:  RCALL  06C4
....................                    lcd_putc(datom); 
0BBE:  MOVFF  23,2D
0BC2:  RCALL  0720
....................                   // printf(lcd_putc,datom); 
....................                    clave[1]=datom-0X30; 
0BC4:  MOVLW  30
0BC6:  SUBWF  23,W
0BC8:  MOVWF  15
....................                    clave[0]=clave[0]+clave[1]; 
0BCA:  MOVF   15,W
0BCC:  ADDWF  14,F
....................                    lcd_gotoxy(7,1); 
0BCE:  MOVLW  07
0BD0:  MOVWF  2E
0BD2:  MOVLW  01
0BD4:  MOVWF  2F
0BD6:  RCALL  06C4
....................                    printf(lcd_putc,"*"); 
0BD8:  MOVLW  2A
0BDA:  MOVWF  2D
0BDC:  RCALL  0720
....................                    delay_ms(50); 
0BDE:  MOVLW  32
0BE0:  MOVWF  2E
0BE2:  RCALL  05B8
....................                    break; 
0BE4:  BRA    0C4A
....................               
....................                    case 3: 
....................                    lcd_gotoxy(8,2); 
0BE6:  MOVLW  08
0BE8:  MOVWF  2E
0BEA:  MOVLW  02
0BEC:  MOVWF  2F
0BEE:  RCALL  06C4
....................                    lcd_putc(datom); 
0BF0:  MOVFF  23,2D
0BF4:  RCALL  0720
....................                    //printf(lcd_putc,datom); 
....................                    clave[2]=datom-0X30; 
0BF6:  MOVLW  30
0BF8:  SUBWF  23,W
0BFA:  MOVWF  16
....................                    swap(clave[2]); 
0BFC:  SWAPF  16,F
....................                    lcd_gotoxy(8,1); 
0BFE:  MOVLW  08
0C00:  MOVWF  2E
0C02:  MOVLW  01
0C04:  MOVWF  2F
0C06:  RCALL  06C4
....................                    printf(lcd_putc,"*"); 
0C08:  MOVLW  2A
0C0A:  MOVWF  2D
0C0C:  RCALL  0720
....................                    delay_ms(50); 
0C0E:  MOVLW  32
0C10:  MOVWF  2E
0C12:  RCALL  05B8
....................                    break; 
0C14:  BRA    0C4A
....................               
....................                    case 4: 
....................                    lcd_gotoxy(9,2); 
0C16:  MOVLW  09
0C18:  MOVWF  2E
0C1A:  MOVLW  02
0C1C:  MOVWF  2F
0C1E:  RCALL  06C4
....................                    lcd_putc(datom); 
0C20:  MOVFF  23,2D
0C24:  RCALL  0720
....................                   // printf(lcd_putc,datom); 
....................                    clave[3]=datom-0X30; 
0C26:  MOVLW  30
0C28:  SUBWF  23,W
0C2A:  MOVWF  17
....................                    clave[1]=clave[2]+clave[3]; 
0C2C:  MOVF   17,W
0C2E:  ADDWF  16,W
0C30:  MOVWF  15
....................                    lcd_gotoxy(9,1); 
0C32:  MOVLW  09
0C34:  MOVWF  2E
0C36:  MOVLW  01
0C38:  MOVWF  2F
0C3A:  RCALL  06C4
....................                    printf(lcd_putc,"*"); 
0C3C:  MOVLW  2A
0C3E:  MOVWF  2D
0C40:  RCALL  0720
....................                    delay_ms(50); 
0C42:  MOVLW  32
0C44:  MOVWF  2E
0C46:  RCALL  05B8
....................                    break; 
0C48:  BRA    0C4A
....................                  }  
....................                   i++; 
0C4A:  INCF   11,F
....................                   delay_ms(500); 
0C4C:  MOVLW  02
0C4E:  MOVWF  2C
0C50:  MOVLW  FA
0C52:  MOVWF  2E
0C54:  RCALL  05B8
0C56:  DECFSZ 2C,F
0C58:  BRA    0C50
....................                   auxsegundos=0; 
0C5A:  CLRF   2B
0C5C:  CLRF   2A
....................                   segundos=0; 
0C5E:  CLRF   29
0C60:  CLRF   28
....................            } 
....................            auxsegundos++; 
0C62:  INCF   2A,F
0C64:  BTFSC  FD8.2
0C66:  INCF   2B,F
....................            if(auxsegundos > 20) 
0C68:  MOVF   2B,F
0C6A:  BNZ   0C72
0C6C:  MOVF   2A,W
0C6E:  SUBLW  14
0C70:  BC    0C7C
....................             { 
....................               segundos++; 
0C72:  INCF   28,F
0C74:  BTFSC  FD8.2
0C76:  INCF   29,F
....................               auxsegundos=0; 
0C78:  CLRF   2B
0C7A:  CLRF   2A
....................             } 
....................          
....................       
....................     
....................     }while(i<4 && segundos<6); 
0C7C:  MOVF   11,W
0C7E:  SUBLW  03
0C80:  BNC   0C8E
0C82:  MOVF   29,F
0C84:  BNZ   0C8E
0C86:  MOVF   28,W
0C88:  SUBLW  05
0C8A:  BTFSC  FD8.0
0C8C:  BRA    0B60
....................       clave[i]='#'; 
0C8E:  CLRF   03
0C90:  MOVF   11,W
0C92:  ADDLW  14
0C94:  MOVWF  FE9
0C96:  MOVLW  00
0C98:  ADDWFC 03,W
0C9A:  MOVWF  FEA
0C9C:  MOVLW  23
0C9E:  MOVWF  FEF
....................       lcd_gotoxy(b,1); 
0CA0:  MOVFF  12,2E
0CA4:  MOVLW  01
0CA6:  MOVWF  2F
0CA8:  RCALL  06C4
....................       printf(lcd_putc,"*") ; 
0CAA:  MOVLW  2A
0CAC:  MOVWF  2D
0CAE:  RCALL  0720
....................       b++; 
0CB0:  INCF   12,F
....................       auxsegundos=0; 
0CB2:  CLRF   2B
0CB4:  CLRF   2A
....................       segundos=0; 
0CB6:  CLRF   29
0CB8:  CLRF   28
....................    } 
0CBA:  INCF   11,F
0CBC:  BRA    0B58
.................... } 
0CBE:  RETLW  00
....................  
....................  
.................... void un_digito() 
.................... { lcd_putc('\f'); 
*
0CE2:  MOVLW  0C
0CE4:  MOVWF  2D
0CE6:  RCALL  0720
....................   segundos=0; 
0CE8:  CLRF   29
0CEA:  CLRF   28
....................   auxsegundos=0; 
0CEC:  CLRF   2B
0CEE:  CLRF   2A
....................   flag=false; 
0CF0:  BCF    0E.1
....................   do{ 
....................       datom=kbd_getc(); 
0CF2:  RCALL  0A2C
0CF4:  MOVFF  01,23
....................       delay_ms(60); 
0CF8:  MOVLW  3C
0CFA:  MOVWF  2E
0CFC:  RCALL  05B8
....................       if(datom !='\0') 
0CFE:  MOVF   23,F
0D00:  BZ    0D1A
....................         { 
....................           lcd_gotoxy(8,1);  //coloque el numero digitado  en posicion del LCD 
0D02:  MOVLW  08
0D04:  MOVWF  2E
0D06:  MOVLW  01
0D08:  MOVWF  2F
0D0A:  RCALL  06C4
....................           lcd_putc(datom); //visualice datom 
0D0C:  MOVFF  23,2D
0D10:  RCALL  0720
....................           datom=datom-0x30; //quitele ASCII 
0D12:  MOVLW  30
0D14:  SUBWF  23,F
....................           flag=true; 
0D16:  BSF    0E.1
....................            
....................         }else { 
0D18:  BRA    0D34
....................                auxsegundos++; 
0D1A:  INCF   2A,F
0D1C:  BTFSC  FD8.2
0D1E:  INCF   2B,F
....................                if(auxsegundos>20) 
0D20:  MOVF   2B,F
0D22:  BNZ   0D2A
0D24:  MOVF   2A,W
0D26:  SUBLW  14
0D28:  BC    0D34
....................                { 
....................                  segundos++; 
0D2A:  INCF   28,F
0D2C:  BTFSC  FD8.2
0D2E:  INCF   29,F
....................                  auxsegundos=0; 
0D30:  CLRF   2B
0D32:  CLRF   2A
....................                 } 
....................        } 
....................          
....................   }while(segundos<6 && flag==false ); 
0D34:  MOVF   29,F
0D36:  BNZ   0D42
0D38:  MOVF   28,W
0D3A:  SUBLW  05
0D3C:  BNC   0D42
0D3E:  BTFSS  0E.1
0D40:  BRA    0CF2
.................... } 
0D42:  RETLW  00
....................  
.................... void escribir_memoria() 
.................... { 
....................   for(i=0; i<2; i++) 
0D44:  CLRF   11
0D46:  MOVF   11,W
0D48:  SUBLW  01
0D4A:  BNC   0D96
....................   {  write_eeprom(adres, clave[i]); 
0D4C:  CLRF   03
0D4E:  MOVF   11,W
0D50:  ADDLW  14
0D52:  MOVWF  FE9
0D54:  MOVLW  00
0D56:  ADDWFC 03,W
0D58:  MOVWF  FEA
0D5A:  MOVFF  FEF,2C
0D5E:  MOVFF  20,FA9
0D62:  MOVFF  2C,FA8
0D66:  BCF    FA6.6
0D68:  BCF    FA6.7
0D6A:  BSF    FA6.2
0D6C:  MOVFF  FF2,00
0D70:  BCF    FF2.7
0D72:  MOVLB  F
0D74:  MOVLW  55
0D76:  MOVWF  FA7
0D78:  MOVLW  AA
0D7A:  MOVWF  FA7
0D7C:  BSF    FA6.1
0D7E:  BTFSC  FA6.1
0D80:  BRA    0D7E
0D82:  BCF    FA6.2
0D84:  MOVF   00,W
0D86:  IORWF  FF2,F
....................      delay_ms(5); 
0D88:  MOVLW  05
0D8A:  MOVWF  2E
0D8C:  MOVLB  0
0D8E:  RCALL  05B8
....................      adres++; 
0D90:  INCF   20,F
....................   } 
0D92:  INCF   11,F
0D94:  BRA    0D46
.................... } 
0D96:  RETLW  00
....................  
.................... void escribir_memoria_ext() 
.................... { 
....................   for(i=0; i<2; i++) 
....................   {  write_ext_eeprom(adres, clave[i]); 
....................      delay_ms(5); 
....................      adres++; 
....................   } 
.................... } 
....................  
....................  
.................... void leer() 
.................... { 
....................   for(i=0; i<4; i++) 
*
0794:  CLRF   11
0796:  MOVF   11,W
0798:  SUBLW  03
079A:  BNC   07CC
....................   { 
....................     datoi[i]=read_eeprom(i); 
079C:  CLRF   03
079E:  MOVF   11,W
07A0:  ADDLW  18
07A2:  MOVWF  FE9
07A4:  MOVLW  00
07A6:  ADDWFC 03,W
07A8:  MOVWF  FEA
07AA:  MOVFF  FF2,2E
07AE:  BCF    FF2.7
07B0:  MOVFF  11,FA9
07B4:  BCF    FA6.6
07B6:  BCF    FA6.7
07B8:  BSF    FA6.0
07BA:  MOVF   FA8,W
07BC:  BTFSC  2E.7
07BE:  BSF    FF2.7
07C0:  MOVWF  FEF
....................     delay_ms(1); 
07C2:  MOVLW  01
07C4:  MOVWF  2E
07C6:  RCALL  05B8
....................   } 
07C8:  INCF   11,F
07CA:  BRA    0796
.................... } 
07CC:  GOTO   0E8A (RETURN)
....................  
....................  
.................... void leer_men_ext() 
.................... { 
....................   for(i=0; i<4; i++) 
*
093E:  CLRF   11
0940:  MOVF   11,W
0942:  SUBLW  03
0944:  BNC   0978
....................   { 
....................     datoe[i]=read_ext_eeprom(i); 
0946:  CLRF   03
0948:  MOVF   11,W
094A:  ADDLW  1C
094C:  MOVWF  01
094E:  MOVLW  00
0950:  ADDWFC 03,F
0952:  MOVFF  01,2C
0956:  MOVFF  03,2D
095A:  CLRF   2F
095C:  MOVFF  11,2E
0960:  BRA    08A4
0962:  MOVFF  2D,FEA
0966:  MOVFF  2C,FE9
096A:  MOVFF  01,FEF
....................     delay_ms(1); 
096E:  MOVLW  01
0970:  MOVWF  2E
0972:  RCALL  05B8
....................    } 
0974:  INCF   11,F
0976:  BRA    0940
.................... } 
0978:  GOTO   0E8C (RETURN)
....................  
....................     
....................     
....................     
.................... /******************** 
.................... Programa Principal 
.................... ********************/ 
....................  
.................... void main() 
.................... { 
*
0D98:  CLRF   FF8
0D9A:  BCF    FD0.7
0D9C:  MOVLW  FE
0D9E:  MOVWF  00
0DA0:  MOVLW  08
0DA2:  MOVWF  01
0DA4:  MOVLW  02
0DA6:  MOVWF  FE9
0DA8:  MOVLW  00
0DAA:  MOVWF  FEA
0DAC:  CLRF   FEE
0DAE:  DECFSZ 00,F
0DB0:  BRA    0DAC
0DB2:  DECFSZ 01,F
0DB4:  BRA    0DAC
0DB6:  CLRF   FEA
0DB8:  CLRF   FE9
0DBA:  MOVF   FC1,W
0DBC:  ANDLW  C0
0DBE:  IORLW  0F
0DC0:  MOVWF  FC1
0DC2:  MOVLW  07
0DC4:  MOVWF  FB4
0DC6:  CLRF   05
0DC8:  CLRF   06
0DCA:  CLRF   0D
0DCC:  BCF    0E.0
0DCE:  CLRF   0F
0DD0:  CLRF   10
.................... inicio: 
....................    #zero_ram 
....................     set_tris_A(0x28);         /*0010 1000 EL 28 SALE ES DIVIDIENDO LOS 8BITS EN 4 DIGITOS Y TOMAR A QUE NUMERO CORRESPONCEN 
0DD2:  MOVLW  28
0DD4:  MOVWF  F92
....................     RA0 PIN 2  FREE 
....................     RA1 PIN 3  FREE 
....................     RA2 PIN 4  FREE 
....................     RA3 PIN 5  FREE 
....................     RA4 PIN 6  FREE 
....................     RA5 PIN 7  FREE 
....................     RA6 PIN 14 FREE 
....................     RA7 NO EXISTE */ 
....................      
....................     set_tris_B(0x00); /*0000 0000 EL 28 SALE ES DIVIDIENDO LOS 8BITS EN 4 DIGITOS Y TOMAR A QUE NUMERO CORRESPONCEN 
0DD6:  MOVLW  00
0DD8:  MOVWF  F93
....................     RB0 PIN 33  LED1 
....................     RB1 PIN 34  LED2 
....................     RB2 PIN 35  LED4 
....................     RB3 PIN 36  LED5 
....................     RB4 PIN 37  LED6 
....................     RB5 PIN 38  LED7 
....................     RB6 PIN 39  LED8 
....................     RB7 PIN 40  LED8 */ 
....................      
....................     set_tris_D(0x00); /*0000 0000 EL 28 SALE ES DIVIDIENDO LOS 8BITS EN 4 DIGITOS Y TOMAR A QUE NUMERO CORRESPONCEN 
0DDA:  MOVWF  F95
....................     RB0 PIN 33  LED1 
....................     RB1 PIN 34  LED2 
....................     RB2 PIN 35  LED4 
....................     RB3 PIN 36  LED5 
....................     RB4 PIN 37  LED6 
....................     RB5 PIN 38  LED7 
....................     RB6 PIN 39  LED8 
....................     RB7 PIN 40  LED8 */ 
....................      
....................     lcd_init(); 
0DDC:  BRA    0660
....................     kbd_init(); 
0DDE:  BRA    06C0
....................     output_A(0x00);                            //Limpiar el puerto A 
0DE0:  CLRF   F92
0DE2:  CLRF   F89
....................     output_B(0x00);                           //Limipiar el puerto B 
0DE4:  CLRF   F93
0DE6:  CLRF   F8A
....................     output_D(0x00);                           //Limipiar el puerto D 
0DE8:  CLRF   F95
0DEA:  CLRF   F8C
....................  
.................... menu: 
....................    lcd_putc('\f');   //Limpiar pantalla 
0DEC:  MOVLW  0C
0DEE:  MOVWF  2D
0DF0:  RCALL  0720
....................    lcd_gotoxy(1,1); 
0DF2:  MOVLW  01
0DF4:  MOVWF  2E
0DF6:  MOVWF  2F
0DF8:  RCALL  06C4
....................    lcd_putc("  BIENVENIDOS"); 
0DFA:  CLRF   2C
0DFC:  MOVF   2C,W
0DFE:  CALL   0038
0E02:  IORLW  00
0E04:  BZ    0E0E
0E06:  INCF   2C,F
0E08:  MOVWF  2D
0E0A:  RCALL  0720
0E0C:  BRA    0DFC
....................    lcd_gotoxy(1,2); 
0E0E:  MOVLW  01
0E10:  MOVWF  2E
0E12:  MOVLW  02
0E14:  MOVWF  2F
0E16:  RCALL  06C4
....................    lcd_putc("ARQ. COMP. NOCHE"); 
0E18:  CLRF   2C
0E1A:  MOVF   2C,W
0E1C:  CALL   0056
0E20:  IORLW  00
0E22:  BZ    0E2C
0E24:  INCF   2C,F
0E26:  MOVWF  2D
0E28:  RCALL  0720
0E2A:  BRA    0E1A
....................    delay_ms(3000); 
0E2C:  MOVLW  0C
0E2E:  MOVWF  2C
0E30:  MOVLW  FA
0E32:  MOVWF  2E
0E34:  CALL   05B8
0E38:  DECFSZ 2C,F
0E3A:  BRA    0E30
....................     
....................    printf(lcd_putc,"\f CAMILO PINLLA\n VERONICA FORERO"); 
0E3C:  CLRF   2C
0E3E:  MOVF   2C,W
0E40:  CALL   0078
0E44:  INCF   2C,F
0E46:  MOVWF  00
0E48:  MOVWF  2D
0E4A:  RCALL  0720
0E4C:  MOVLW  20
0E4E:  SUBWF  2C,W
0E50:  BNZ   0E3E
....................    delay_ms(3000); 
0E52:  MOVLW  0C
0E54:  MOVWF  2C
0E56:  MOVLW  FA
0E58:  MOVWF  2E
0E5A:  CALL   05B8
0E5E:  DECFSZ 2C,F
0E60:  BRA    0E56
....................     
....................    printf(lcd_putc,"\f    POR FAVOR\n  DIGITE CLAVE"); 
0E62:  CLRF   2C
0E64:  MOVF   2C,W
0E66:  CALL   00AA
0E6A:  INCF   2C,F
0E6C:  MOVWF  00
0E6E:  MOVWF  2D
0E70:  RCALL  0720
0E72:  MOVLW  1D
0E74:  SUBWF  2C,W
0E76:  BNZ   0E64
....................    delay_ms(3000); 
0E78:  MOVLW  0C
0E7A:  MOVWF  2C
0E7C:  MOVLW  FA
0E7E:  MOVWF  2E
0E80:  CALL   05B8
0E84:  DECFSZ 2C,F
0E86:  BRA    0E7C
....................     
....................     
....................    leer();                                    //datoi[0]= clave que le demos datoi[1]=clave que le demos 
0E88:  BRA    0794
....................    leer_men_ext(); 
0E8A:  BRA    093E
....................    teclado();  
0E8C:  RCALL  0B44
....................    if(clave[0]==0x15 &  clave[1]==0x52) 
0E8E:  MOVF   14,W
0E90:  SUBLW  15
0E92:  BZ    0E98
0E94:  MOVLW  00
0E96:  BRA    0E9A
0E98:  MOVLW  01
0E9A:  MOVWF  2C
0E9C:  MOVF   15,W
0E9E:  SUBLW  52
0EA0:  BZ    0EA6
0EA2:  MOVLW  00
0EA4:  BRA    0EA8
0EA6:  MOVLW  01
0EA8:  ANDWF  2C,W
0EAA:  BTFSC  FD8.2
0EAC:  BRA    0F94
....................    {admin: 
....................       printf(lcd_putc,"\f BIENV. AL MENU\n DEL DISENADOR"); 
0EAE:  CLRF   2C
0EB0:  MOVF   2C,W
0EB2:  CALL   00D8
0EB6:  INCF   2C,F
0EB8:  MOVWF  00
0EBA:  MOVWF  2D
0EBC:  RCALL  0720
0EBE:  MOVLW  1F
0EC0:  SUBWF  2C,W
0EC2:  BNZ   0EB0
....................       delay_ms(3000); 
0EC4:  MOVLW  0C
0EC6:  MOVWF  2C
0EC8:  MOVLW  FA
0ECA:  MOVWF  2E
0ECC:  CALL   05B8
0ED0:  DECFSZ 2C,F
0ED2:  BRA    0EC8
....................       printf(lcd_putc,"\f MARQUE 1 PARA:\n MENU DE CAMILO"); 
0ED4:  CLRF   2C
0ED6:  MOVF   2C,W
0ED8:  CALL   0108
0EDC:  INCF   2C,F
0EDE:  MOVWF  00
0EE0:  MOVWF  2D
0EE2:  RCALL  0720
0EE4:  MOVLW  20
0EE6:  SUBWF  2C,W
0EE8:  BNZ   0ED6
....................       delay_ms(3000);  
0EEA:  MOVLW  0C
0EEC:  MOVWF  2C
0EEE:  MOVLW  FA
0EF0:  MOVWF  2E
0EF2:  CALL   05B8
0EF6:  DECFSZ 2C,F
0EF8:  BRA    0EEE
....................       printf(lcd_putc,"\f MARQUE 2 PARA:\n MENU VERONICA"); 
0EFA:  CLRF   2C
0EFC:  MOVF   2C,W
0EFE:  CALL   013A
0F02:  INCF   2C,F
0F04:  MOVWF  00
0F06:  MOVWF  2D
0F08:  RCALL  0720
0F0A:  MOVLW  1F
0F0C:  SUBWF  2C,W
0F0E:  BNZ   0EFC
....................       delay_ms(3000);   
0F10:  MOVLW  0C
0F12:  MOVWF  2C
0F14:  MOVLW  FA
0F16:  MOVWF  2E
0F18:  CALL   05B8
0F1C:  DECFSZ 2C,F
0F1E:  BRA    0F14
....................       printf(lcd_putc,"\f MARQUE 3 PARA:\n SALIR"); 
0F20:  CLRF   2C
0F22:  MOVF   2C,W
0F24:  CALL   016A
0F28:  INCF   2C,F
0F2A:  MOVWF  00
0F2C:  MOVWF  2D
0F2E:  CALL   0720
0F32:  MOVLW  17
0F34:  SUBWF  2C,W
0F36:  BNZ   0F22
....................       delay_ms(3000);   
0F38:  MOVLW  0C
0F3A:  MOVWF  2C
0F3C:  MOVLW  FA
0F3E:  MOVWF  2E
0F40:  CALL   05B8
0F44:  DECFSZ 2C,F
0F46:  BRA    0F3C
....................        
....................       un_digito();  //datom 
0F48:  RCALL  0CE2
....................        
....................       if(datom==0x01) 
0F4A:  DECFSZ 23,W
0F4C:  BRA    0F52
....................       { 
....................          //Leer_MemoriaInt(); 
....................          goto  camilo; 
0F4E:  BRA    0FB4
....................       } 
....................        
....................      else if(datom==0x02) 
0F50:  BRA    0F90
0F52:  MOVF   23,W
0F54:  SUBLW  02
0F56:  BNZ   0F5C
....................       { 
....................          goto  vero; 
0F58:  BRA    15EA
....................       } 
....................        
....................      else if(datom==0x03) 
0F5A:  BRA    0F90
0F5C:  MOVF   23,W
0F5E:  SUBLW  03
0F60:  BNZ   0F66
....................       { 
....................          reset_cpu(); 
0F62:  RESET
....................       }else{ 
0F64:  BRA    0F90
....................        
....................              printf(lcd_putc,"\f ERROR DE NUMERO:\n  "); 
0F66:  CLRF   2C
0F68:  MOVF   2C,W
0F6A:  CALL   0192
0F6E:  INCF   2C,F
0F70:  MOVWF  00
0F72:  MOVWF  2D
0F74:  CALL   0720
0F78:  MOVLW  15
0F7A:  SUBWF  2C,W
0F7C:  BNZ   0F68
....................              delay_ms(3000); 
0F7E:  MOVLW  0C
0F80:  MOVWF  2C
0F82:  MOVLW  FA
0F84:  MOVWF  2E
0F86:  CALL   05B8
0F8A:  DECFSZ 2C,F
0F8C:  BRA    0F82
....................              goto  admin;} 
0F8E:  BRA    0EAE
....................    } 
....................     
....................   else  if(clave[0]==datoi[1] &  clave[1]==datoi[0]) 
0F90:  GOTO   1C4C
0F94:  MOVF   19,W
0F96:  SUBWF  14,W
0F98:  BZ    0F9E
0F9A:  MOVLW  00
0F9C:  BRA    0FA0
0F9E:  MOVLW  01
0FA0:  MOVWF  2C
0FA2:  MOVF   18,W
0FA4:  SUBWF  15,W
0FA6:  BZ    0FAC
0FA8:  MOVLW  00
0FAA:  BRA    0FAE
0FAC:  MOVLW  01
0FAE:  ANDWF  2C,W
0FB0:  BTFSC  FD8.2
0FB2:  BRA    15CA
....................    { 
.................... camilo: adres=0x00; 
0FB4:  CLRF   20
....................       printf(lcd_putc,"\f BIENV. AL MENU\n DE CAMILO"); 
0FB6:  CLRF   2C
0FB8:  MOVF   2C,W
0FBA:  CALL   01B8
0FBE:  INCF   2C,F
0FC0:  MOVWF  00
0FC2:  MOVWF  2D
0FC4:  CALL   0720
0FC8:  MOVLW  1B
0FCA:  SUBWF  2C,W
0FCC:  BNZ   0FB8
....................       delay_ms(3000); 
0FCE:  MOVLW  0C
0FD0:  MOVWF  2C
0FD2:  MOVLW  FA
0FD4:  MOVWF  2E
0FD6:  CALL   05B8
0FDA:  DECFSZ 2C,F
0FDC:  BRA    0FD2
....................       printf(lcd_putc,"\f MARQUE 1 PARA \n CAMBIAR CLAVE"); 
0FDE:  CLRF   2C
0FE0:  MOVF   2C,W
0FE2:  CALL   01E4
0FE6:  INCF   2C,F
0FE8:  MOVWF  00
0FEA:  MOVWF  2D
0FEC:  CALL   0720
0FF0:  MOVLW  1F
0FF2:  SUBWF  2C,W
0FF4:  BNZ   0FE0
....................       delay_ms(3000); 
0FF6:  MOVLW  0C
0FF8:  MOVWF  2C
0FFA:  MOVLW  FA
0FFC:  MOVWF  2E
0FFE:  CALL   05B8
1002:  DECFSZ 2C,F
1004:  BRA    0FFA
....................       printf(lcd_putc,"\f MARQUE 2 PARA \n FECHA Y HORA"); 
1006:  CLRF   2C
1008:  MOVF   2C,W
100A:  CALL   0214
100E:  INCF   2C,F
1010:  MOVWF  00
1012:  MOVWF  2D
1014:  CALL   0720
1018:  MOVLW  1E
101A:  SUBWF  2C,W
101C:  BNZ   1008
....................       delay_ms(3000); 
101E:  MOVLW  0C
1020:  MOVWF  2C
1022:  MOVLW  FA
1024:  MOVWF  2E
1026:  CALL   05B8
102A:  DECFSZ 2C,F
102C:  BRA    1022
....................       printf(lcd_putc,"\f MARQUE 3 PARA \n REPORTES"); 
102E:  CLRF   2C
1030:  MOVF   2C,W
1032:  CALL   0244
1036:  INCF   2C,F
1038:  MOVWF  00
103A:  MOVWF  2D
103C:  CALL   0720
1040:  MOVLW  1A
1042:  SUBWF  2C,W
1044:  BNZ   1030
....................       delay_ms(3000); 
1046:  MOVLW  0C
1048:  MOVWF  2C
104A:  MOVLW  FA
104C:  MOVWF  2E
104E:  CALL   05B8
1052:  DECFSZ 2C,F
1054:  BRA    104A
....................       printf(lcd_putc,"\f MARQUE 4 PARA \n MTR PASO A PASO"); 
1056:  CLRF   2C
1058:  MOVF   2C,W
105A:  CALL   0270
105E:  INCF   2C,F
1060:  MOVWF  00
1062:  MOVWF  2D
1064:  CALL   0720
1068:  MOVLW  21
106A:  SUBWF  2C,W
106C:  BNZ   1058
....................       delay_ms(3000); 
106E:  MOVLW  0C
1070:  MOVWF  2C
1072:  MOVLW  FA
1074:  MOVWF  2E
1076:  CALL   05B8
107A:  DECFSZ 2C,F
107C:  BRA    1072
....................       printf(lcd_putc,"\f MARQUE 5 PARA \n SERVOMOTOR"); 
107E:  CLRF   2C
1080:  MOVF   2C,W
1082:  CALL   02A2
1086:  INCF   2C,F
1088:  MOVWF  00
108A:  MOVWF  2D
108C:  CALL   0720
1090:  MOVLW  1C
1092:  SUBWF  2C,W
1094:  BNZ   1080
....................       delay_ms(3000); 
1096:  MOVLW  0C
1098:  MOVWF  2C
109A:  MOVLW  FA
109C:  MOVWF  2E
109E:  CALL   05B8
10A2:  DECFSZ 2C,F
10A4:  BRA    109A
....................       printf(lcd_putc,"\f MARQUE 6 PARA \n CAD"); 
10A6:  CLRF   2C
10A8:  MOVF   2C,W
10AA:  CALL   02D0
10AE:  INCF   2C,F
10B0:  MOVWF  00
10B2:  MOVWF  2D
10B4:  CALL   0720
10B8:  MOVLW  15
10BA:  SUBWF  2C,W
10BC:  BNZ   10A8
....................       delay_ms(3000); 
10BE:  MOVLW  0C
10C0:  MOVWF  2C
10C2:  MOVLW  FA
10C4:  MOVWF  2E
10C6:  CALL   05B8
10CA:  DECFSZ 2C,F
10CC:  BRA    10C2
....................       printf(lcd_putc,"\f MARQUE 7 PARA \n DTFM"); 
10CE:  CLRF   2C
10D0:  MOVF   2C,W
10D2:  CALL   02F6
10D6:  INCF   2C,F
10D8:  MOVWF  00
10DA:  MOVWF  2D
10DC:  CALL   0720
10E0:  MOVLW  16
10E2:  SUBWF  2C,W
10E4:  BNZ   10D0
....................       delay_ms(3000); 
10E6:  MOVLW  0C
10E8:  MOVWF  2C
10EA:  MOVLW  FA
10EC:  MOVWF  2E
10EE:  CALL   05B8
10F2:  DECFSZ 2C,F
10F4:  BRA    10EA
....................       printf(lcd_putc,"\f MARQUE 8 PARA \n SENSORES"); 
10F6:  CLRF   2C
10F8:  MOVF   2C,W
10FA:  CALL   031E
10FE:  INCF   2C,F
1100:  MOVWF  00
1102:  MOVWF  2D
1104:  CALL   0720
1108:  MOVLW  1A
110A:  SUBWF  2C,W
110C:  BNZ   10F8
....................       delay_ms(3000); 
110E:  MOVLW  0C
1110:  MOVWF  2C
1112:  MOVLW  FA
1114:  MOVWF  2E
1116:  CALL   05B8
111A:  DECFSZ 2C,F
111C:  BRA    1112
....................       printf(lcd_putc,"\f MARQUE 9 PARA \n SALIR"); 
111E:  CLRF   2C
1120:  MOVF   2C,W
1122:  CALL   034A
1126:  INCF   2C,F
1128:  MOVWF  00
112A:  MOVWF  2D
112C:  CALL   0720
1130:  MOVLW  17
1132:  SUBWF  2C,W
1134:  BNZ   1120
....................       delay_ms(3000); 
1136:  MOVLW  0C
1138:  MOVWF  2C
113A:  MOVLW  FA
113C:  MOVWF  2E
113E:  CALL   05B8
1142:  DECFSZ 2C,F
1144:  BRA    113A
....................  
....................       un_digito(); 
1146:  RCALL  0CE2
....................        
....................       if(datom==0x01) 
1148:  DECFSZ 23,W
114A:  BRA    12C6
....................      { 
....................        lcd_putc('\f');                   //Limpiar pantalla comando 
114C:  MOVLW  0C
114E:  MOVWF  2D
1150:  CALL   0720
....................        lcd_gotoxy(1,1);                  //escribir en a primera fila primera posicion  
1154:  MOVLW  01
1156:  MOVWF  2E
1158:  MOVWF  2F
115A:  CALL   06C4
....................        lcd_putc("MEN CAMBIAR CLAV");     //lo que se escribe 
115E:  CLRF   2C
1160:  MOVF   2C,W
1162:  CALL   0372
1166:  IORLW  00
1168:  BZ    1174
116A:  INCF   2C,F
116C:  MOVWF  2D
116E:  CALL   0720
1172:  BRA    1160
....................        lcd_gotoxy(3,2);                  //escribir en a primera fila primera posicion  
1174:  MOVLW  03
1176:  MOVWF  2E
1178:  MOVLW  02
117A:  MOVWF  2F
117C:  CALL   06C4
....................        lcd_putc("DIGITE NU. CLAVE");     //clave[0]= y clave[1]= 
1180:  CLRF   2C
1182:  MOVF   2C,W
1184:  CALL   0394
1188:  IORLW  00
118A:  BZ    1196
118C:  INCF   2C,F
118E:  MOVWF  2D
1190:  CALL   0720
1194:  BRA    1182
....................        delay_ms(3000); 
1196:  MOVLW  0C
1198:  MOVWF  2C
119A:  MOVLW  FA
119C:  MOVWF  2E
119E:  CALL   05B8
11A2:  DECFSZ 2C,F
11A4:  BRA    119A
....................        teclado(); 
11A6:  RCALL  0B44
....................         
....................        dato1=clave[0]; 
11A8:  MOVFF  14,21
....................        dato2=clave[1]; 
11AC:  MOVFF  15,22
....................         
....................        lcd_putc('\f');                   //Limpiar pantalla comando 
11B0:  MOVLW  0C
11B2:  MOVWF  2D
11B4:  CALL   0720
....................        lcd_gotoxy(1,1);                  //escribir en a primera fila primera posicion  
11B8:  MOVLW  01
11BA:  MOVWF  2E
11BC:  MOVWF  2F
11BE:  CALL   06C4
....................        lcd_putc("POR FAVOR DIGITE");     //lo que se escribe 
11C2:  CLRF   2C
11C4:  MOVF   2C,W
11C6:  CALL   03B6
11CA:  IORLW  00
11CC:  BZ    11D8
11CE:  INCF   2C,F
11D0:  MOVWF  2D
11D2:  CALL   0720
11D6:  BRA    11C4
....................        lcd_gotoxy(1,2);                  //escribir en a primera fila primera posicion  
11D8:  MOVLW  01
11DA:  MOVWF  2E
11DC:  MOVLW  02
11DE:  MOVWF  2F
11E0:  CALL   06C4
....................        lcd_putc("DIGITE NUE.CLAVE");    
11E4:  CLRF   2C
11E6:  MOVF   2C,W
11E8:  CALL   03D8
11EC:  IORLW  00
11EE:  BZ    11FA
11F0:  INCF   2C,F
11F2:  MOVWF  2D
11F4:  CALL   0720
11F8:  BRA    11E6
....................        delay_ms(3000); 
11FA:  MOVLW  0C
11FC:  MOVWF  2C
11FE:  MOVLW  FA
1200:  MOVWF  2E
1202:  CALL   05B8
1206:  DECFSZ 2C,F
1208:  BRA    11FE
....................         
....................        teclado(); 
120A:  RCALL  0B44
....................         
....................        if(clave[0]==dato1 & clave[1]==dato2) 
120C:  MOVF   21,W
120E:  SUBWF  14,W
1210:  BZ    1216
1212:  MOVLW  00
1214:  BRA    1218
1216:  MOVLW  01
1218:  MOVWF  2C
121A:  MOVF   22,W
121C:  SUBWF  15,W
121E:  BZ    1224
1220:  MOVLW  00
1222:  BRA    1226
1224:  MOVLW  01
1226:  ANDWF  2C,W
1228:  BZ    128A
....................        { 
....................          escribir_memoria(); 
122A:  RCALL  0D44
....................          lcd_putc('\f');                   //Limpiar pantalla comando 
122C:  MOVLW  0C
122E:  MOVWF  2D
1230:  CALL   0720
....................          lcd_gotoxy(1,1);                  //escribir en a primera fila primera posicion  
1234:  MOVLW  01
1236:  MOVWF  2E
1238:  MOVWF  2F
123A:  CALL   06C4
....................          lcd_putc("CLAVE MODIFICADA");     //lo que se escribe 
123E:  CLRF   2C
1240:  MOVF   2C,W
1242:  CALL   03FA
1246:  IORLW  00
1248:  BZ    1254
124A:  INCF   2C,F
124C:  MOVWF  2D
124E:  CALL   0720
1252:  BRA    1240
....................          lcd_gotoxy(3,2);                  //escribir en a primera fila primera posicion  
1254:  MOVLW  03
1256:  MOVWF  2E
1258:  MOVLW  02
125A:  MOVWF  2F
125C:  CALL   06C4
....................          lcd_putc("CON EXITO");    
1260:  CLRF   2C
1262:  MOVF   2C,W
1264:  CALL   041C
1268:  IORLW  00
126A:  BZ    1276
126C:  INCF   2C,F
126E:  MOVWF  2D
1270:  CALL   0720
1274:  BRA    1262
....................          delay_ms(3000); 
1276:  MOVLW  0C
1278:  MOVWF  2C
127A:  MOVLW  FA
127C:  MOVWF  2E
127E:  CALL   05B8
1282:  DECFSZ 2C,F
1284:  BRA    127A
....................           goto camilo; 
1286:  BRA    0FB4
....................        } 
....................        else{ 
1288:  BRA    12C4
....................        lcd_putc('\f');                   //Limpiar pantalla comando 
128A:  MOVLW  0C
128C:  MOVWF  2D
128E:  CALL   0720
....................        lcd_gotoxy(1,1);                  //escribir en a primera fila primera posicion  
1292:  MOVLW  01
1294:  MOVWF  2E
1296:  MOVWF  2F
1298:  CALL   06C4
....................        lcd_putc("ERROR DE CLAVE");     //lo que se escribe 
129C:  CLRF   2C
129E:  MOVF   2C,W
12A0:  CALL   0436
12A4:  IORLW  00
12A6:  BZ    12B2
12A8:  INCF   2C,F
12AA:  MOVWF  2D
12AC:  CALL   0720
12B0:  BRA    129E
....................        delay_ms(3000); 
12B2:  MOVLW  0C
12B4:  MOVWF  2C
12B6:  MOVLW  FA
12B8:  MOVWF  2E
12BA:  CALL   05B8
12BE:  DECFSZ 2C,F
12C0:  BRA    12B6
....................        goto camilo; 
12C2:  BRA    0FB4
....................        } 
....................         
....................      } 
....................      else if(datom==0x02) 
12C4:  BRA    15C8
12C6:  MOVF   23,W
12C8:  SUBLW  02
12CA:  BNZ   132A
....................      { 
....................        lcd_putc('\f');                  //Limpiar pantalla comando 
12CC:  MOVLW  0C
12CE:  MOVWF  2D
12D0:  CALL   0720
....................        lcd_gotoxy(1,1);                 //escribir en a primera fila primera posicion  
12D4:  MOVLW  01
12D6:  MOVWF  2E
12D8:  MOVWF  2F
12DA:  CALL   06C4
....................        lcd_putc("MEN FECHA Y HORA");    //lo que se escribe 
12DE:  CLRF   2C
12E0:  MOVF   2C,W
12E2:  CALL   0456
12E6:  IORLW  00
12E8:  BZ    12F4
12EA:  INCF   2C,F
12EC:  MOVWF  2D
12EE:  CALL   0720
12F2:  BRA    12E0
....................        lcd_gotoxy(3,2);                 //escribir en a primera fila primera posicion  
12F4:  MOVLW  03
12F6:  MOVWF  2E
12F8:  MOVLW  02
12FA:  MOVWF  2F
12FC:  CALL   06C4
....................        lcd_putc("EN CONSTRUCCION"); 
1300:  CLRF   2C
1302:  MOVF   2C,W
1304:  CALL   0478
1308:  IORLW  00
130A:  BZ    1316
130C:  INCF   2C,F
130E:  MOVWF  2D
1310:  CALL   0720
1314:  BRA    1302
....................        delay_ms(3000); 
1316:  MOVLW  0C
1318:  MOVWF  2C
131A:  MOVLW  FA
131C:  MOVWF  2E
131E:  CALL   05B8
1322:  DECFSZ 2C,F
1324:  BRA    131A
....................        goto camilo; 
1326:  BRA    0FB4
....................      } 
....................     else  if(datom==0x03) 
1328:  BRA    15C8
132A:  MOVF   23,W
132C:  SUBLW  03
132E:  BNZ   138E
....................      { 
....................        lcd_putc('\f');                //Limpiar pantalla comando 
1330:  MOVLW  0C
1332:  MOVWF  2D
1334:  CALL   0720
....................        lcd_gotoxy(1,1);               //escribir en a primera fila primera posicion  
1338:  MOVLW  01
133A:  MOVWF  2E
133C:  MOVWF  2F
133E:  CALL   06C4
....................        lcd_putc("MENU REPORTES");     //lo que se escribe 
1342:  CLRF   2C
1344:  MOVF   2C,W
1346:  CALL   0498
134A:  IORLW  00
134C:  BZ    1358
134E:  INCF   2C,F
1350:  MOVWF  2D
1352:  CALL   0720
1356:  BRA    1344
....................        lcd_gotoxy(3,2);               //escribir en a primera fila primera posicion  
1358:  MOVLW  03
135A:  MOVWF  2E
135C:  MOVLW  02
135E:  MOVWF  2F
1360:  CALL   06C4
....................        lcd_putc("EN CONSTRUCCION"); 
1364:  CLRF   2C
1366:  MOVF   2C,W
1368:  CALL   0478
136C:  IORLW  00
136E:  BZ    137A
1370:  INCF   2C,F
1372:  MOVWF  2D
1374:  CALL   0720
1378:  BRA    1366
....................        delay_ms(3000); 
137A:  MOVLW  0C
137C:  MOVWF  2C
137E:  MOVLW  FA
1380:  MOVWF  2E
1382:  CALL   05B8
1386:  DECFSZ 2C,F
1388:  BRA    137E
....................        goto camilo;; 
138A:  BRA    0FB4
....................      } 
....................     else if(datom==0x04) 
138C:  BRA    15C8
138E:  MOVF   23,W
1390:  SUBLW  04
1392:  BNZ   13F2
....................      { 
....................        lcd_putc('\f');               //Limpiar pantalla comando 
1394:  MOVLW  0C
1396:  MOVWF  2D
1398:  CALL   0720
....................        lcd_gotoxy(1,1);              //escribir en a primera fila primera posicion  
139C:  MOVLW  01
139E:  MOVWF  2E
13A0:  MOVWF  2F
13A2:  CALL   06C4
....................        lcd_putc("MEN MOTOR PAS A."); //lo que se escribe 
13A6:  CLRF   2C
13A8:  MOVF   2C,W
13AA:  CALL   04B6
13AE:  IORLW  00
13B0:  BZ    13BC
13B2:  INCF   2C,F
13B4:  MOVWF  2D
13B6:  CALL   0720
13BA:  BRA    13A8
....................        lcd_gotoxy(3,2);              //escribir en a primera fila primera posicion  
13BC:  MOVLW  03
13BE:  MOVWF  2E
13C0:  MOVLW  02
13C2:  MOVWF  2F
13C4:  CALL   06C4
....................        lcd_putc("EN CONSTRUCCION"); 
13C8:  CLRF   2C
13CA:  MOVF   2C,W
13CC:  CALL   0478
13D0:  IORLW  00
13D2:  BZ    13DE
13D4:  INCF   2C,F
13D6:  MOVWF  2D
13D8:  CALL   0720
13DC:  BRA    13CA
....................        delay_ms(3000); 
13DE:  MOVLW  0C
13E0:  MOVWF  2C
13E2:  MOVLW  FA
13E4:  MOVWF  2E
13E6:  CALL   05B8
13EA:  DECFSZ 2C,F
13EC:  BRA    13E2
....................        goto camilo; 
13EE:  BRA    0FB4
....................      } 
....................     else if(datom==0x05) 
13F0:  BRA    15C8
13F2:  MOVF   23,W
13F4:  SUBLW  05
13F6:  BNZ   1456
....................      { 
....................        lcd_putc('\f');              //Limpiar pantalla comando 
13F8:  MOVLW  0C
13FA:  MOVWF  2D
13FC:  CALL   0720
....................        lcd_gotoxy(1,1);             //escribir en a primera fila primera posicion  
1400:  MOVLW  01
1402:  MOVWF  2E
1404:  MOVWF  2F
1406:  CALL   06C4
....................        lcd_putc("MEN SERVOMOTOR");  //lo que se escribe 
140A:  CLRF   2C
140C:  MOVF   2C,W
140E:  CALL   04D8
1412:  IORLW  00
1414:  BZ    1420
1416:  INCF   2C,F
1418:  MOVWF  2D
141A:  CALL   0720
141E:  BRA    140C
....................        lcd_gotoxy(3,2);             //escribir en a primera fila primera posicion  
1420:  MOVLW  03
1422:  MOVWF  2E
1424:  MOVLW  02
1426:  MOVWF  2F
1428:  CALL   06C4
....................        lcd_putc("EN CONSTRUCCION"); 
142C:  CLRF   2C
142E:  MOVF   2C,W
1430:  CALL   0478
1434:  IORLW  00
1436:  BZ    1442
1438:  INCF   2C,F
143A:  MOVWF  2D
143C:  CALL   0720
1440:  BRA    142E
....................        delay_ms(3000); 
1442:  MOVLW  0C
1444:  MOVWF  2C
1446:  MOVLW  FA
1448:  MOVWF  2E
144A:  CALL   05B8
144E:  DECFSZ 2C,F
1450:  BRA    1446
....................        goto camilo; 
1452:  BRA    0FB4
....................      } 
....................     else if(datom==0x06) 
1454:  BRA    15C8
1456:  MOVF   23,W
1458:  SUBLW  06
145A:  BNZ   14BA
....................      { 
....................        lcd_putc('\f');               //Limpiar pantalla comando 
145C:  MOVLW  0C
145E:  MOVWF  2D
1460:  CALL   0720
....................        lcd_gotoxy(1,1);              //escribir en a primera fila primera posicion  
1464:  MOVLW  01
1466:  MOVWF  2E
1468:  MOVWF  2F
146A:  CALL   06C4
....................        lcd_putc("MENU CAD");         //lo que se escribe 
146E:  CLRF   2C
1470:  MOVF   2C,W
1472:  CALL   04F8
1476:  IORLW  00
1478:  BZ    1484
147A:  INCF   2C,F
147C:  MOVWF  2D
147E:  CALL   0720
1482:  BRA    1470
....................        lcd_gotoxy(3,2);              //escribir en a primera fila primera posicion  
1484:  MOVLW  03
1486:  MOVWF  2E
1488:  MOVLW  02
148A:  MOVWF  2F
148C:  CALL   06C4
....................        lcd_putc("EN CONSTRUCCION"); 
1490:  CLRF   2C
1492:  MOVF   2C,W
1494:  CALL   0478
1498:  IORLW  00
149A:  BZ    14A6
149C:  INCF   2C,F
149E:  MOVWF  2D
14A0:  CALL   0720
14A4:  BRA    1492
....................        delay_ms(3000); 
14A6:  MOVLW  0C
14A8:  MOVWF  2C
14AA:  MOVLW  FA
14AC:  MOVWF  2E
14AE:  CALL   05B8
14B2:  DECFSZ 2C,F
14B4:  BRA    14AA
....................        goto camilo; 
14B6:  BRA    0FB4
....................      } 
....................     else if(datom==0x07) 
14B8:  BRA    15C8
14BA:  MOVF   23,W
14BC:  SUBLW  07
14BE:  BNZ   151E
....................      { 
....................        lcd_putc('\f');               //Limpiar pantalla comando 
14C0:  MOVLW  0C
14C2:  MOVWF  2D
14C4:  CALL   0720
....................        lcd_gotoxy(1,1);              //escribir en a primera fila primera posicion  
14C8:  MOVLW  01
14CA:  MOVWF  2E
14CC:  MOVWF  2F
14CE:  CALL   06C4
....................        lcd_putc("MEN DTMF");         //lo que se escribe 
14D2:  CLRF   2C
14D4:  MOVF   2C,W
14D6:  CALL   0512
14DA:  IORLW  00
14DC:  BZ    14E8
14DE:  INCF   2C,F
14E0:  MOVWF  2D
14E2:  CALL   0720
14E6:  BRA    14D4
....................        lcd_gotoxy(3,2);              //escribir en a primera fila primera posicion  
14E8:  MOVLW  03
14EA:  MOVWF  2E
14EC:  MOVLW  02
14EE:  MOVWF  2F
14F0:  CALL   06C4
....................        lcd_putc("EN CONSTRUCCION"); 
14F4:  CLRF   2C
14F6:  MOVF   2C,W
14F8:  CALL   0478
14FC:  IORLW  00
14FE:  BZ    150A
1500:  INCF   2C,F
1502:  MOVWF  2D
1504:  CALL   0720
1508:  BRA    14F6
....................        delay_ms(3000); 
150A:  MOVLW  0C
150C:  MOVWF  2C
150E:  MOVLW  FA
1510:  MOVWF  2E
1512:  CALL   05B8
1516:  DECFSZ 2C,F
1518:  BRA    150E
....................        goto camilo; 
151A:  BRA    0FB4
....................      } 
....................     else if(datom==0x08) 
151C:  BRA    15C8
151E:  MOVF   23,W
1520:  SUBLW  08
1522:  BNZ   1582
....................      { 
....................        lcd_putc('\f');              //Limpiar pantalla comando 
1524:  MOVLW  0C
1526:  MOVWF  2D
1528:  CALL   0720
....................        lcd_gotoxy(1,1);             //escribir en a primera fila primera posicion  
152C:  MOVLW  01
152E:  MOVWF  2E
1530:  MOVWF  2F
1532:  CALL   06C4
....................        lcd_putc("MEN SENSORES");    //lo que se escribe 
1536:  CLRF   2C
1538:  MOVF   2C,W
153A:  CALL   052C
153E:  IORLW  00
1540:  BZ    154C
1542:  INCF   2C,F
1544:  MOVWF  2D
1546:  CALL   0720
154A:  BRA    1538
....................        lcd_gotoxy(3,2);             //escribir en a primera fila primera posicion  
154C:  MOVLW  03
154E:  MOVWF  2E
1550:  MOVLW  02
1552:  MOVWF  2F
1554:  CALL   06C4
....................        lcd_putc("EN CONSTRUCCION"); 
1558:  CLRF   2C
155A:  MOVF   2C,W
155C:  CALL   0478
1560:  IORLW  00
1562:  BZ    156E
1564:  INCF   2C,F
1566:  MOVWF  2D
1568:  CALL   0720
156C:  BRA    155A
....................        delay_ms(3000); 
156E:  MOVLW  0C
1570:  MOVWF  2C
1572:  MOVLW  FA
1574:  MOVWF  2E
1576:  CALL   05B8
157A:  DECFSZ 2C,F
157C:  BRA    1572
....................        goto camilo; 
157E:  BRA    0FB4
....................      } 
....................     else if(datom==0x09) 
1580:  BRA    15C8
1582:  MOVF   23,W
1584:  SUBLW  09
1586:  BNZ   158C
....................      { 
....................       goto admin; 
1588:  BRA    0EAE
....................      } 
....................      else{ 
158A:  BRA    15C8
....................           lcd_putc('\f');                 //Limpiar pantalla comando 
158C:  MOVLW  0C
158E:  MOVWF  2D
1590:  CALL   0720
....................           lcd_gotoxy(1,2);                //escribir en a primera fila primera posicion  
1594:  MOVLW  01
1596:  MOVWF  2E
1598:  MOVLW  02
159A:  MOVWF  2F
159C:  CALL   06C4
....................           lcd_putc("ERROR DE NUMERO");   //lo que se escribe 
15A0:  CLRF   2C
15A2:  MOVF   2C,W
15A4:  CALL   054A
15A8:  IORLW  00
15AA:  BZ    15B6
15AC:  INCF   2C,F
15AE:  MOVWF  2D
15B0:  CALL   0720
15B4:  BRA    15A2
....................           delay_ms(3000); 
15B6:  MOVLW  0C
15B8:  MOVWF  2C
15BA:  MOVLW  FA
15BC:  MOVWF  2E
15BE:  CALL   05B8
15C2:  DECFSZ 2C,F
15C4:  BRA    15BA
....................           goto menu; 
15C6:  BRA    0DEC
....................       } 
....................    } 
....................    else if(clave[0]==datoi[3] &  clave[1]==datoi[2]) 
15C8:  BRA    1C4C
15CA:  MOVF   1B,W
15CC:  SUBWF  14,W
15CE:  BZ    15D4
15D0:  MOVLW  00
15D2:  BRA    15D6
15D4:  MOVLW  01
15D6:  MOVWF  2C
15D8:  MOVF   1A,W
15DA:  SUBWF  15,W
15DC:  BZ    15E2
15DE:  MOVLW  00
15E0:  BRA    15E4
15E2:  MOVLW  01
15E4:  ANDWF  2C,W
15E6:  BTFSC  FD8.2
15E8:  BRA    1C0E
....................    { 
.................... vero:   adres=0x02; 
15EA:  MOVLW  02
15EC:  MOVWF  20
....................       printf(lcd_putc,"\f BIENV. AL MENU\n DE VERONICA"); 
15EE:  CLRF   2C
15F0:  MOVF   2C,W
15F2:  CALL   056A
15F6:  INCF   2C,F
15F8:  MOVWF  00
15FA:  MOVWF  2D
15FC:  CALL   0720
1600:  MOVLW  1D
1602:  SUBWF  2C,W
1604:  BNZ   15F0
....................       delay_ms(3000); 
1606:  MOVLW  0C
1608:  MOVWF  2C
160A:  MOVLW  FA
160C:  MOVWF  2E
160E:  CALL   05B8
1612:  DECFSZ 2C,F
1614:  BRA    160A
....................       printf(lcd_putc,"\f MARQUE 1 PARA \n CAMBIAR CLAVE"); 
1616:  CLRF   2C
1618:  MOVF   2C,W
161A:  CALL   01E4
161E:  INCF   2C,F
1620:  MOVWF  00
1622:  MOVWF  2D
1624:  CALL   0720
1628:  MOVLW  1F
162A:  SUBWF  2C,W
162C:  BNZ   1618
....................       delay_ms(3000); 
162E:  MOVLW  0C
1630:  MOVWF  2C
1632:  MOVLW  FA
1634:  MOVWF  2E
1636:  CALL   05B8
163A:  DECFSZ 2C,F
163C:  BRA    1632
....................       printf(lcd_putc,"\f MARQUE 2 PARA \n FECHA Y HORA"); 
163E:  CLRF   2C
1640:  MOVF   2C,W
1642:  CALL   0214
1646:  INCF   2C,F
1648:  MOVWF  00
164A:  MOVWF  2D
164C:  CALL   0720
1650:  MOVLW  1E
1652:  SUBWF  2C,W
1654:  BNZ   1640
....................       delay_ms(3000); 
1656:  MOVLW  0C
1658:  MOVWF  2C
165A:  MOVLW  FA
165C:  MOVWF  2E
165E:  CALL   05B8
1662:  DECFSZ 2C,F
1664:  BRA    165A
....................       printf(lcd_putc,"\f MARQUE 3 PARA \n REPORTES"); 
1666:  CLRF   2C
1668:  MOVF   2C,W
166A:  CALL   0244
166E:  INCF   2C,F
1670:  MOVWF  00
1672:  MOVWF  2D
1674:  CALL   0720
1678:  MOVLW  1A
167A:  SUBWF  2C,W
167C:  BNZ   1668
....................       delay_ms(3000); 
167E:  MOVLW  0C
1680:  MOVWF  2C
1682:  MOVLW  FA
1684:  MOVWF  2E
1686:  CALL   05B8
168A:  DECFSZ 2C,F
168C:  BRA    1682
....................       printf(lcd_putc,"\f MARQUE 4 PARA \n MTR PASO A PASO"); 
168E:  CLRF   2C
1690:  MOVF   2C,W
1692:  CALL   0270
1696:  INCF   2C,F
1698:  MOVWF  00
169A:  MOVWF  2D
169C:  CALL   0720
16A0:  MOVLW  21
16A2:  SUBWF  2C,W
16A4:  BNZ   1690
....................       delay_ms(3000); 
16A6:  MOVLW  0C
16A8:  MOVWF  2C
16AA:  MOVLW  FA
16AC:  MOVWF  2E
16AE:  CALL   05B8
16B2:  DECFSZ 2C,F
16B4:  BRA    16AA
....................       printf(lcd_putc,"\f MARQUE 5 PARA \n SERVOMOTOR"); 
16B6:  CLRF   2C
16B8:  MOVF   2C,W
16BA:  CALL   02A2
16BE:  INCF   2C,F
16C0:  MOVWF  00
16C2:  MOVWF  2D
16C4:  CALL   0720
16C8:  MOVLW  1C
16CA:  SUBWF  2C,W
16CC:  BNZ   16B8
....................       delay_ms(3000); 
16CE:  MOVLW  0C
16D0:  MOVWF  2C
16D2:  MOVLW  FA
16D4:  MOVWF  2E
16D6:  CALL   05B8
16DA:  DECFSZ 2C,F
16DC:  BRA    16D2
....................       printf(lcd_putc,"\f MARQUE 6 PARA \n CAD"); 
16DE:  CLRF   2C
16E0:  MOVF   2C,W
16E2:  CALL   02D0
16E6:  INCF   2C,F
16E8:  MOVWF  00
16EA:  MOVWF  2D
16EC:  CALL   0720
16F0:  MOVLW  15
16F2:  SUBWF  2C,W
16F4:  BNZ   16E0
....................       delay_ms(3000); 
16F6:  MOVLW  0C
16F8:  MOVWF  2C
16FA:  MOVLW  FA
16FC:  MOVWF  2E
16FE:  CALL   05B8
1702:  DECFSZ 2C,F
1704:  BRA    16FA
....................       printf(lcd_putc,"\f MARQUE 7 PARA \n DTFM"); 
1706:  CLRF   2C
1708:  MOVF   2C,W
170A:  CALL   02F6
170E:  INCF   2C,F
1710:  MOVWF  00
1712:  MOVWF  2D
1714:  CALL   0720
1718:  MOVLW  16
171A:  SUBWF  2C,W
171C:  BNZ   1708
....................       delay_ms(3000); 
171E:  MOVLW  0C
1720:  MOVWF  2C
1722:  MOVLW  FA
1724:  MOVWF  2E
1726:  CALL   05B8
172A:  DECFSZ 2C,F
172C:  BRA    1722
....................       printf(lcd_putc,"\f MARQUE 8 PARA \n SENSORES"); 
172E:  CLRF   2C
1730:  MOVF   2C,W
1732:  CALL   031E
1736:  INCF   2C,F
1738:  MOVWF  00
173A:  MOVWF  2D
173C:  CALL   0720
1740:  MOVLW  1A
1742:  SUBWF  2C,W
1744:  BNZ   1730
....................       delay_ms(3000); 
1746:  MOVLW  0C
1748:  MOVWF  2C
174A:  MOVLW  FA
174C:  MOVWF  2E
174E:  CALL   05B8
1752:  DECFSZ 2C,F
1754:  BRA    174A
....................       printf(lcd_putc,"\f MARQUE 9 PARA \n SALIR"); 
1756:  CLRF   2C
1758:  MOVF   2C,W
175A:  CALL   034A
175E:  INCF   2C,F
1760:  MOVWF  00
1762:  MOVWF  2D
1764:  CALL   0720
1768:  MOVLW  17
176A:  SUBWF  2C,W
176C:  BNZ   1758
....................       delay_ms(3000); 
176E:  MOVLW  0C
1770:  MOVWF  2C
1772:  MOVLW  FA
1774:  MOVWF  2E
1776:  CALL   05B8
177A:  DECFSZ 2C,F
177C:  BRA    1772
....................       
....................        
....................      un_digito(); 
177E:  CALL   0CE2
....................       if(datom==0x01) 
1782:  DECFSZ 23,W
1784:  BRA    1906
....................      { 
....................        lcd_putc('\f');                   //Limpiar pantalla comando 
1786:  MOVLW  0C
1788:  MOVWF  2D
178A:  CALL   0720
....................        lcd_gotoxy(1,1);                  //escribir en a primera fila primera posicion  
178E:  MOVLW  01
1790:  MOVWF  2E
1792:  MOVWF  2F
1794:  CALL   06C4
....................        lcd_putc("MEN CAMBIAR CLAV");     //lo que se escribe 
1798:  CLRF   2C
179A:  MOVF   2C,W
179C:  CALL   0372
17A0:  IORLW  00
17A2:  BZ    17AE
17A4:  INCF   2C,F
17A6:  MOVWF  2D
17A8:  CALL   0720
17AC:  BRA    179A
....................        lcd_gotoxy(3,2);                  //escribir en a primera fila primera posicion  
17AE:  MOVLW  03
17B0:  MOVWF  2E
17B2:  MOVLW  02
17B4:  MOVWF  2F
17B6:  CALL   06C4
....................        lcd_putc("DIGITE NU. CLAVE");     //clave[0]= y clave[1]= 
17BA:  CLRF   2C
17BC:  MOVF   2C,W
17BE:  CALL   0394
17C2:  IORLW  00
17C4:  BZ    17D0
17C6:  INCF   2C,F
17C8:  MOVWF  2D
17CA:  CALL   0720
17CE:  BRA    17BC
....................        delay_ms(3000); 
17D0:  MOVLW  0C
17D2:  MOVWF  2C
17D4:  MOVLW  FA
17D6:  MOVWF  2E
17D8:  CALL   05B8
17DC:  DECFSZ 2C,F
17DE:  BRA    17D4
....................        teclado(); 
17E0:  CALL   0B44
....................         
....................        dato1=clave[0]; 
17E4:  MOVFF  14,21
....................        dato2=clave[1]; 
17E8:  MOVFF  15,22
....................         
....................        lcd_putc('\f');                   //Limpiar pantalla comando 
17EC:  MOVLW  0C
17EE:  MOVWF  2D
17F0:  CALL   0720
....................        lcd_gotoxy(1,1);                  //escribir en a primera fila primera posicion  
17F4:  MOVLW  01
17F6:  MOVWF  2E
17F8:  MOVWF  2F
17FA:  CALL   06C4
....................        lcd_putc("POR FAVOR DIGITE");     //lo que se escribe 
17FE:  CLRF   2C
1800:  MOVF   2C,W
1802:  CALL   03B6
1806:  IORLW  00
1808:  BZ    1814
180A:  INCF   2C,F
180C:  MOVWF  2D
180E:  CALL   0720
1812:  BRA    1800
....................        lcd_gotoxy(1,2);                  //escribir en a primera fila primera posicion  
1814:  MOVLW  01
1816:  MOVWF  2E
1818:  MOVLW  02
181A:  MOVWF  2F
181C:  CALL   06C4
....................        lcd_putc("DIGITE NUE.CLAVE");    
1820:  CLRF   2C
1822:  MOVF   2C,W
1824:  CALL   03D8
1828:  IORLW  00
182A:  BZ    1836
182C:  INCF   2C,F
182E:  MOVWF  2D
1830:  CALL   0720
1834:  BRA    1822
....................        delay_ms(3000); 
1836:  MOVLW  0C
1838:  MOVWF  2C
183A:  MOVLW  FA
183C:  MOVWF  2E
183E:  CALL   05B8
1842:  DECFSZ 2C,F
1844:  BRA    183A
....................         
....................        teclado(); 
1846:  CALL   0B44
....................         
....................        if(clave[0]==dato1 & clave[1]==dato2) 
184A:  MOVF   21,W
184C:  SUBWF  14,W
184E:  BZ    1854
1850:  MOVLW  00
1852:  BRA    1856
1854:  MOVLW  01
1856:  MOVWF  2C
1858:  MOVF   22,W
185A:  SUBWF  15,W
185C:  BZ    1862
185E:  MOVLW  00
1860:  BRA    1864
1862:  MOVLW  01
1864:  ANDWF  2C,W
1866:  BZ    18CA
....................        { 
....................         escribir_memoria(); 
1868:  CALL   0D44
....................         lcd_putc('\f');                   //Limpiar pantalla comando 
186C:  MOVLW  0C
186E:  MOVWF  2D
1870:  CALL   0720
....................         lcd_gotoxy(1,1);                  //escribir en a primera fila primera posicion  
1874:  MOVLW  01
1876:  MOVWF  2E
1878:  MOVWF  2F
187A:  CALL   06C4
....................         lcd_putc("CLAVE MODIFICADA");     //lo que se escribe 
187E:  CLRF   2C
1880:  MOVF   2C,W
1882:  CALL   03FA
1886:  IORLW  00
1888:  BZ    1894
188A:  INCF   2C,F
188C:  MOVWF  2D
188E:  CALL   0720
1892:  BRA    1880
....................         lcd_gotoxy(3,2);                  //escribir en a primera fila primera posicion  
1894:  MOVLW  03
1896:  MOVWF  2E
1898:  MOVLW  02
189A:  MOVWF  2F
189C:  CALL   06C4
....................         lcd_putc("CON EXITO");    
18A0:  CLRF   2C
18A2:  MOVF   2C,W
18A4:  CALL   041C
18A8:  IORLW  00
18AA:  BZ    18B6
18AC:  INCF   2C,F
18AE:  MOVWF  2D
18B0:  CALL   0720
18B4:  BRA    18A2
....................         delay_ms(3000); 
18B6:  MOVLW  0C
18B8:  MOVWF  2C
18BA:  MOVLW  FA
18BC:  MOVWF  2E
18BE:  CALL   05B8
18C2:  DECFSZ 2C,F
18C4:  BRA    18BA
....................           goto vero; 
18C6:  BRA    15EA
....................        } 
....................        else{ 
18C8:  BRA    1904
....................        lcd_putc('\f');                   //Limpiar pantalla comando 
18CA:  MOVLW  0C
18CC:  MOVWF  2D
18CE:  CALL   0720
....................        lcd_gotoxy(1,1);                  //escribir en a primera fila primera posicion  
18D2:  MOVLW  01
18D4:  MOVWF  2E
18D6:  MOVWF  2F
18D8:  CALL   06C4
....................        lcd_putc("ERROR DE CLAVE");     //lo que se escribe 
18DC:  CLRF   2C
18DE:  MOVF   2C,W
18E0:  CALL   0436
18E4:  IORLW  00
18E6:  BZ    18F2
18E8:  INCF   2C,F
18EA:  MOVWF  2D
18EC:  CALL   0720
18F0:  BRA    18DE
....................        delay_ms(3000); 
18F2:  MOVLW  0C
18F4:  MOVWF  2C
18F6:  MOVLW  FA
18F8:  MOVWF  2E
18FA:  CALL   05B8
18FE:  DECFSZ 2C,F
1900:  BRA    18F6
....................        goto vero; 
1902:  BRA    15EA
....................        } 
....................         
....................      } 
....................      else if(datom==0x02) 
1904:  BRA    1C0C
1906:  MOVF   23,W
1908:  SUBLW  02
190A:  BNZ   196A
....................      { 
....................        lcd_putc('\f');                  //Limpiar pantalla comando 
190C:  MOVLW  0C
190E:  MOVWF  2D
1910:  CALL   0720
....................        lcd_gotoxy(1,1);                 //escribir en a primera fila primera posicion  
1914:  MOVLW  01
1916:  MOVWF  2E
1918:  MOVWF  2F
191A:  CALL   06C4
....................        lcd_putc("MEN FECHA Y HORA");    //lo que se escribe 
191E:  CLRF   2C
1920:  MOVF   2C,W
1922:  CALL   0456
1926:  IORLW  00
1928:  BZ    1934
192A:  INCF   2C,F
192C:  MOVWF  2D
192E:  CALL   0720
1932:  BRA    1920
....................        lcd_gotoxy(3,2);                 //escribir en a primera fila primera posicion  
1934:  MOVLW  03
1936:  MOVWF  2E
1938:  MOVLW  02
193A:  MOVWF  2F
193C:  CALL   06C4
....................        lcd_putc("EN CONSTRUCCION"); 
1940:  CLRF   2C
1942:  MOVF   2C,W
1944:  CALL   0478
1948:  IORLW  00
194A:  BZ    1956
194C:  INCF   2C,F
194E:  MOVWF  2D
1950:  CALL   0720
1954:  BRA    1942
....................        delay_ms(3000); 
1956:  MOVLW  0C
1958:  MOVWF  2C
195A:  MOVLW  FA
195C:  MOVWF  2E
195E:  CALL   05B8
1962:  DECFSZ 2C,F
1964:  BRA    195A
....................        goto vero; 
1966:  BRA    15EA
....................      } 
....................     else  if(datom==0x03) 
1968:  BRA    1C0C
196A:  MOVF   23,W
196C:  SUBLW  03
196E:  BNZ   19CE
....................      { 
....................        lcd_putc('\f');                //Limpiar pantalla comando 
1970:  MOVLW  0C
1972:  MOVWF  2D
1974:  CALL   0720
....................        lcd_gotoxy(1,1);               //escribir en a primera fila primera posicion  
1978:  MOVLW  01
197A:  MOVWF  2E
197C:  MOVWF  2F
197E:  CALL   06C4
....................        lcd_putc("MENU REPORTES");     //lo que se escribe 
1982:  CLRF   2C
1984:  MOVF   2C,W
1986:  CALL   0498
198A:  IORLW  00
198C:  BZ    1998
198E:  INCF   2C,F
1990:  MOVWF  2D
1992:  CALL   0720
1996:  BRA    1984
....................        lcd_gotoxy(3,2);               //escribir en a primera fila primera posicion  
1998:  MOVLW  03
199A:  MOVWF  2E
199C:  MOVLW  02
199E:  MOVWF  2F
19A0:  CALL   06C4
....................        lcd_putc("EN CONSTRUCCION"); 
19A4:  CLRF   2C
19A6:  MOVF   2C,W
19A8:  CALL   0478
19AC:  IORLW  00
19AE:  BZ    19BA
19B0:  INCF   2C,F
19B2:  MOVWF  2D
19B4:  CALL   0720
19B8:  BRA    19A6
....................        delay_ms(3000); 
19BA:  MOVLW  0C
19BC:  MOVWF  2C
19BE:  MOVLW  FA
19C0:  MOVWF  2E
19C2:  CALL   05B8
19C6:  DECFSZ 2C,F
19C8:  BRA    19BE
....................        goto vero;; 
19CA:  BRA    15EA
....................      } 
....................     else if(datom==0x04) 
19CC:  BRA    1C0C
19CE:  MOVF   23,W
19D0:  SUBLW  04
19D2:  BNZ   1A32
....................      { 
....................        lcd_putc('\f');               //Limpiar pantalla comando 
19D4:  MOVLW  0C
19D6:  MOVWF  2D
19D8:  CALL   0720
....................        lcd_gotoxy(1,1);              //escribir en a primera fila primera posicion  
19DC:  MOVLW  01
19DE:  MOVWF  2E
19E0:  MOVWF  2F
19E2:  CALL   06C4
....................        lcd_putc("MEN MOTOR PAS A."); //lo que se escribe 
19E6:  CLRF   2C
19E8:  MOVF   2C,W
19EA:  CALL   04B6
19EE:  IORLW  00
19F0:  BZ    19FC
19F2:  INCF   2C,F
19F4:  MOVWF  2D
19F6:  CALL   0720
19FA:  BRA    19E8
....................        lcd_gotoxy(3,2);              //escribir en a primera fila primera posicion  
19FC:  MOVLW  03
19FE:  MOVWF  2E
1A00:  MOVLW  02
1A02:  MOVWF  2F
1A04:  CALL   06C4
....................        lcd_putc("EN CONSTRUCCION"); 
1A08:  CLRF   2C
1A0A:  MOVF   2C,W
1A0C:  CALL   0478
1A10:  IORLW  00
1A12:  BZ    1A1E
1A14:  INCF   2C,F
1A16:  MOVWF  2D
1A18:  CALL   0720
1A1C:  BRA    1A0A
....................        delay_ms(3000); 
1A1E:  MOVLW  0C
1A20:  MOVWF  2C
1A22:  MOVLW  FA
1A24:  MOVWF  2E
1A26:  CALL   05B8
1A2A:  DECFSZ 2C,F
1A2C:  BRA    1A22
....................        goto vero; 
1A2E:  BRA    15EA
....................      } 
....................     else if(datom==0x05) 
1A30:  BRA    1C0C
1A32:  MOVF   23,W
1A34:  SUBLW  05
1A36:  BNZ   1A96
....................      { 
....................        lcd_putc('\f');              //Limpiar pantalla comando 
1A38:  MOVLW  0C
1A3A:  MOVWF  2D
1A3C:  CALL   0720
....................        lcd_gotoxy(1,1);             //escribir en a primera fila primera posicion  
1A40:  MOVLW  01
1A42:  MOVWF  2E
1A44:  MOVWF  2F
1A46:  CALL   06C4
....................        lcd_putc("MEN SERVOMOTOR");  //lo que se escribe 
1A4A:  CLRF   2C
1A4C:  MOVF   2C,W
1A4E:  CALL   04D8
1A52:  IORLW  00
1A54:  BZ    1A60
1A56:  INCF   2C,F
1A58:  MOVWF  2D
1A5A:  CALL   0720
1A5E:  BRA    1A4C
....................        lcd_gotoxy(3,2);             //escribir en a primera fila primera posicion  
1A60:  MOVLW  03
1A62:  MOVWF  2E
1A64:  MOVLW  02
1A66:  MOVWF  2F
1A68:  CALL   06C4
....................        lcd_putc("EN CONSTRUCCION"); 
1A6C:  CLRF   2C
1A6E:  MOVF   2C,W
1A70:  CALL   0478
1A74:  IORLW  00
1A76:  BZ    1A82
1A78:  INCF   2C,F
1A7A:  MOVWF  2D
1A7C:  CALL   0720
1A80:  BRA    1A6E
....................        delay_ms(3000); 
1A82:  MOVLW  0C
1A84:  MOVWF  2C
1A86:  MOVLW  FA
1A88:  MOVWF  2E
1A8A:  CALL   05B8
1A8E:  DECFSZ 2C,F
1A90:  BRA    1A86
....................        goto vero; 
1A92:  BRA    15EA
....................      } 
....................     else if(datom==0x06) 
1A94:  BRA    1C0C
1A96:  MOVF   23,W
1A98:  SUBLW  06
1A9A:  BNZ   1AFA
....................      { 
....................        lcd_putc('\f');               //Limpiar pantalla comando 
1A9C:  MOVLW  0C
1A9E:  MOVWF  2D
1AA0:  CALL   0720
....................        lcd_gotoxy(1,1);              //escribir en a primera fila primera posicion  
1AA4:  MOVLW  01
1AA6:  MOVWF  2E
1AA8:  MOVWF  2F
1AAA:  CALL   06C4
....................        lcd_putc("MENU CAD");         //lo que se escribe 
1AAE:  CLRF   2C
1AB0:  MOVF   2C,W
1AB2:  CALL   04F8
1AB6:  IORLW  00
1AB8:  BZ    1AC4
1ABA:  INCF   2C,F
1ABC:  MOVWF  2D
1ABE:  CALL   0720
1AC2:  BRA    1AB0
....................        lcd_gotoxy(3,2);              //escribir en a primera fila primera posicion  
1AC4:  MOVLW  03
1AC6:  MOVWF  2E
1AC8:  MOVLW  02
1ACA:  MOVWF  2F
1ACC:  CALL   06C4
....................        lcd_putc("EN CONSTRUCCION"); 
1AD0:  CLRF   2C
1AD2:  MOVF   2C,W
1AD4:  CALL   0478
1AD8:  IORLW  00
1ADA:  BZ    1AE6
1ADC:  INCF   2C,F
1ADE:  MOVWF  2D
1AE0:  CALL   0720
1AE4:  BRA    1AD2
....................        delay_ms(3000); 
1AE6:  MOVLW  0C
1AE8:  MOVWF  2C
1AEA:  MOVLW  FA
1AEC:  MOVWF  2E
1AEE:  CALL   05B8
1AF2:  DECFSZ 2C,F
1AF4:  BRA    1AEA
....................        goto vero; 
1AF6:  BRA    15EA
....................      } 
....................     else if(datom==0x07) 
1AF8:  BRA    1C0C
1AFA:  MOVF   23,W
1AFC:  SUBLW  07
1AFE:  BNZ   1B5E
....................      { 
....................        lcd_putc('\f');               //Limpiar pantalla comando 
1B00:  MOVLW  0C
1B02:  MOVWF  2D
1B04:  CALL   0720
....................        lcd_gotoxy(1,1);              //escribir en a primera fila primera posicion  
1B08:  MOVLW  01
1B0A:  MOVWF  2E
1B0C:  MOVWF  2F
1B0E:  CALL   06C4
....................        lcd_putc("MEN DTMF");         //lo que se escribe 
1B12:  CLRF   2C
1B14:  MOVF   2C,W
1B16:  CALL   0512
1B1A:  IORLW  00
1B1C:  BZ    1B28
1B1E:  INCF   2C,F
1B20:  MOVWF  2D
1B22:  CALL   0720
1B26:  BRA    1B14
....................        lcd_gotoxy(3,2);              //escribir en a primera fila primera posicion  
1B28:  MOVLW  03
1B2A:  MOVWF  2E
1B2C:  MOVLW  02
1B2E:  MOVWF  2F
1B30:  CALL   06C4
....................        lcd_putc("EN CONSTRUCCION"); 
1B34:  CLRF   2C
1B36:  MOVF   2C,W
1B38:  CALL   0478
1B3C:  IORLW  00
1B3E:  BZ    1B4A
1B40:  INCF   2C,F
1B42:  MOVWF  2D
1B44:  CALL   0720
1B48:  BRA    1B36
....................        delay_ms(3000); 
1B4A:  MOVLW  0C
1B4C:  MOVWF  2C
1B4E:  MOVLW  FA
1B50:  MOVWF  2E
1B52:  CALL   05B8
1B56:  DECFSZ 2C,F
1B58:  BRA    1B4E
....................        goto vero; 
1B5A:  BRA    15EA
....................      } 
....................     else if(datom==0x08) 
1B5C:  BRA    1C0C
1B5E:  MOVF   23,W
1B60:  SUBLW  08
1B62:  BNZ   1BC2
....................      { 
....................        lcd_putc('\f');              //Limpiar pantalla comando 
1B64:  MOVLW  0C
1B66:  MOVWF  2D
1B68:  CALL   0720
....................        lcd_gotoxy(1,1);             //escribir en a primera fila primera posicion  
1B6C:  MOVLW  01
1B6E:  MOVWF  2E
1B70:  MOVWF  2F
1B72:  CALL   06C4
....................        lcd_putc("MEN SENSORES");    //lo que se escribe 
1B76:  CLRF   2C
1B78:  MOVF   2C,W
1B7A:  CALL   052C
1B7E:  IORLW  00
1B80:  BZ    1B8C
1B82:  INCF   2C,F
1B84:  MOVWF  2D
1B86:  CALL   0720
1B8A:  BRA    1B78
....................        lcd_gotoxy(3,2);             //escribir en a primera fila primera posicion  
1B8C:  MOVLW  03
1B8E:  MOVWF  2E
1B90:  MOVLW  02
1B92:  MOVWF  2F
1B94:  CALL   06C4
....................        lcd_putc("EN CONSTRUCCION"); 
1B98:  CLRF   2C
1B9A:  MOVF   2C,W
1B9C:  CALL   0478
1BA0:  IORLW  00
1BA2:  BZ    1BAE
1BA4:  INCF   2C,F
1BA6:  MOVWF  2D
1BA8:  CALL   0720
1BAC:  BRA    1B9A
....................        delay_ms(3000); 
1BAE:  MOVLW  0C
1BB0:  MOVWF  2C
1BB2:  MOVLW  FA
1BB4:  MOVWF  2E
1BB6:  CALL   05B8
1BBA:  DECFSZ 2C,F
1BBC:  BRA    1BB2
....................        goto vero; 
1BBE:  BRA    15EA
....................      } 
....................     else if(datom==0x09) 
1BC0:  BRA    1C0C
1BC2:  MOVF   23,W
1BC4:  SUBLW  09
1BC6:  BNZ   1BCE
....................      { 
....................       goto admin; 
1BC8:  GOTO   0EAE
....................      } 
....................      else{ 
1BCC:  BRA    1C0C
....................           lcd_putc('\f');                 //Limpiar pantalla comando 
1BCE:  MOVLW  0C
1BD0:  MOVWF  2D
1BD2:  CALL   0720
....................           lcd_gotoxy(1,2);                //escribir en a primera fila primera posicion  
1BD6:  MOVLW  01
1BD8:  MOVWF  2E
1BDA:  MOVLW  02
1BDC:  MOVWF  2F
1BDE:  CALL   06C4
....................           lcd_putc("ERROR DE NUMERO");   //lo que se escribe 
1BE2:  CLRF   2C
1BE4:  MOVF   2C,W
1BE6:  CALL   054A
1BEA:  IORLW  00
1BEC:  BZ    1BF8
1BEE:  INCF   2C,F
1BF0:  MOVWF  2D
1BF2:  CALL   0720
1BF6:  BRA    1BE4
....................           delay_ms(3000); 
1BF8:  MOVLW  0C
1BFA:  MOVWF  2C
1BFC:  MOVLW  FA
1BFE:  MOVWF  2E
1C00:  CALL   05B8
1C04:  DECFSZ 2C,F
1C06:  BRA    1BFC
....................           goto menu; 
1C08:  GOTO   0DEC
....................       } 
....................      }else{ 
1C0C:  BRA    1C4C
....................           lcd_putc('\f');                 //Limpiar pantalla comando 
1C0E:  MOVLW  0C
1C10:  MOVWF  2D
1C12:  CALL   0720
....................           lcd_gotoxy(1,2);                //escribir en a primera fila primera posicion  
1C16:  MOVLW  01
1C18:  MOVWF  2E
1C1A:  MOVLW  02
1C1C:  MOVWF  2F
1C1E:  CALL   06C4
....................           lcd_putc("CONTRA. ERRONEA");   //lo que se escribe 
1C22:  CLRF   2C
1C24:  MOVF   2C,W
1C26:  CALL   0598
1C2A:  IORLW  00
1C2C:  BZ    1C38
1C2E:  INCF   2C,F
1C30:  MOVWF  2D
1C32:  CALL   0720
1C36:  BRA    1C24
....................           delay_ms(3000); 
1C38:  MOVLW  0C
1C3A:  MOVWF  2C
1C3C:  MOVLW  FA
1C3E:  MOVWF  2E
1C40:  CALL   05B8
1C44:  DECFSZ 2C,F
1C46:  BRA    1C3C
....................           goto menu; 
1C48:  GOTO   0DEC
....................      } 
....................    } 
....................  
1C4C:  SLEEP 

Configuration Fuses:
   Word  1: 0C00   NOIESO NOFCMEN HS PLL1 CPUDIV1 NOUSBDIV
   Word  2: 1E18   NOBROWNOUT NOWDT BORV20 PUT WDT32768 NOVREGEN
   Word  3: 0300   PBADEN CCP2C1 NOMCLR NOLPT1OSC
   Word  4: 0081   STVREN NODEBUG NOLVP NOXINST NOICPRT
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: E00F   NOWRT NOWRTD NOWRTC NOWRTB
   Word  7: 400F   NOEBTR NOEBTRB

ROM data:
F00000: 23 45 34 56 
