CCS PCH C Compiler, Version 4.093, 51109               23-oct.-21 10:44

               Filename: C:\Proyecto arquitectura c\Motor\Motor paso a paso.lst

               ROM used: 12168 bytes (37%)
                         Largest free fragment is 20600
               RAM used: 142 (7%) at main() level
                         159 (8%) worst case
               Stack:    6 locations

*
0000:  GOTO   18EC
.................... #include <18F4550.h> 
.................... //////// Standard Header file for the PIC18F4550 device //////////////// 
.................... #device PIC18F4550 
.................... #list 
....................  
.................... #fuses     HS,NOPROTECT,NOBROWNOUT,NOWDT,PUT,NOCPD,NODEBUG,NOLVP,NOMCLR 
.................... #use       delay(clock=20000000) 
*
071E:  CLRF   FEA
0720:  MOVLW  95
0722:  MOVWF  FE9
0724:  MOVF   FEF,W
0726:  BZ    0742
0728:  MOVLW  06
072A:  MOVWF  01
072C:  CLRF   00
072E:  DECFSZ 00,F
0730:  BRA    072E
0732:  DECFSZ 01,F
0734:  BRA    072C
0736:  MOVLW  7B
0738:  MOVWF  00
073A:  DECFSZ 00,F
073C:  BRA    073A
073E:  DECFSZ FEF,F
0740:  BRA    0728
0742:  RETLW  00
.................... #include   <stdlib.h>          //LIBRERIAS MATEMATICAS IGUAL LA DE ABAJO 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = TRUE, sign = FALSE, point = FALSE; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = FALSE; 
....................          if (c == '+') 
....................          { 
....................             sign = FALSE; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = TRUE; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = TRUE; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = TRUE, sign = FALSE, point = FALSE; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = FALSE; 
....................          if (c == '+') 
....................          { 
....................             sign = FALSE; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = TRUE; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = TRUE; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = TRUE, sign = FALSE, point = FALSE; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = FALSE; 
....................          if (c == '+') 
....................          { 
....................             sign = FALSE; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = TRUE; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = TRUE; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    BYTE t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=TRUE; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = FALSE; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include   <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float32)l); 
....................   res = 32768.0*(float32)l; 
....................   res += (float32)(unsigned int16)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float48)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float48)l); 
....................   res = 32768.0*(float32)l; 
....................   res += (float48)(unsigned int16)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float48)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float64)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float64)l); 
....................   res = 32768.0*(float64)l; 
....................   res += (float64)(unsigned int16)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float64)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y/LN2 - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y/LN2 - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y/LN2 - (float64)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {0.45145214, -9.0558803, 26.940971, -19.860189}; 
.................... float32 const ql[4] = {1.0000000,  -8.1354259, 16.780517, -9.9300943}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................    bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................       res = res*y2 + pl[2]; 
....................       res = res*y2 + pl[3]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + ql[2]; 
....................       r = r*y2 + ql[3]; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................     
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................    
....................       if(bit_test(data2,7)) 
....................          bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................       res = res*y2 + pl[2]; 
....................       res = res*y2 + pl[3]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + ql[2]; 
....................       r = r*y2 + ql[3]; 
....................  
....................       res = y*res/r; 
....................  
....................     data1 = *(((unsigned int8 *)(&x)+5)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+4)); 
....................     if(bit_test (data2,7)) 
....................        bit_set(data1,0); 
....................       
....................     n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................          r = -(float48)-n; 
....................       else 
....................          r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float32 const pl_64[4] = {0.45145214, -9.0558803, 26.940971, -19.860189}; 
.................... float32 const ql_64[4] = {1.0000000,  -8.1354259, 16.780517, -9.9300943}; 
.................... #endif 
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................       bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................     bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................    bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................      bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #define TWOBYPI          0.6366197723675813 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[4] = { 
....................       -0.499999993585, 
....................        0.041666636258, 
....................       -0.0013888361399, 
....................        0.00002476016134 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 3; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[4] = { 
....................       -0.499999993585, 
....................        0.041666636258, 
....................       -0.0013888361399, 
....................        0.00002476016134 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 3; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float48 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p[4] = { 
....................       -0.499999993585, 
....................        0.041666636258, 
....................       -0.0013888361399, 
....................        0.00002476016134 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 3; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #define   LCD_E    PIN_E2 
.................... #define   LCD_CK   PIN_E1 
.................... #define   LCD_DAT  PIN_E0 
.................... #include <LCD4x20_3PIN.c>       //libreria LCD 
.................... // flex_lcd_3_pins.c 
....................  
.................... //Modificacin de Flex_lcd por Duende_Azul y Akenafab 
.................... //Trabaja con 3 pines y 74VHC164 
.................... //8-Bit Serial-In, Parallel-Out Shift Register 
....................  
.................... //La LCD se usa en modo 4bits 
.................... //Revisar diagrama de conexion Adjunto 
....................  
.................... //No esta habilitada la lectura del LCD 
.................... //RW debe ir a gnd 
....................  
.................... //Definir pines antes de llamar libreria// 
.................... //#define LCD_E     PIN_A0 
.................... //#define LCD_CK    PIN_A1    
.................... //#define LCD_DAT   PIN_A2 
....................  
.................... //======================================== 
.................... int RS_bit; 
.................... #define lcd_type 2        // 0=5x7, 1=5x10, 2=2 lines 
.................... #define lcd_line_two 0x40 // LCD RAM address for the 2nd line 
....................  
....................  
.................... int8 const LCD_INIT_STRING[4] = 
.................... { 
....................  0x20 | (lcd_type << 2), // Func set: 4-bit, 2 lines, 5x8 dots 
....................  0xc,                    // Display on 
....................  1,                      // Clear display 
....................  6                       // Increment cursor 
....................  }; 
.................... BYTE lcdline; 
....................  
.................... //------------------------------------- 
.................... void lcd_send_nibble(int8 nibble, int rs_bit) 
.................... { 
....................  
.................... int x; 
.................... if(RS_bit==1) 
0744:  DECFSZ x9D,W
0746:  BRA    074A
....................    nibble=nibble|0x10; 
0748:  BSF    x9C.4
....................  
.................... for(x=0;x<5;x++){ 
074A:  CLRF   x9E
074C:  MOVF   x9E,W
074E:  SUBLW  04
0750:  BNC   0774
....................          output_bit(LCD_DAT,shift_right(&nibble,1,0)); 
0752:  BCF    FD8.0
0754:  RRCF   x9C,F
0756:  BC    075C
0758:  BCF    F8D.0
075A:  BRA    075E
075C:  BSF    F8D.0
075E:  BCF    F96.0
....................          delay_cycles(1); 
0760:  NOP   
....................          output_low(LCD_CK); 
0762:  BCF    F96.1
0764:  BCF    F8D.1
....................          delay_us(1); 
0766:  BRA    0768
0768:  BRA    076A
076A:  NOP   
....................          output_high(LCD_CK);} 
076C:  BCF    F96.1
076E:  BSF    F8D.1
0770:  INCF   x9E,F
0772:  BRA    074C
....................  
....................  
....................  
....................  output_high(LCD_E); 
0774:  BCF    F96.2
0776:  BSF    F8D.2
....................  delay_us(2); 
0778:  MOVLW  03
077A:  MOVWF  00
077C:  DECFSZ 00,F
077E:  BRA    077C
....................  output_low(LCD_E); 
0780:  BCF    F96.2
0782:  BCF    F8D.2
.................... } 
0784:  RETLW  00
....................  
.................... //----------------------------------- 
.................... //---------------------------------------- 
.................... // Send a byte to the LCD. 
.................... void lcd_send_byte(int8 address, int8 n) 
.................... { 
.................... //output_low(LCD_RS); 
.................... RS_bit=0; 
0786:  CLRF   0B
.................... delay_us(100); 
0788:  MOVLW  A6
078A:  MOVWF  00
078C:  DECFSZ 00,F
078E:  BRA    078C
0790:  NOP   
....................  
....................  
.................... if(address) 
0792:  MOVF   x99,F
0794:  BZ    079C
....................    //output_high(LCD_RS); 
....................    RS_bit=1; 
0796:  MOVLW  01
0798:  MOVWF  0B
.................... else 
079A:  BRA    079E
....................    //output_low(LCD_RS); 
....................    RS_bit=0; 
079C:  CLRF   0B
....................  
....................  delay_cycles(1); 
079E:  NOP   
....................  
....................  
.................... output_low(LCD_E); 
07A0:  BCF    F96.2
07A2:  BCF    F8D.2
....................  
.................... lcd_send_nibble(n >> 4,RS_bit); 
07A4:  SWAPF  x9A,W
07A6:  MOVWF  x9B
07A8:  MOVLW  0F
07AA:  ANDWF  x9B,F
07AC:  MOVFF  9B,9C
07B0:  MOVFF  0B,9D
07B4:  RCALL  0744
.................... lcd_send_nibble(n & 0xf,RS_bit); 
07B6:  MOVF   x9A,W
07B8:  ANDLW  0F
07BA:  MOVWF  x9B
07BC:  MOVWF  x9C
07BE:  MOVFF  0B,9D
07C2:  RCALL  0744
.................... } 
07C4:  RETLW  00
....................  
.................... //---------------------------- 
.................... void lcd_init(void) 
.................... { 
.................... int8 i; 
....................  
.................... //output_low(LCD_RS); 
.................... RS_bit=0; 
07C6:  CLRF   0B
....................  
.................... output_low(LCD_E); 
07C8:  BCF    F96.2
07CA:  BCF    F8D.2
....................  
.................... delay_ms(20); 
07CC:  MOVLW  14
07CE:  MOVWF  x95
07D0:  RCALL  071E
....................  
.................... for(i=0 ;i < 3; i++) 
07D2:  CLRF   x8D
07D4:  MOVF   x8D,W
07D6:  SUBLW  02
07D8:  BNC   07EE
....................    { 
....................     lcd_send_nibble(0x03,RS_bit); 
07DA:  MOVLW  03
07DC:  MOVWF  x9C
07DE:  MOVFF  0B,9D
07E2:  RCALL  0744
....................     delay_ms(5); 
07E4:  MOVLW  05
07E6:  MOVWF  x95
07E8:  RCALL  071E
....................    } 
07EA:  INCF   x8D,F
07EC:  BRA    07D4
....................  
.................... lcd_send_nibble(0x02,RS_bit); 
07EE:  MOVLW  02
07F0:  MOVWF  x9C
07F2:  MOVFF  0B,9D
07F6:  RCALL  0744
....................  
.................... for(i=0; i < sizeof(LCD_INIT_STRING); i++) 
07F8:  CLRF   x8D
07FA:  MOVF   x8D,W
07FC:  SUBLW  03
07FE:  BNC   0824
....................    { 
....................     lcd_send_byte(0, LCD_INIT_STRING[i]); 
0800:  CLRF   03
0802:  MOVF   x8D,W
0804:  MOVFF  FF2,8E
0808:  BCF    FF2.7
080A:  CALL   0004
080E:  BTFSC  x8E.7
0810:  BSF    FF2.7
0812:  MOVWF  x8E
0814:  CLRF   x99
0816:  MOVWF  x9A
0818:  RCALL  0786
....................  
....................     delay_ms(5); 
081A:  MOVLW  05
081C:  MOVWF  x95
081E:  RCALL  071E
....................      
....................    } 
0820:  INCF   x8D,F
0822:  BRA    07FA
....................  
.................... } 
0824:  GOTO   1A2C (RETURN)
....................  
.................... //---------------------------- 
....................  
.................... void lcd_gotoxy(int8 x, int8 y) 
.................... { 
.................... int8 address; 
....................  
....................    switch(y) { 
*
082C:  MOVLW  01
082E:  SUBWF  x96,W
0830:  ADDLW  FC
0832:  BC    0852
0834:  ADDLW  04
0836:  GOTO   0866
....................      case 1 : address=0x80;break; 
083A:  MOVLW  80
083C:  MOVWF  x97
083E:  BRA    0852
....................      case 2 : address=0xc0;break; 
0840:  MOVLW  C0
0842:  MOVWF  x97
0844:  BRA    0852
....................      case 3 : address=0x94;break; 
0846:  MOVLW  94
0848:  MOVWF  x97
084A:  BRA    0852
....................      case 4 : address=0xd4;break; 
084C:  MOVLW  D4
084E:  MOVWF  x97
0850:  BRA    0852
....................    } 
.................... address += x-1; 
0852:  MOVLW  01
0854:  SUBWF  x95,W
0856:  ADDWF  x97,F
.................... lcd_send_byte(0, 0x80 | address); 
0858:  MOVF   x97,W
085A:  IORLW  80
085C:  MOVWF  x98
085E:  CLRF   x99
0860:  MOVWF  x9A
0862:  RCALL  0786
.................... } 
0864:  RETLW  00
....................  
.................... //----------------------------- 
.................... void lcd_putc(char c) 
.................... { 
....................  switch(c) 
....................    { 
*
0888:  MOVF   x94,W
088A:  XORLW  0C
088C:  BZ    08A4
088E:  XORLW  06
0890:  BZ    08B8
0892:  XORLW  02
0894:  BZ    08C6
0896:  XORLW  6B
0898:  BZ    08D0
089A:  XORLW  04
089C:  BZ    08DA
089E:  XORLW  0F
08A0:  BZ    08E4
08A2:  BRA    08EE
....................     case '\f':                //limpia pantalla 
....................       lcd_send_byte(0,1); 
08A4:  CLRF   x99
08A6:  MOVLW  01
08A8:  MOVWF  x9A
08AA:  RCALL  0786
....................       lcdline=1; 
08AC:  MOVLW  01
08AE:  MOVWF  0C
....................       delay_ms(8); 
08B0:  MOVLW  08
08B2:  MOVWF  x95
08B4:  RCALL  071E
....................       break; 
08B6:  BRA    08FA
....................  
....................     case '\n':                //cambio de linea 
....................        lcd_gotoxy(1,++lcdline); 
08B8:  INCF   0C,F
08BA:  MOVLW  01
08BC:  MOVWF  x95
08BE:  MOVFF  0C,96
08C2:  RCALL  082C
....................        break; 
08C4:  BRA    08FA
....................  
....................     case '\b':                //retrocede 1 caracter 
....................        lcd_send_byte(0,0x10); 
08C6:  CLRF   x99
08C8:  MOVLW  10
08CA:  MOVWF  x9A
08CC:  RCALL  0786
....................        break; 
08CE:  BRA    08FA
....................         
....................     case '\c':                //on display 
....................     lcd_send_byte(0,0x0c); 
08D0:  CLRF   x99
08D2:  MOVLW  0C
08D4:  MOVWF  x9A
08D6:  RCALL  0786
....................     break; 
08D8:  BRA    08FA
....................     
....................     case '\g':                 
....................     lcd_send_byte(0,0x0f);    // prende cursor y parpadea 
08DA:  CLRF   x99
08DC:  MOVLW  0F
08DE:  MOVWF  x9A
08E0:  RCALL  0786
....................     break;   
08E2:  BRA    08FA
....................  
....................     case '\h':                //retrocede 1 caracter 
....................     lcd_send_byte(0,0x0f);    // prende cursor y parpadea 
08E4:  CLRF   x99
08E6:  MOVLW  0F
08E8:  MOVWF  x9A
08EA:  RCALL  0786
....................     break; 
08EC:  BRA    08FA
....................      
....................     default: 
....................        lcd_send_byte(1,c); 
08EE:  MOVLW  01
08F0:  MOVWF  x99
08F2:  MOVFF  94,9A
08F6:  RCALL  0786
....................        break; 
08F8:  BRA    08FA
....................    } 
.................... } 
08FA:  RETLW  00
....................  
.................... //------------------------------ 
....................  
.................... void lcd_cursor_vb(short visible, short blink) {  
....................   lcd_send_byte(0, 0xC|(visible<<1)|blink);  
.................... }  
....................  
....................  
.................... #include <KBD18F.c>             //LIBRERIA TECLADO 
.................... //////////////////////////////////////////////////////////////////////////////////// 
.................... //                                   KBD.C                                        // 
.................... //               FUNCIONES PARA ESCANEO DE UN TECLADO MATRICIAL                   // 
.................... //                         4X4 HEXADECIMAL, EN EL PORTB                           // 
.................... //       kbd_init()       Debe ser invocada antes que las otras funciones.         // 
.................... //       c=lcd_getc(c)    Si h sido presionada una tecla devuelve el caracter c    // 
.................... //                  y lo salva en el char c, sino se presiona una tecla       // 
.................... //                  retorna el valor /0, esta funcin puede invocarse         // 
.................... //                  frecuentemente para no perder teclas pulsadas.            // 
.................... //        NOTA: REQUIERE COLOCAR RESISTENCIAS (2.2K) EN LOS PINES DE COLUMNAS     // 
.................... //               PINES DE COLUMNAS DE RB0(COL0) A RB3(COL3))                   // 
.................... //               PINES DE FILAS DE RB4(ROW0)) A RB7(ROW3))                    //  
.................... //                  MODIF.: ING. FRANK GIRALDO - UD                       // 
.................... //////////////////////////////////////////////////////////////////////////////////// 
.................... /*//////////////////////////////////////////////////////////////////////////////////  
.................... *    RB0 RB1 RB2 RB3    
.................... *     |   |   |   | 
.................... *     c0  c1  c2  c3   
.................... *   | 1 | 2 | 3 | F | r0 - RB4 
.................... *   | 4 | 5 | 6 | E | r1 - RB5 
.................... *   | 7 | 8 | 9 | D | r2 - RB6 
.................... *   | A | 0 | B | C | r3 - RB7 
.................... * 
.................... *   COLUMNS=OUTs 
.................... *   ROWS=INs 
.................... *   SE HABILITAN PULL-UP INTERNAS  
.................... *   SE REQUIERE COLOCAR RESISTENCIAS (2.2K) EN LOS PINES DE COLUMNAS  
.................... * 
.................... */////////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... #byte portkbd = 0XF81                  //portkbd = portB 
.................... //Keypad connection:   (Column 0 es B0) 
.................... //                Bx: 
.................... #define COL0 (0 << 0) 
.................... #define COL1 (0 << 1) 
.................... #define COL2 (0 << 2) 
.................... #define COL3 (0 << 3) 
.................... #define ROW0 (1 << 4) 
.................... #define ROW1 (1 << 5) 
.................... #define ROW2 (1 << 6) 
.................... #define ROW3 (1 << 7) 
.................... #define ALL_ROWS (ROW3|ROW2|ROW1|ROW0) 
.................... #define ALL_PINS (ALL_ROWS|COL3|COL2|COL1|COL0) 
....................  
.................... char const KEYS[4][4] = {{'1','2','3','A'}, 
....................                          {'4','5','6','B'}, 
....................                          {'7','8','9','C'}, 
....................                          {'*','0','#','D'}}; 
....................  
.................... #define KBD_DEBOUNCE_FACTOR 0.2 
.................... // Modifique el valor de temporizacin antirrebote con (KBD_DEBOUNCE_FACTOR = n/333), 
.................... // en donde n es el nmero de veces por segundo en los que ud. invoca 
.................... //la funcin kbd_getc(). 
.................... // 
....................  
.................... void kbd_init(){ 
.................... } 
*
0828:  GOTO   1A30 (RETURN)
....................  
.................... char kbd_getc( ) 
.................... { 
....................    static BYTE kbd_call_count; 
....................    static short int kbd_down; 
....................    static char last_key; 
....................    static BYTE col; 
....................    BYTE kchar; 
....................    BYTE row; 
....................    port_b_pullups(TRUE); 
*
0B8E:  BCF    FF1.7
....................    kchar='\0'; 
0B90:  CLRF   x8D
....................  
....................    if(++kbd_call_count>KBD_DEBOUNCE_FACTOR) 
0B92:  INCF   0D,F
0B94:  CLRF   x90
0B96:  MOVFF  0D,8F
0B9A:  RCALL  0AE2
0B9C:  MOVLW  CD
0B9E:  MOVWF  x92
0BA0:  MOVLW  CC
0BA2:  MOVWF  x91
0BA4:  MOVLW  4C
0BA6:  MOVWF  x90
0BA8:  MOVLW  7C
0BAA:  MOVWF  x8F
0BAC:  MOVFF  03,96
0BB0:  MOVFF  02,95
0BB4:  MOVFF  01,94
0BB8:  MOVFF  00,93
0BBC:  RCALL  0B18
0BBE:  BNC   0C76
....................    { 
....................        switch (col) 
....................        { 
0BC0:  MOVF   10,W
0BC2:  ADDLW  FC
0BC4:  BC    0BF4
0BC6:  ADDLW  04
0BC8:  GOTO   0C84
....................          case 0   : set_tris_b(ALL_PINS&~COL0); 
0BCC:  MOVLW  F0
0BCE:  MOVWF  F93
....................                     portkbd=(0b1110); 
0BD0:  MOVLW  0E
0BD2:  MOVWF  F81
....................                     break; 
0BD4:  BRA    0BF4
....................  
....................          case 1   : set_tris_b(ALL_PINS&~COL1); 
0BD6:  MOVLW  F0
0BD8:  MOVWF  F93
....................                     portkbd=(0b1101); 
0BDA:  MOVLW  0D
0BDC:  MOVWF  F81
....................                     break; 
0BDE:  BRA    0BF4
....................  
....................          case 2   : set_tris_b(ALL_PINS&~COL2); 
0BE0:  MOVLW  F0
0BE2:  MOVWF  F93
....................                     portkbd=(0b1011); 
0BE4:  MOVLW  0B
0BE6:  MOVWF  F81
....................                     break; 
0BE8:  BRA    0BF4
....................  
....................          case 3   : set_tris_b(ALL_PINS&~COL3); 
0BEA:  MOVLW  F0
0BEC:  MOVWF  F93
....................                     portkbd=(0b0111); 
0BEE:  MOVLW  07
0BF0:  MOVWF  F81
....................                     break; 
0BF2:  BRA    0BF4
....................        } 
....................  
....................        if(kbd_down) 
0BF4:  BTFSS  0E.0
0BF6:  BRA    0C0A
....................        { 
....................          if((portkbd & (ALL_ROWS))==(ALL_ROWS)) 
0BF8:  MOVF   F81,W
0BFA:  ANDLW  F0
0BFC:  SUBLW  F0
0BFE:  BNZ   0C08
....................          { 
....................            kbd_down=FALSE; 
0C00:  BCF    0E.0
....................            kchar=last_key; 
0C02:  MOVFF  0F,8D
....................            last_key='\0'; 
0C06:  CLRF   0F
....................          } 
....................        } 
....................        else 
0C08:  BRA    0C74
....................        { 
....................           if((portkbd & (ALL_ROWS))!=(ALL_ROWS)) 
0C0A:  MOVF   F81,W
0C0C:  ANDLW  F0
0C0E:  SUBLW  F0
0C10:  BZ    0C6A
....................           { 
....................              if((portkbd & ROW0) == 0) 
0C12:  MOVF   F81,W
0C14:  ANDLW  10
0C16:  BNZ   0C1C
....................                row = 0; 
0C18:  CLRF   x8E
....................              else if((portkbd & ROW1) == 0) 
0C1A:  BRA    0C3E
0C1C:  MOVF   F81,W
0C1E:  ANDLW  20
0C20:  BNZ   0C28
....................                row = 1; 
0C22:  MOVLW  01
0C24:  MOVWF  x8E
....................              else if((portkbd & ROW2) == 0) 
0C26:  BRA    0C3E
0C28:  MOVF   F81,W
0C2A:  ANDLW  40
0C2C:  BNZ   0C34
....................                row = 2; 
0C2E:  MOVLW  02
0C30:  MOVWF  x8E
....................              else if((portkbd & ROW3) == 0) 
0C32:  BRA    0C3E
0C34:  MOVF   F81,W
0C36:  ANDLW  80
0C38:  BNZ   0C3E
....................                row = 3; 
0C3A:  MOVLW  03
0C3C:  MOVWF  x8E
....................              last_key = KEYS[row][col]; 
0C3E:  MOVF   x8E,W
0C40:  MULLW  04
0C42:  MOVF   FF3,W
0C44:  CLRF   x90
0C46:  MOVWF  x8F
0C48:  CLRF   03
0C4A:  MOVF   10,W
0C4C:  ADDWF  x8F,W
0C4E:  MOVWF  01
0C50:  MOVF   x90,W
0C52:  ADDWFC 03,F
0C54:  MOVF   01,W
0C56:  MOVFF  FF2,8F
0C5A:  BCF    FF2.7
0C5C:  CALL   0018
0C60:  BTFSC  x8F.7
0C62:  BSF    FF2.7
0C64:  MOVWF  0F
....................              kbd_down = TRUE; 
0C66:  BSF    0E.0
....................           } 
....................           else 
0C68:  BRA    0C74
....................           { 
....................              ++col; 
0C6A:  INCF   10,F
....................              if(col==4) 
0C6C:  MOVF   10,W
0C6E:  SUBLW  04
0C70:  BNZ   0C74
....................              col=0; 
0C72:  CLRF   10
....................           } 
....................        } 
....................       kbd_call_count=0; 
0C74:  CLRF   0D
....................    } 
....................   kchar = last_key; 
0C76:  MOVFF  0F,8D
....................   set_tris_b(ALL_PINS); 
0C7A:  MOVLW  F0
0C7C:  MOVWF  F93
....................   return(kchar); 
0C7E:  MOVFF  8D,01
.................... } 
0C82:  RETLW  00
....................  
.................... /*char dato; 
.................... char tecla() 
.................... { 
....................    dato='\0'; 
....................    while(dato=='\0') 
....................    { 
....................       dato=kbd_getc(); 
....................       delay_ms(100); 
....................    } 
.................... return dato; 
.................... } */ 
....................  
.................... #include <DS1307A.c>            //LIBRERIA RELOJ 
.................... /////////////////////////////////////////////////////////////////////////////////////// 
.................... ///                               DS1307.C                                           /// 
.................... ///                     Driver for Real Time Clock                                   /// 
.................... ///                     modified by Redpic 08/2006                                   /// 
.................... ///                  http://picmania.garcia-cuervo.com                               /// 
.................... ///                                                                                  /// 
.................... /// void ds1307_init(val)                                                            /// 
.................... ///                  - Enable oscillator without clearing the seconds register       /// 
.................... ///                    used when PIC loses power and DS1307 run from 3V BAT          /// 
.................... ///                  - Config Control Register with next parameters:                 /// 
.................... ///                     DS1307_ALL_DISABLED          All disabled                    /// 
.................... ///                     DS1307_OUT_ON_DISABLED_HIHG  Out to Hight on Disable Out     /// 
.................... ///                     DS1307_OUT_ENABLED           Out Enabled                     /// 
.................... ///                     DS1307_OUT_1_HZ              Freq. Out to 1 Hz               /// 
.................... ///                     DS1307_OUT_4_KHZ             Freq. Out to 4.096 Khz          /// 
.................... ///                     DS1307_OUT_8_KHZ             Freq. Out to 8.192 Khz          /// 
.................... ///                     DS1307_OUT_32_KHZ            Freq. Out to 32.768 Khz         /// 
.................... ///                                                                                  /// 
.................... ///                     Example init:                                                /// 
.................... ///                     ds1307_init(DS1307_ALL_DISABLED);                            /// 
.................... ///                     ds1307_init(DS1307_OUT_ENABLED | DS1307_OUT_1_HZ);           /// 
.................... ///                                                                                  /// 
.................... /// void ds1307_set_date_time(day,mth,year,dow,hour,min,sec) - Set the date/time     /// 
.................... ///                                                                                  /// 
.................... /// void ds1307_get_date(day,mth,year,dow)                   - Get the date          /// 
.................... ///                                                                                  /// 
.................... /// void ds1307_get_time(hr,min,sec)                         - Get the time          /// 
.................... ///                                                                                  /// 
.................... /// char ds1307_read_nvram_byte(char addr)                   - Read byte in address  /// 
.................... ///                                                                                  /// 
.................... /// void ds1307_write_nvram_byte(char addr, char value)      - Write byte in address /// 
.................... ///                                                                                  /// 
.................... /// void ds1307_get_day_of_week(char* ptr)                   - Get string Day Of Week/// 
.................... ///                                                                                  /// 
.................... /// If defined USE_INTERRUPTS all functions disable Global Interrupts on starts and  /// 
.................... ///                           enable Global on ends else usar can do it hiself       /// 
.................... ///                                                                                  /// 
.................... /////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef RTC_SDA 
.................... #define RTC_SDA  PIN_A3 
.................... #define RTC_SCL  PIN_A2 
.................... #endif 
....................  
.................... #use i2c(master, sda=RTC_SDA, scl=RTC_SCL) 
*
0FCE:  MOVLW  08
0FD0:  MOVWF  01
0FD2:  MOVLW  05
0FD4:  MOVWF  00
0FD6:  DECFSZ 00,F
0FD8:  BRA    0FD6
0FDA:  BCF    F89.2
0FDC:  BCF    F92.2
0FDE:  MOVLW  06
0FE0:  MOVWF  00
0FE2:  DECFSZ 00,F
0FE4:  BRA    0FE2
0FE6:  RLCF   x91,F
0FE8:  BCF    F89.3
0FEA:  BTFSC  FD8.0
0FEC:  BSF    F92.3
0FEE:  BTFSS  FD8.0
0FF0:  BCF    F92.3
0FF2:  BSF    F92.2
0FF4:  BTFSS  F80.2
0FF6:  BRA    0FF4
0FF8:  DECFSZ 01,F
0FFA:  BRA    0FD2
0FFC:  MOVLW  05
0FFE:  MOVWF  00
1000:  DECFSZ 00,F
1002:  BRA    1000
1004:  BCF    F89.2
1006:  BCF    F92.2
1008:  NOP   
100A:  BSF    F92.3
100C:  MOVLW  06
100E:  MOVWF  00
1010:  DECFSZ 00,F
1012:  BRA    1010
1014:  MOVLW  06
1016:  MOVWF  00
1018:  DECFSZ 00,F
101A:  BRA    1018
101C:  BSF    F92.2
101E:  BTFSS  F80.2
1020:  BRA    101E
1022:  CLRF   01
1024:  MOVLW  06
1026:  MOVWF  00
1028:  DECFSZ 00,F
102A:  BRA    1028
102C:  BTFSC  F80.3
102E:  BSF    01.0
1030:  BCF    F89.2
1032:  BCF    F92.2
1034:  BCF    F89.3
1036:  BCF    F92.3
1038:  RETLW  00
103A:  MOVLW  08
103C:  MOVWF  x92
103E:  MOVFF  00,93
1042:  BSF    F92.3
1044:  MOVLW  06
1046:  MOVWF  00
1048:  DECFSZ 00,F
104A:  BRA    1048
104C:  BSF    F92.2
104E:  BTFSS  F80.2
1050:  BRA    104E
1052:  BTFSC  F80.3
1054:  BSF    FD8.0
1056:  BTFSS  F80.3
1058:  BCF    FD8.0
105A:  RLCF   01,F
105C:  MOVLW  05
105E:  MOVWF  00
1060:  DECFSZ 00,F
1062:  BRA    1060
1064:  BCF    F92.2
1066:  BCF    F89.2
1068:  DECFSZ x92,F
106A:  BRA    1042
106C:  BSF    F92.3
106E:  MOVLW  06
1070:  MOVWF  00
1072:  DECFSZ 00,F
1074:  BRA    1072
1076:  BCF    F89.3
1078:  MOVF   x93,W
107A:  BTFSS  FD8.2
107C:  BCF    F92.3
107E:  NOP   
1080:  BSF    F92.2
1082:  BTFSS  F80.2
1084:  BRA    1082
1086:  MOVLW  05
1088:  MOVWF  00
108A:  DECFSZ 00,F
108C:  BRA    108A
108E:  BCF    F89.2
1090:  BCF    F92.2
1092:  MOVLW  06
1094:  MOVWF  00
1096:  DECFSZ 00,F
1098:  BRA    1096
109A:  BCF    F89.3
109C:  BCF    F92.3
109E:  RETLW  00
....................  
.................... #define DS1307_ALL_DISABLED         0b00000000 // All disabled 
.................... #define DS1307_OUT_ON_DISABLED_HIHG 0b10000000 // Out to Hight on Disable Out 
.................... #define DS1307_OUT_ENABLED          0b00010000 // Out Enabled 
.................... #define DS1307_OUT_1_HZ             0b00000000 // Freq. Out to 1 Hz 
.................... #define DS1307_OUT_4_KHZ            0b00000001 // Freq. Out to 4.096 Khz 
.................... #define DS1307_OUT_8_KHZ            0b00000010 // Freq. Out to 8.192 Khz 
.................... #define DS1307_OUT_32_KHZ           0b00000011 // Freq. Out to 32.768 Khz 
....................  
.................... #define Start_user_address_nvram    0x08 
.................... #define End_user_address_nvram      0x3f 
....................  
.................... char days_of_week[7][11]={"Lunes\0","Martes\0","Mircoles\0","Jueves\0","Viernes\0","Sbado\0","Domingo\0"}; 
....................  
.................... byte ds1307_bin2bcd(byte binary_value); 
.................... byte ds1307_bcd2bin(byte bcd_value); 
....................  
.................... void ds1307_init(int val){ 
....................  
....................    byte seconds = 0; 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    disable_interrupts(global); 
.................... #endif 
....................  
....................    i2c_start(); 
....................    i2c_write(0xD0); 
....................    i2c_write(0x00); 
....................    i2c_start(); 
....................    i2c_write(0xD1); 
....................    seconds = ds1307_bcd2bin(i2c_read(0)); 
....................    i2c_stop(); 
....................    seconds &= 0x7F; 
....................  
....................    delay_us(3); 
....................  
....................    i2c_start(); 
....................    i2c_write(0xD0); 
....................    i2c_write(0x00); 
....................    i2c_write(ds1307_bin2bcd(seconds)); 
....................    i2c_start(); 
....................    i2c_write(0xD0); 
....................    i2c_write(0x07); 
....................    i2c_write(val); 
....................    i2c_stop(); 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    enable_interrupts(global); 
.................... #endif 
....................  
.................... } 
....................  
.................... void ds1307_set_date_time(byte day, byte mth, byte year, byte dow, byte hr, byte min, byte sec){ 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    disable_interrupts(global); 
.................... #endif 
....................  
....................   sec &= 0x7F; 
....................   hr &= 0x3F; 
....................  
....................   i2c_start(); 
....................   i2c_write(0xD0); 
....................   i2c_write(0x00); 
....................   i2c_write(ds1307_bin2bcd(sec)); 
....................   i2c_write(ds1307_bin2bcd(min)); 
....................   i2c_write(ds1307_bin2bcd(hr)); 
....................   i2c_write(ds1307_bin2bcd(dow)); 
....................   i2c_write(ds1307_bin2bcd(day)); 
....................   i2c_write(ds1307_bin2bcd(mth)); 
....................   i2c_write(ds1307_bin2bcd(year)); 
....................   i2c_stop(); 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    enable_interrupts(global); 
.................... #endif 
....................  
.................... } 
....................  
.................... void ds1307_get_date(byte &day, byte &mth, byte &year, byte &dow){ 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    disable_interrupts(global); 
*
11BE:  BCF    FF2.6
11C0:  BCF    FF2.7
11C2:  BTFSC  FF2.7
11C4:  BRA    11C0
*
14E6:  BCF    FF2.6
14E8:  BCF    FF2.7
14EA:  BTFSC  FF2.7
14EC:  BRA    14E8
.................... #endif 
....................  
....................   i2c_start(); 
*
11C6:  BSF    F92.3
11C8:  MOVLW  05
11CA:  MOVWF  00
11CC:  DECFSZ 00,F
11CE:  BRA    11CC
11D0:  BSF    F92.2
11D2:  MOVLW  06
11D4:  MOVWF  00
11D6:  DECFSZ 00,F
11D8:  BRA    11D6
11DA:  BCF    F89.3
11DC:  BCF    F92.3
11DE:  MOVLW  05
11E0:  MOVWF  00
11E2:  DECFSZ 00,F
11E4:  BRA    11E2
11E6:  BCF    F89.2
11E8:  BCF    F92.2
*
14EE:  BSF    F92.3
14F0:  MOVLW  05
14F2:  MOVWF  00
14F4:  DECFSZ 00,F
14F6:  BRA    14F4
14F8:  BSF    F92.2
14FA:  MOVLW  06
14FC:  MOVWF  00
14FE:  DECFSZ 00,F
1500:  BRA    14FE
1502:  BCF    F89.3
1504:  BCF    F92.3
1506:  MOVLW  05
1508:  MOVWF  00
150A:  DECFSZ 00,F
150C:  BRA    150A
150E:  BCF    F89.2
1510:  BCF    F92.2
....................   i2c_write(0xD0); 
*
11EA:  MOVLW  D0
11EC:  MOVWF  x91
11EE:  RCALL  0FCE
*
1512:  MOVLW  D0
1514:  MOVWF  x91
1516:  RCALL  0FCE
....................   i2c_write(0x03); 
*
11F0:  MOVLW  03
11F2:  MOVWF  x91
11F4:  RCALL  0FCE
*
1518:  MOVLW  03
151A:  MOVWF  x91
151C:  RCALL  0FCE
....................   i2c_start(); 
*
11F6:  BSF    F92.3
11F8:  MOVLW  05
11FA:  MOVWF  00
11FC:  DECFSZ 00,F
11FE:  BRA    11FC
1200:  BSF    F92.2
1202:  MOVLW  06
1204:  MOVWF  00
1206:  DECFSZ 00,F
1208:  BRA    1206
120A:  BTFSS  F80.2
120C:  BRA    120A
120E:  BCF    F89.3
1210:  BCF    F92.3
1212:  MOVLW  05
1214:  MOVWF  00
1216:  DECFSZ 00,F
1218:  BRA    1216
121A:  BCF    F89.2
121C:  BCF    F92.2
*
151E:  BSF    F92.3
1520:  MOVLW  05
1522:  MOVWF  00
1524:  DECFSZ 00,F
1526:  BRA    1524
1528:  BSF    F92.2
152A:  MOVLW  06
152C:  MOVWF  00
152E:  DECFSZ 00,F
1530:  BRA    152E
1532:  BTFSS  F80.2
1534:  BRA    1532
1536:  BCF    F89.3
1538:  BCF    F92.3
153A:  MOVLW  05
153C:  MOVWF  00
153E:  DECFSZ 00,F
1540:  BRA    153E
1542:  BCF    F89.2
1544:  BCF    F92.2
....................   i2c_write(0xD1); 
*
121E:  MOVLW  D1
1220:  MOVWF  x91
1222:  RCALL  0FCE
*
1546:  MOVLW  D1
1548:  MOVWF  x91
154A:  RCALL  0FCE
....................   dow  = ds1307_bcd2bin(i2c_read() & 0x7f); 
*
1224:  MOVLW  01
1226:  MOVWF  00
1228:  RCALL  103A
122A:  MOVF   01,W
122C:  ANDLW  7F
122E:  MOVWF  x8D
1230:  MOVWF  x92
1232:  RCALL  10A0
1234:  MOVFF  01,89
*
154C:  MOVLW  01
154E:  MOVWF  00
1550:  RCALL  103A
1552:  MOVF   01,W
1554:  ANDLW  7F
1556:  MOVWF  x8D
1558:  MOVWF  x92
155A:  RCALL  10A0
155C:  MOVFF  01,81
....................   day  = ds1307_bcd2bin(i2c_read() & 0x3f); 
*
1238:  MOVLW  01
123A:  MOVWF  00
123C:  RCALL  103A
123E:  MOVF   01,W
1240:  ANDLW  3F
1242:  MOVWF  x8D
1244:  MOVWF  x92
1246:  RCALL  10A0
1248:  MOVFF  01,86
*
1560:  MOVLW  01
1562:  MOVWF  00
1564:  RCALL  103A
1566:  MOVF   01,W
1568:  ANDLW  3F
156A:  MOVWF  x8D
156C:  MOVWF  x92
156E:  RCALL  10A0
1570:  MOVFF  01,7E
....................   mth  = ds1307_bcd2bin(i2c_read() & 0x1f); 
*
124C:  MOVLW  01
124E:  MOVWF  00
1250:  RCALL  103A
1252:  MOVF   01,W
1254:  ANDLW  1F
1256:  MOVWF  x8D
1258:  MOVWF  x92
125A:  RCALL  10A0
125C:  MOVFF  01,87
*
1574:  MOVLW  01
1576:  MOVWF  00
1578:  RCALL  103A
157A:  MOVF   01,W
157C:  ANDLW  1F
157E:  MOVWF  x8D
1580:  MOVWF  x92
1582:  RCALL  10A0
1584:  MOVFF  01,7F
....................   year = ds1307_bcd2bin(i2c_read(0)); 
*
1260:  CLRF   00
1262:  RCALL  103A
1264:  MOVFF  01,8D
1268:  MOVFF  01,92
126C:  RCALL  10A0
126E:  MOVFF  01,88
*
1588:  CLRF   00
158A:  RCALL  103A
158C:  MOVFF  01,8D
1590:  MOVFF  01,92
1594:  RCALL  10A0
1596:  MOVFF  01,80
....................   i2c_stop(); 
*
1272:  BCF    F92.3
1274:  NOP   
1276:  BSF    F92.2
1278:  BTFSS  F80.2
127A:  BRA    1278
127C:  MOVLW  05
127E:  MOVWF  00
1280:  DECFSZ 00,F
1282:  BRA    1280
1284:  BRA    1286
1286:  NOP   
1288:  BSF    F92.3
128A:  MOVLW  05
128C:  MOVWF  00
128E:  DECFSZ 00,F
1290:  BRA    128E
*
159A:  BCF    F92.3
159C:  NOP   
159E:  BSF    F92.2
15A0:  BTFSS  F80.2
15A2:  BRA    15A0
15A4:  MOVLW  05
15A6:  MOVWF  00
15A8:  DECFSZ 00,F
15AA:  BRA    15A8
15AC:  BRA    15AE
15AE:  NOP   
15B0:  BSF    F92.3
15B2:  MOVLW  05
15B4:  MOVWF  00
15B6:  DECFSZ 00,F
15B8:  BRA    15B6
....................  
.................... #ifndef USE_INTERRUPTS 
....................    enable_interrupts(global); 
*
1292:  MOVLW  C0
1294:  IORWF  FF2,F
*
15BA:  MOVLW  C0
15BC:  IORWF  FF2,F
.................... #endif 
....................  
.................... } 
....................  
.................... void ds1307_get_time(byte &hr, byte &min, byte &sec){ 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    disable_interrupts(global); 
*
1326:  BCF    FF2.6
1328:  BCF    FF2.7
132A:  BTFSC  FF2.7
132C:  BRA    1328
*
15BE:  BCF    FF2.6
15C0:  BCF    FF2.7
15C2:  BTFSC  FF2.7
15C4:  BRA    15C0
.................... #endif 
....................  
....................   i2c_start(); 
*
132E:  BSF    F92.3
1330:  MOVLW  05
1332:  MOVWF  00
1334:  DECFSZ 00,F
1336:  BRA    1334
1338:  BSF    F92.2
133A:  MOVLW  06
133C:  MOVWF  00
133E:  DECFSZ 00,F
1340:  BRA    133E
1342:  BCF    F89.3
1344:  BCF    F92.3
1346:  MOVLW  05
1348:  MOVWF  00
134A:  DECFSZ 00,F
134C:  BRA    134A
134E:  BCF    F89.2
1350:  BCF    F92.2
*
15C6:  BSF    F92.3
15C8:  MOVLW  05
15CA:  MOVWF  00
15CC:  DECFSZ 00,F
15CE:  BRA    15CC
15D0:  BSF    F92.2
15D2:  MOVLW  06
15D4:  MOVWF  00
15D6:  DECFSZ 00,F
15D8:  BRA    15D6
15DA:  BCF    F89.3
15DC:  BCF    F92.3
15DE:  MOVLW  05
15E0:  MOVWF  00
15E2:  DECFSZ 00,F
15E4:  BRA    15E2
15E6:  BCF    F89.2
15E8:  BCF    F92.2
....................   i2c_write(0xD0); 
*
1352:  MOVLW  D0
1354:  MOVWF  x91
1356:  RCALL  0FCE
*
15EA:  MOVLW  D0
15EC:  MOVWF  x91
15EE:  RCALL  0FCE
....................   i2c_write(0x00); 
*
1358:  CLRF   x91
135A:  RCALL  0FCE
*
15F0:  CLRF   x91
15F2:  RCALL  0FCE
....................   i2c_start(); 
*
135C:  BSF    F92.3
135E:  MOVLW  05
1360:  MOVWF  00
1362:  DECFSZ 00,F
1364:  BRA    1362
1366:  BSF    F92.2
1368:  MOVLW  06
136A:  MOVWF  00
136C:  DECFSZ 00,F
136E:  BRA    136C
1370:  BTFSS  F80.2
1372:  BRA    1370
1374:  BCF    F89.3
1376:  BCF    F92.3
1378:  MOVLW  05
137A:  MOVWF  00
137C:  DECFSZ 00,F
137E:  BRA    137C
1380:  BCF    F89.2
1382:  BCF    F92.2
*
15F4:  BSF    F92.3
15F6:  MOVLW  05
15F8:  MOVWF  00
15FA:  DECFSZ 00,F
15FC:  BRA    15FA
15FE:  BSF    F92.2
1600:  MOVLW  06
1602:  MOVWF  00
1604:  DECFSZ 00,F
1606:  BRA    1604
1608:  BTFSS  F80.2
160A:  BRA    1608
160C:  BCF    F89.3
160E:  BCF    F92.3
1610:  MOVLW  05
1612:  MOVWF  00
1614:  DECFSZ 00,F
1616:  BRA    1614
1618:  BCF    F89.2
161A:  BCF    F92.2
....................   i2c_write(0xD1); 
*
1384:  MOVLW  D1
1386:  MOVWF  x91
1388:  RCALL  0FCE
*
161C:  MOVLW  D1
161E:  MOVWF  x91
1620:  RCALL  0FCE
....................   sec = ds1307_bcd2bin(i2c_read() & 0x7f); 
*
138A:  MOVLW  01
138C:  MOVWF  00
138E:  RCALL  103A
1390:  MOVF   01,W
1392:  ANDLW  7F
1394:  MOVWF  x8D
1396:  MOVWF  x92
1398:  RCALL  10A0
139A:  MOVFF  01,85
*
1622:  MOVLW  01
1624:  MOVWF  00
1626:  RCALL  103A
1628:  MOVF   01,W
162A:  ANDLW  7F
162C:  MOVWF  x8D
162E:  MOVWF  x92
1630:  RCALL  10A0
1632:  MOVFF  01,82
....................   min = ds1307_bcd2bin(i2c_read() & 0x7f); 
*
139E:  MOVLW  01
13A0:  MOVWF  00
13A2:  RCALL  103A
13A4:  MOVF   01,W
13A6:  ANDLW  7F
13A8:  MOVWF  x8D
13AA:  MOVWF  x92
13AC:  RCALL  10A0
13AE:  MOVFF  01,84
*
1636:  MOVLW  01
1638:  MOVWF  00
163A:  RCALL  103A
163C:  MOVF   01,W
163E:  ANDLW  7F
1640:  MOVWF  x8D
1642:  MOVWF  x92
1644:  RCALL  10A0
1646:  MOVFF  01,7D
....................   hr  = ds1307_bcd2bin(i2c_read(0) & 0x3f); 
*
13B2:  CLRF   00
13B4:  RCALL  103A
13B6:  MOVF   01,W
13B8:  ANDLW  3F
13BA:  MOVWF  x8D
13BC:  MOVWF  x92
13BE:  RCALL  10A0
13C0:  MOVFF  01,83
*
164A:  CLRF   00
164C:  RCALL  103A
164E:  MOVF   01,W
1650:  ANDLW  3F
1652:  MOVWF  x8D
1654:  MOVWF  x92
1656:  RCALL  10A0
1658:  MOVFF  01,7C
....................   i2c_stop(); 
*
13C4:  BCF    F92.3
13C6:  NOP   
13C8:  BSF    F92.2
13CA:  BTFSS  F80.2
13CC:  BRA    13CA
13CE:  MOVLW  05
13D0:  MOVWF  00
13D2:  DECFSZ 00,F
13D4:  BRA    13D2
13D6:  BRA    13D8
13D8:  NOP   
13DA:  BSF    F92.3
13DC:  MOVLW  05
13DE:  MOVWF  00
13E0:  DECFSZ 00,F
13E2:  BRA    13E0
*
165C:  BCF    F92.3
165E:  NOP   
1660:  BSF    F92.2
1662:  BTFSS  F80.2
1664:  BRA    1662
1666:  MOVLW  05
1668:  MOVWF  00
166A:  DECFSZ 00,F
166C:  BRA    166A
166E:  BRA    1670
1670:  NOP   
1672:  BSF    F92.3
1674:  MOVLW  05
1676:  MOVWF  00
1678:  DECFSZ 00,F
167A:  BRA    1678
....................  
.................... #ifndef USE_INTERRUPTS 
....................    enable_interrupts(global); 
*
13E4:  MOVLW  C0
13E6:  IORWF  FF2,F
*
167C:  MOVLW  C0
167E:  IORWF  FF2,F
.................... #endif 
....................  
.................... } 
....................  
....................  
.................... char ds1307_read_nvram_byte(char addr){ 
....................  
....................    char retval; 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    disable_interrupts(global); 
.................... #endif 
....................  
....................    i2c_start(); 
....................    i2c_write(0xD0); 
....................    i2c_write(addr); 
....................  
....................    i2c_start(); 
....................    i2c_write(0xD1); 
....................    retval = i2c_read(0); 
....................    i2c_stop(); 
....................  
....................    return(retval); 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    enable_interrupts(global); 
.................... #endif 
....................  
.................... } 
....................  
.................... void ds1307_write_nvram_byte(char addr, char value){ 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    disable_interrupts(global); 
.................... #endif 
....................  
....................    i2c_start(); 
....................    i2c_write(0xD0); 
....................    i2c_write(addr); 
....................    i2c_write(value); 
....................    i2c_stop(); 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    enable_interrupts(global); 
.................... #endif 
....................  
.................... } 
....................  
.................... void ds1307_get_day_of_week(char* ptr){ 
....................  
....................    byte lday; 
....................    byte lmonth; 
....................    byte lyr; 
....................    byte ldow; 
....................    ds1307_get_date(lday,lmonth,lyr,ldow); 
....................    sprintf(ptr,"%s",days_of_week[ldow]); 
.................... } 
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
....................  
.................... byte ds1307_bin2bcd(byte binary_value){ 
....................  
....................   byte temp; 
....................   byte retval; 
....................  
....................   temp = binary_value; 
....................   retval = 0; 
....................   while(1){ 
....................     if(temp >= 10){ 
....................       temp -= 10; 
....................       retval += 0x10; 
....................     }else{ 
....................       retval += temp; 
....................       break; 
....................     } 
....................   } 
....................   return(retval); 
.................... } 
....................  
.................... byte ds1307_bcd2bin(byte bcd_value){ 
....................  
....................   byte temp; 
....................  
....................   temp = bcd_value; 
*
10A0:  MOVFF  92,93
....................   temp >>= 1; 
10A4:  BCF    FD8.0
10A6:  RRCF   x93,F
....................   temp &= 0x78; 
10A8:  MOVLW  78
10AA:  ANDWF  x93,F
....................   return(temp + (temp >> 2) + (bcd_value & 0x0f)); 
10AC:  RRCF   x93,W
10AE:  MOVWF  00
10B0:  RRCF   00,F
10B2:  MOVLW  3F
10B4:  ANDWF  00,F
10B6:  MOVF   00,W
10B8:  ADDWF  x93,W
10BA:  MOVWF  x94
10BC:  MOVF   x92,W
10BE:  ANDLW  0F
10C0:  ADDWF  x94,W
10C2:  MOVWF  01
.................... } 
10C4:  RETLW  00
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #include <24C512.c> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////   Library for a 24LC512 serial EEPROM                             //// 
.................... ////                                                                   //// 
.................... ////   init_ext_eeprom();    Call before the other functions are used  //// 
.................... ////                                                                   //// 
.................... ////   write_ext_eeprom(a, d);  Write the byte d to the address a      //// 
.................... ////                                                                   //// 
.................... ////   d = read_ext_eeprom(a);   Read the byte d from the address a    //// 
.................... ////                                                                   //// 
.................... ////   The main program may define eeprom_sda                          //// 
.................... ////   and eeprom_scl to override the defaults below.                  //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef EEPROM_SDA 
....................  
.................... #define EEPROM_SDA  PIN_A1 
.................... #define EEPROM_SCL  PIN_A0 
....................  
.................... #endif 
....................  
.................... #use i2c(master, sda=EEPROM_SDA, scl=EEPROM_SCL) 
*
0938:  MOVLW  08
093A:  MOVWF  01
093C:  MOVLW  05
093E:  MOVWF  00
0940:  DECFSZ 00,F
0942:  BRA    0940
0944:  BCF    F89.0
0946:  BCF    F92.0
0948:  MOVLW  06
094A:  MOVWF  00
094C:  DECFSZ 00,F
094E:  BRA    094C
0950:  RLCF   x94,F
0952:  BCF    F89.1
0954:  BTFSC  FD8.0
0956:  BSF    F92.1
0958:  BTFSS  FD8.0
095A:  BCF    F92.1
095C:  BSF    F92.0
095E:  BTFSS  F80.0
0960:  BRA    095E
0962:  DECFSZ 01,F
0964:  BRA    093C
0966:  MOVLW  05
0968:  MOVWF  00
096A:  DECFSZ 00,F
096C:  BRA    096A
096E:  BCF    F89.0
0970:  BCF    F92.0
0972:  NOP   
0974:  BSF    F92.1
0976:  MOVLW  06
0978:  MOVWF  00
097A:  DECFSZ 00,F
097C:  BRA    097A
097E:  MOVLW  06
0980:  MOVWF  00
0982:  DECFSZ 00,F
0984:  BRA    0982
0986:  BSF    F92.0
0988:  BTFSS  F80.0
098A:  BRA    0988
098C:  CLRF   01
098E:  MOVLW  06
0990:  MOVWF  00
0992:  DECFSZ 00,F
0994:  BRA    0992
0996:  BTFSC  F80.1
0998:  BSF    01.0
099A:  BCF    F89.0
099C:  BCF    F92.0
099E:  BCF    F89.1
09A0:  BCF    F92.1
09A2:  RETLW  00
09A4:  MOVLW  08
09A6:  MOVWF  x93
09A8:  MOVFF  00,94
09AC:  BSF    F92.1
09AE:  MOVLW  06
09B0:  MOVWF  00
09B2:  DECFSZ 00,F
09B4:  BRA    09B2
09B6:  BSF    F92.0
09B8:  BTFSS  F80.0
09BA:  BRA    09B8
09BC:  BTFSC  F80.1
09BE:  BSF    FD8.0
09C0:  BTFSS  F80.1
09C2:  BCF    FD8.0
09C4:  RLCF   01,F
09C6:  MOVLW  05
09C8:  MOVWF  00
09CA:  DECFSZ 00,F
09CC:  BRA    09CA
09CE:  BCF    F92.0
09D0:  BCF    F89.0
09D2:  DECFSZ x93,F
09D4:  BRA    09AC
09D6:  BSF    F92.1
09D8:  MOVLW  06
09DA:  MOVWF  00
09DC:  DECFSZ 00,F
09DE:  BRA    09DC
09E0:  BCF    F89.1
09E2:  MOVF   x94,W
09E4:  BTFSS  FD8.2
09E6:  BCF    F92.1
09E8:  NOP   
09EA:  BSF    F92.0
09EC:  BTFSS  F80.0
09EE:  BRA    09EC
09F0:  MOVLW  05
09F2:  MOVWF  00
09F4:  DECFSZ 00,F
09F6:  BRA    09F4
09F8:  BCF    F89.0
09FA:  BCF    F92.0
09FC:  MOVLW  06
09FE:  MOVWF  00
0A00:  DECFSZ 00,F
0A02:  BRA    0A00
0A04:  BCF    F89.1
0A06:  BCF    F92.1
0A08:  GOTO   0A7A (RETURN)
....................  
.................... #define EEPROM_ADDRESS long int 
.................... #define EEPROM_SIZE   65535 
....................  
.................... void init_ext_eeprom() 
.................... { 
....................    output_float(EEPROM_SCL); 
....................    output_float(EEPROM_SDA); 
....................  
.................... } 
....................  
.................... void write_ext_eeprom(long int address, BYTE data) 
.................... { 
....................    short int status; 
....................    i2c_start(); 
*
0EA6:  BSF    F92.1
0EA8:  MOVLW  05
0EAA:  MOVWF  00
0EAC:  DECFSZ 00,F
0EAE:  BRA    0EAC
0EB0:  BSF    F92.0
0EB2:  MOVLW  06
0EB4:  MOVWF  00
0EB6:  DECFSZ 00,F
0EB8:  BRA    0EB6
0EBA:  BCF    F89.1
0EBC:  BCF    F92.1
0EBE:  MOVLW  05
0EC0:  MOVWF  00
0EC2:  DECFSZ 00,F
0EC4:  BRA    0EC2
0EC6:  BCF    F89.0
0EC8:  BCF    F92.0
....................    i2c_write(0xa0); 
0ECA:  MOVLW  A0
0ECC:  MOVWF  x94
0ECE:  RCALL  0938
....................    i2c_write(address>>8); 
0ED0:  MOVFF  8F,92
0ED4:  CLRF   x93
0ED6:  MOVFF  8F,94
0EDA:  RCALL  0938
....................    i2c_write(address); 
0EDC:  MOVFF  8E,94
0EE0:  RCALL  0938
....................    i2c_write(data); 
0EE2:  MOVFF  90,94
0EE6:  RCALL  0938
....................    i2c_stop(); 
0EE8:  BCF    F92.1
0EEA:  NOP   
0EEC:  BSF    F92.0
0EEE:  BTFSS  F80.0
0EF0:  BRA    0EEE
0EF2:  MOVLW  05
0EF4:  MOVWF  00
0EF6:  DECFSZ 00,F
0EF8:  BRA    0EF6
0EFA:  BRA    0EFC
0EFC:  NOP   
0EFE:  BSF    F92.1
0F00:  MOVLW  05
0F02:  MOVWF  00
0F04:  DECFSZ 00,F
0F06:  BRA    0F04
....................    i2c_start(); 
0F08:  BSF    F92.1
0F0A:  MOVLW  05
0F0C:  MOVWF  00
0F0E:  DECFSZ 00,F
0F10:  BRA    0F0E
0F12:  BSF    F92.0
0F14:  MOVLW  06
0F16:  MOVWF  00
0F18:  DECFSZ 00,F
0F1A:  BRA    0F18
0F1C:  BCF    F89.1
0F1E:  BCF    F92.1
0F20:  MOVLW  05
0F22:  MOVWF  00
0F24:  DECFSZ 00,F
0F26:  BRA    0F24
0F28:  BCF    F89.0
0F2A:  BCF    F92.0
....................    status=i2c_write(0xa0); 
0F2C:  MOVLW  A0
0F2E:  MOVWF  x94
0F30:  RCALL  0938
0F32:  MOVF   01,W
0F34:  BCF    x91.0
0F36:  BTFSC  01.0
0F38:  BSF    x91.0
....................    while(status==1) 
....................    { 
0F3A:  BTFSS  x91.0
0F3C:  BRA    0F76
....................       i2c_start(); 
0F3E:  BSF    F92.1
0F40:  MOVLW  05
0F42:  MOVWF  00
0F44:  DECFSZ 00,F
0F46:  BRA    0F44
0F48:  BSF    F92.0
0F4A:  MOVLW  06
0F4C:  MOVWF  00
0F4E:  DECFSZ 00,F
0F50:  BRA    0F4E
0F52:  BTFSS  F80.0
0F54:  BRA    0F52
0F56:  BCF    F89.1
0F58:  BCF    F92.1
0F5A:  MOVLW  05
0F5C:  MOVWF  00
0F5E:  DECFSZ 00,F
0F60:  BRA    0F5E
0F62:  BCF    F89.0
0F64:  BCF    F92.0
....................       status=i2c_write(0xa0); 
0F66:  MOVLW  A0
0F68:  MOVWF  x94
0F6A:  RCALL  0938
0F6C:  MOVF   01,W
0F6E:  BCF    x91.0
0F70:  BTFSC  01.0
0F72:  BSF    x91.0
....................    } 
0F74:  BRA    0F3A
....................    i2c_stop(); 
0F76:  BCF    F92.1
0F78:  NOP   
0F7A:  BSF    F92.0
0F7C:  BTFSS  F80.0
0F7E:  BRA    0F7C
0F80:  MOVLW  05
0F82:  MOVWF  00
0F84:  DECFSZ 00,F
0F86:  BRA    0F84
0F88:  BRA    0F8A
0F8A:  NOP   
0F8C:  BSF    F92.1
0F8E:  MOVLW  05
0F90:  MOVWF  00
0F92:  DECFSZ 00,F
0F94:  BRA    0F92
.................... } 
0F96:  RETLW  00
....................  
.................... BYTE read_ext_eeprom(long int address) { 
....................    BYTE data; 
....................    i2c_start(); 
*
0A0C:  BSF    F92.1
0A0E:  MOVLW  05
0A10:  MOVWF  00
0A12:  DECFSZ 00,F
0A14:  BRA    0A12
0A16:  BSF    F92.0
0A18:  MOVLW  06
0A1A:  MOVWF  00
0A1C:  DECFSZ 00,F
0A1E:  BRA    0A1C
0A20:  BCF    F89.1
0A22:  BCF    F92.1
0A24:  MOVLW  05
0A26:  MOVWF  00
0A28:  DECFSZ 00,F
0A2A:  BRA    0A28
0A2C:  BCF    F89.0
0A2E:  BCF    F92.0
....................    i2c_write(0xa0); 
0A30:  MOVLW  A0
0A32:  MOVWF  x94
0A34:  RCALL  0938
....................    i2c_write(address>>8); 
0A36:  MOVFF  90,92
0A3A:  CLRF   x93
0A3C:  MOVFF  90,94
0A40:  RCALL  0938
....................    i2c_write(address); 
0A42:  MOVFF  8F,94
0A46:  RCALL  0938
....................    i2c_start(); 
0A48:  BSF    F92.1
0A4A:  MOVLW  05
0A4C:  MOVWF  00
0A4E:  DECFSZ 00,F
0A50:  BRA    0A4E
0A52:  BSF    F92.0
0A54:  MOVLW  06
0A56:  MOVWF  00
0A58:  DECFSZ 00,F
0A5A:  BRA    0A58
0A5C:  BTFSS  F80.0
0A5E:  BRA    0A5C
0A60:  BCF    F89.1
0A62:  BCF    F92.1
0A64:  MOVLW  05
0A66:  MOVWF  00
0A68:  DECFSZ 00,F
0A6A:  BRA    0A68
0A6C:  BCF    F89.0
0A6E:  BCF    F92.0
....................    i2c_write(0xa1); 
0A70:  MOVLW  A1
0A72:  MOVWF  x94
0A74:  RCALL  0938
....................    data=i2c_read(0); 
0A76:  CLRF   00
0A78:  BRA    09A4
0A7A:  MOVFF  01,91
....................    i2c_stop(); 
0A7E:  BCF    F92.1
0A80:  NOP   
0A82:  BSF    F92.0
0A84:  BTFSS  F80.0
0A86:  BRA    0A84
0A88:  MOVLW  05
0A8A:  MOVWF  00
0A8C:  DECFSZ 00,F
0A8E:  BRA    0A8C
0A90:  BRA    0A92
0A92:  NOP   
0A94:  BSF    F92.1
0A96:  MOVLW  05
0A98:  MOVWF  00
0A9A:  DECFSZ 00,F
0A9C:  BRA    0A9A
....................    return(data); 
0A9E:  MOVFF  91,01
.................... } 
0AA2:  RETLW  00
....................  
.................... #ROM     0xf00000={0x4523}     //colocar 0 para usuario 1, estan al reves primero esta los dos digitos ultimos y luego los otros 
.................... #ROM     0xf00002={0x5634}     //esto es asignacion de claves para los usuarios 
.................... #define SW PIN A5 
.................... //Vamos a nombrar los registros de proposito GRAL 
.................... int i, b, clave[4], datoi[4], datoe[4], adres,  dato1, dato2, cantidad; 
.................... char datom; 
.................... float valor; 
.................... short flag, espacio_vacio; 
.................... long segundos, auxsegundos; 
.................... int ide, hour, min, day, mth, year, dow, sec, time[8] ; 
.................... int contador, demora=20; 
....................  
.................... /************************** 
.................... SECCION DE METODOS 
.................... ************************/ 
....................  
.................... void teclado() 
.................... {  
....................     lcd_putc('\f'); 
*
0CA6:  MOVLW  0C
0CA8:  MOVWF  x94
0CAA:  RCALL  0888
....................     segundos=0; 
0CAC:  CLRF   x78
0CAE:  CLRF   x77
....................     auxsegundos=0; 
0CB0:  CLRF   x7A
0CB2:  CLRF   x79
....................     b=6; 
0CB4:  MOVLW  06
0CB6:  MOVWF  x61
....................      for(i=0;i<4; i++) 
0CB8:  CLRF   x60
0CBA:  MOVF   x60,W
0CBC:  SUBLW  03
0CBE:  BTFSS  FD8.0
0CC0:  BRA    0E20
....................       { 
....................         do{ 
....................             datom=kbd_getc(); // escanea teclado 
0CC2:  RCALL  0B8E
0CC4:  MOVFF  01,72
....................             delay_ms(60); 
0CC8:  MOVLW  3C
0CCA:  MOVWF  x95
0CCC:  RCALL  071E
....................              if(datom!='\0')  //si hay dato valido 
0CCE:  MOVF   x72,F
0CD0:  BTFSC  FD8.2
0CD2:  BRA    0DC4
....................               { 
....................                  switch (i+1) 
....................                   { 
0CD4:  MOVLW  01
0CD6:  ADDWF  x60,W
0CD8:  ADDLW  FF
0CDA:  ADDLW  FC
0CDC:  BTFSC  FD8.0
0CDE:  BRA    0DAC
0CE0:  ADDLW  04
0CE2:  GOTO   0E22
....................                    case 1: 
....................                    lcd_gotoxy(6,1); 
0CE6:  MOVLW  06
0CE8:  MOVWF  x95
0CEA:  MOVLW  01
0CEC:  MOVWF  x96
0CEE:  RCALL  082C
....................                    lcd_putc(datom); 
0CF0:  MOVFF  72,94
0CF4:  RCALL  0888
....................                    //printf(lcd_putc,datom); 
....................                    clave[0]=datom-0X30; 
0CF6:  MOVLW  30
0CF8:  SUBWF  x72,W
0CFA:  MOVWF  x62
....................                    swap(clave[0]); 
0CFC:  SWAPF  x62,F
....................                    lcd_gotoxy(6,2); 
0CFE:  MOVLW  06
0D00:  MOVWF  x95
0D02:  MOVLW  02
0D04:  MOVWF  x96
0D06:  RCALL  082C
....................                    printf(lcd_putc,"*"); 
0D08:  MOVLW  2A
0D0A:  MOVWF  x94
0D0C:  RCALL  0888
....................                    delay_ms(50); 
0D0E:  MOVLW  32
0D10:  MOVWF  x95
0D12:  RCALL  071E
....................                    break; 
0D14:  BRA    0DAC
....................            
....................                    case 2: 
....................                    lcd_gotoxy(7,1); 
0D16:  MOVLW  07
0D18:  MOVWF  x95
0D1A:  MOVLW  01
0D1C:  MOVWF  x96
0D1E:  RCALL  082C
....................                    lcd_putc(datom); 
0D20:  MOVFF  72,94
0D24:  RCALL  0888
....................                   // printf(lcd_putc,datom); 
....................                    clave[1]=datom-0X30; 
0D26:  MOVLW  30
0D28:  SUBWF  x72,W
0D2A:  MOVWF  x63
....................                    clave[0]=clave[0]+clave[1]; 
0D2C:  MOVF   x63,W
0D2E:  ADDWF  x62,F
....................                    lcd_gotoxy(7,2); 
0D30:  MOVLW  07
0D32:  MOVWF  x95
0D34:  MOVLW  02
0D36:  MOVWF  x96
0D38:  RCALL  082C
....................                    printf(lcd_putc,"*"); 
0D3A:  MOVLW  2A
0D3C:  MOVWF  x94
0D3E:  RCALL  0888
....................                    delay_ms(50); 
0D40:  MOVLW  32
0D42:  MOVWF  x95
0D44:  RCALL  071E
....................                    break; 
0D46:  BRA    0DAC
....................               
....................                    case 3: 
....................                    lcd_gotoxy(8,1); 
0D48:  MOVLW  08
0D4A:  MOVWF  x95
0D4C:  MOVLW  01
0D4E:  MOVWF  x96
0D50:  RCALL  082C
....................                    lcd_putc(datom); 
0D52:  MOVFF  72,94
0D56:  RCALL  0888
....................                    //printf(lcd_putc,datom); 
....................                    clave[2]=datom-0X30; 
0D58:  MOVLW  30
0D5A:  SUBWF  x72,W
0D5C:  MOVWF  x64
....................                    swap(clave[2]); 
0D5E:  SWAPF  x64,F
....................                    lcd_gotoxy(8,2); 
0D60:  MOVLW  08
0D62:  MOVWF  x95
0D64:  MOVLW  02
0D66:  MOVWF  x96
0D68:  RCALL  082C
....................                    printf(lcd_putc,"*"); 
0D6A:  MOVLW  2A
0D6C:  MOVWF  x94
0D6E:  RCALL  0888
....................                    delay_ms(50); 
0D70:  MOVLW  32
0D72:  MOVWF  x95
0D74:  RCALL  071E
....................                    break; 
0D76:  BRA    0DAC
....................               
....................                    case 4: 
....................                    lcd_gotoxy(9,1); 
0D78:  MOVLW  09
0D7A:  MOVWF  x95
0D7C:  MOVLW  01
0D7E:  MOVWF  x96
0D80:  RCALL  082C
....................                    lcd_putc(datom); 
0D82:  MOVFF  72,94
0D86:  RCALL  0888
....................                   // printf(lcd_putc,datom); 
....................                    clave[3]=datom-0X30; 
0D88:  MOVLW  30
0D8A:  SUBWF  x72,W
0D8C:  MOVWF  x65
....................                    clave[1]=clave[2]+clave[3]; 
0D8E:  MOVF   x65,W
0D90:  ADDWF  x64,W
0D92:  MOVWF  x63
....................                    lcd_gotoxy(9,2); 
0D94:  MOVLW  09
0D96:  MOVWF  x95
0D98:  MOVLW  02
0D9A:  MOVWF  x96
0D9C:  RCALL  082C
....................                    printf(lcd_putc,"*"); 
0D9E:  MOVLW  2A
0DA0:  MOVWF  x94
0DA2:  RCALL  0888
....................                    delay_ms(50); 
0DA4:  MOVLW  32
0DA6:  MOVWF  x95
0DA8:  RCALL  071E
....................                    break; 
0DAA:  BRA    0DAC
....................                  }  
....................                   i++; 
0DAC:  INCF   x60,F
....................                   delay_ms(500); 
0DAE:  MOVLW  02
0DB0:  MOVWF  x8D
0DB2:  MOVLW  FA
0DB4:  MOVWF  x95
0DB6:  RCALL  071E
0DB8:  DECFSZ x8D,F
0DBA:  BRA    0DB2
....................                   auxsegundos=0; 
0DBC:  CLRF   x7A
0DBE:  CLRF   x79
....................                   segundos=0; 
0DC0:  CLRF   x78
0DC2:  CLRF   x77
....................            } 
....................            auxsegundos++; 
0DC4:  INCF   x79,F
0DC6:  BTFSC  FD8.2
0DC8:  INCF   x7A,F
....................            if(auxsegundos > 20) 
0DCA:  MOVF   x7A,F
0DCC:  BNZ   0DD4
0DCE:  MOVF   x79,W
0DD0:  SUBLW  14
0DD2:  BC    0DDE
....................             { 
....................               segundos++; 
0DD4:  INCF   x77,F
0DD6:  BTFSC  FD8.2
0DD8:  INCF   x78,F
....................               auxsegundos=0; 
0DDA:  CLRF   x7A
0DDC:  CLRF   x79
....................             } 
....................          
....................       
....................     
....................     }while(i<4 && segundos<6); 
0DDE:  MOVF   x60,W
0DE0:  SUBLW  03
0DE2:  BNC   0DF0
0DE4:  MOVF   x78,F
0DE6:  BNZ   0DF0
0DE8:  MOVF   x77,W
0DEA:  SUBLW  05
0DEC:  BTFSC  FD8.0
0DEE:  BRA    0CC2
....................       clave[i]='#'; 
0DF0:  CLRF   03
0DF2:  MOVF   x60,W
0DF4:  ADDLW  62
0DF6:  MOVWF  FE9
0DF8:  MOVLW  00
0DFA:  ADDWFC 03,W
0DFC:  MOVWF  FEA
0DFE:  MOVLW  23
0E00:  MOVWF  FEF
....................       lcd_gotoxy(b,1); 
0E02:  MOVFF  61,95
0E06:  MOVLW  01
0E08:  MOVWF  x96
0E0A:  RCALL  082C
....................       printf(lcd_putc,"*") ; 
0E0C:  MOVLW  2A
0E0E:  MOVWF  x94
0E10:  RCALL  0888
....................       b++; 
0E12:  INCF   x61,F
....................       auxsegundos=0; 
0E14:  CLRF   x7A
0E16:  CLRF   x79
....................       segundos=0; 
0E18:  CLRF   x78
0E1A:  CLRF   x77
....................    } 
0E1C:  INCF   x60,F
0E1E:  BRA    0CBA
.................... } 
0E20:  RETLW  00
....................  
....................  
....................  
.................... void un_digito() 
.................... { lcd_putc('\f'); 
*
0E44:  MOVLW  0C
0E46:  MOVWF  x94
0E48:  RCALL  0888
....................   segundos=0; 
0E4A:  CLRF   x78
0E4C:  CLRF   x77
....................   auxsegundos=0; 
0E4E:  CLRF   x7A
0E50:  CLRF   x79
....................   flag=false; 
0E52:  BCF    0E.1
....................   do{ 
....................       datom=kbd_getc(); 
0E54:  RCALL  0B8E
0E56:  MOVFF  01,72
....................       delay_ms(60); 
0E5A:  MOVLW  3C
0E5C:  MOVWF  x95
0E5E:  RCALL  071E
....................       if(datom !='\0') 
0E60:  MOVF   x72,F
0E62:  BZ    0E7C
....................         { 
....................           lcd_gotoxy(8,1);  //coloque el numero digitado  en posicion del LCD 
0E64:  MOVLW  08
0E66:  MOVWF  x95
0E68:  MOVLW  01
0E6A:  MOVWF  x96
0E6C:  RCALL  082C
....................           lcd_putc(datom); //visualice datom 
0E6E:  MOVFF  72,94
0E72:  RCALL  0888
....................           datom=datom-0x30; //quitele ASCII 
0E74:  MOVLW  30
0E76:  SUBWF  x72,F
....................           flag=true; 
0E78:  BSF    0E.1
....................            
....................         }else { 
0E7A:  BRA    0E96
....................                auxsegundos++; 
0E7C:  INCF   x79,F
0E7E:  BTFSC  FD8.2
0E80:  INCF   x7A,F
....................                if(auxsegundos>20) 
0E82:  MOVF   x7A,F
0E84:  BNZ   0E8C
0E86:  MOVF   x79,W
0E88:  SUBLW  14
0E8A:  BC    0E96
....................                { 
....................                  segundos++; 
0E8C:  INCF   x77,F
0E8E:  BTFSC  FD8.2
0E90:  INCF   x78,F
....................                  auxsegundos=0; 
0E92:  CLRF   x7A
0E94:  CLRF   x79
....................                 } 
....................        } 
....................          
....................   }while(segundos<6 && flag==false ); 
0E96:  MOVF   x78,F
0E98:  BNZ   0EA4
0E9A:  MOVF   x77,W
0E9C:  SUBLW  05
0E9E:  BNC   0EA4
0EA0:  BTFSS  0E.1
0EA2:  BRA    0E54
.................... } 
0EA4:  RETLW  00
....................  
.................... void escribir_memoria() 
.................... { 
....................   for(i=0; i<2; i++) 
....................   {  write_eeprom(adres, clave[i]); 
....................      delay_ms(5); 
....................      adres++; 
....................   } 
.................... } 
....................  
.................... void escribir_memoria_ext() 
.................... { 
....................   for(i=0; i<2; i++) 
*
0F98:  CLRF   x60
0F9A:  MOVF   x60,W
0F9C:  SUBLW  01
0F9E:  BNC   0FCC
....................   {  write_ext_eeprom(adres, clave[i]); 
0FA0:  CLRF   03
0FA2:  MOVF   x60,W
0FA4:  ADDLW  62
0FA6:  MOVWF  FE9
0FA8:  MOVLW  00
0FAA:  ADDWFC 03,W
0FAC:  MOVWF  FEA
0FAE:  MOVFF  FEF,8D
0FB2:  CLRF   x8F
0FB4:  MOVFF  6E,8E
0FB8:  MOVFF  8D,90
0FBC:  RCALL  0EA6
....................      delay_ms(5); 
0FBE:  MOVLW  05
0FC0:  MOVWF  x95
0FC2:  CALL   071E
....................      adres++; 
0FC6:  INCF   x6E,F
....................   } 
0FC8:  INCF   x60,F
0FCA:  BRA    0F9A
.................... } 
0FCC:  RETLW  00
....................  
....................  
.................... void leer() 
.................... { 
....................   for(i=0; i<4; i++) 
*
08FC:  CLRF   x60
08FE:  MOVF   x60,W
0900:  SUBLW  03
0902:  BNC   0934
....................   { 
....................     datoi[i]=read_eeprom(i); 
0904:  CLRF   03
0906:  MOVF   x60,W
0908:  ADDLW  66
090A:  MOVWF  FE9
090C:  MOVLW  00
090E:  ADDWFC 03,W
0910:  MOVWF  FEA
0912:  MOVFF  FF2,8F
0916:  BCF    FF2.7
0918:  MOVFF  60,FA9
091C:  BCF    FA6.6
091E:  BCF    FA6.7
0920:  BSF    FA6.0
0922:  MOVF   FA8,W
0924:  BTFSC  x8F.7
0926:  BSF    FF2.7
0928:  MOVWF  FEF
....................     delay_ms(1); 
092A:  MOVLW  01
092C:  MOVWF  x95
092E:  RCALL  071E
....................   } 
0930:  INCF   x60,F
0932:  BRA    08FE
.................... } 
0934:  GOTO   1BAA (RETURN)
....................  
....................  
.................... void leer_men_ext() 
.................... { 
....................   for(i=0; i<4; i++) 
*
0AA4:  CLRF   x60
0AA6:  MOVF   x60,W
0AA8:  SUBLW  03
0AAA:  BNC   0ADE
....................   { 
....................     datoe[i]=read_ext_eeprom(i); 
0AAC:  CLRF   03
0AAE:  MOVF   x60,W
0AB0:  ADDLW  6A
0AB2:  MOVWF  01
0AB4:  MOVLW  00
0AB6:  ADDWFC 03,F
0AB8:  MOVFF  01,8D
0ABC:  MOVFF  03,8E
0AC0:  CLRF   x90
0AC2:  MOVFF  60,8F
0AC6:  RCALL  0A0C
0AC8:  MOVFF  8E,FEA
0ACC:  MOVFF  8D,FE9
0AD0:  MOVFF  01,FEF
....................     delay_ms(1); 
0AD4:  MOVLW  01
0AD6:  MOVWF  x95
0AD8:  RCALL  071E
....................    } 
0ADA:  INCF   x60,F
0ADC:  BRA    0AA6
.................... } 
0ADE:  GOTO   1BAE (RETURN)
....................  
.................... void hora_fecha(){ 
....................    //ds1307_get_date(day, mth, year, dow); 
....................    ds1307_get_date(time[3], time[4], time[5], time[6]); 
....................    lcd_putc('\f'); 
*
1296:  MOVLW  0C
1298:  MOVWF  x94
129A:  CALL   0888
....................    lcd_gotoxy(1,1); 
129E:  MOVLW  01
12A0:  MOVWF  x95
12A2:  MOVWF  x96
12A4:  CALL   082C
....................    printf(lcd_putc,"DATE:"); 
12A8:  CLRF   x8D
12AA:  MOVF   x8D,W
12AC:  CALL   0038
12B0:  INCF   x8D,F
12B2:  MOVWF  00
12B4:  MOVWF  x94
12B6:  CALL   0888
12BA:  MOVLW  05
12BC:  SUBWF  x8D,W
12BE:  BNZ   12AA
....................     
....................    for(i=3;i<6;i++){ 
12C0:  MOVLW  03
12C2:  MOVWF  x60
12C4:  MOVF   x60,W
12C6:  SUBLW  05
12C8:  BNC   12FA
....................       printf(lcd_putc,"%2d/",time[i]); 
12CA:  CLRF   03
12CC:  MOVF   x60,W
12CE:  ADDLW  83
12D0:  MOVWF  FE9
12D2:  MOVLW  00
12D4:  ADDWFC 03,W
12D6:  MOVWF  FEA
12D8:  MOVFF  FEF,8D
12DC:  MOVFF  8D,8E
12E0:  MOVLW  11
12E2:  MOVWF  x8F
12E4:  RCALL  10EE
12E6:  MOVLW  2F
12E8:  MOVWF  x94
12EA:  CALL   0888
....................       delay_ms(200); 
12EE:  MOVLW  C8
12F0:  MOVWF  x95
12F2:  CALL   071E
....................        
....................    } 
12F6:  INCF   x60,F
12F8:  BRA    12C4
....................    lcd_gotoxy(16,1); 
12FA:  MOVLW  10
12FC:  MOVWF  x95
12FE:  MOVLW  01
1300:  MOVWF  x96
1302:  CALL   082C
....................    lcd_putc("D "); 
1306:  CLRF   x8D
1308:  MOVF   x8D,W
130A:  CALL   004E
130E:  IORLW  00
1310:  BZ    131C
1312:  INCF   x8D,F
1314:  MOVWF  x94
1316:  CALL   0888
131A:  BRA    1308
....................     
....................     for(i=0;i<10;i++){ 
131C:  CLRF   x60
131E:  MOVF   x60,W
1320:  SUBLW  09
1322:  BTFSS  FD8.0
1324:  BRA    1476
....................          //ds1307_get_time(hour, min, sec); 
....................          ds1307_get_time(time[0],time[1],time[2]); 
....................          lcd_gotoxy(1,2); 
*
13E8:  MOVLW  01
13EA:  MOVWF  x95
13EC:  MOVLW  02
13EE:  MOVWF  x96
13F0:  CALL   082C
....................          printf(lcd_putc,"HORA:"); 
13F4:  CLRF   x8D
13F6:  MOVF   x8D,W
13F8:  CALL   0062
13FC:  INCF   x8D,F
13FE:  MOVWF  00
1400:  MOVWF  x94
1402:  CALL   0888
1406:  MOVLW  05
1408:  SUBWF  x8D,W
140A:  BNZ   13F6
....................     for(i=0;i<3;i++){ 
140C:  CLRF   x60
140E:  MOVF   x60,W
1410:  SUBLW  02
1412:  BNC   1444
....................         printf(lcd_putc,"%2d:",time[i]); 
1414:  CLRF   03
1416:  MOVF   x60,W
1418:  ADDLW  83
141A:  MOVWF  FE9
141C:  MOVLW  00
141E:  ADDWFC 03,W
1420:  MOVWF  FEA
1422:  MOVFF  FEF,8D
1426:  MOVFF  8D,8E
142A:  MOVLW  11
142C:  MOVWF  x8F
142E:  RCALL  10EE
1430:  MOVLW  3A
1432:  MOVWF  x94
1434:  CALL   0888
....................         delay_ms(200); 
1438:  MOVLW  C8
143A:  MOVWF  x95
143C:  CALL   071E
....................     } 
1440:  INCF   x60,F
1442:  BRA    140E
....................      
....................       lcd_gotoxy(16,2); 
1444:  MOVLW  10
1446:  MOVWF  x95
1448:  MOVLW  02
144A:  MOVWF  x96
144C:  CALL   082C
....................       printf(lcd_putc,"%1d:",time[6]); 
1450:  MOVFF  89,8E
1454:  MOVLW  18
1456:  MOVWF  x8F
1458:  RCALL  10EE
145A:  MOVLW  3A
145C:  MOVWF  x94
145E:  CALL   0888
....................       delay_ms(995); 
1462:  MOVLW  05
1464:  MOVWF  x8D
1466:  MOVLW  C7
1468:  MOVWF  x95
146A:  CALL   071E
146E:  DECFSZ x8D,F
1470:  BRA    1466
....................     } 
1472:  INCF   x60,F
1474:  BRA    131E
....................     
.................... } 
1476:  RETLW  00
....................  
.................... void actualizar(){ 
....................     day=0x0A;          //dia27 
....................     mth=0x0A;          //mes 
....................     year=0x15;         //aos21 
....................     dow=0x01;          //dow lun 
....................     hour=0x014;        //hora 7 
....................     min=0x6;           //min   50 
....................     sec=0x00;          //sec 
....................     ds1307_set_date_time(day, mth, year, dow, hour, min,sec); 
....................    } 
....................  
....................  
.................... void buscar_pos(){ 
....................        espacio_vacio=false; 
1478:  BCF    0E.2
....................        adres=0x08; 
147A:  MOVLW  08
147C:  MOVWF  x6E
....................        contador=0; 
147E:  CLRF   x8B
....................       
....................     do{ 
....................          valor=read_ext_eeprom(adres); 
1480:  CLRF   x90
1482:  MOVFF  6E,8F
1486:  CALL   0A0C
148A:  CLRF   x90
148C:  MOVFF  01,8F
1490:  CALL   0AE2
1494:  MOVFF  03,76
1498:  MOVFF  02,75
149C:  MOVFF  01,74
14A0:  MOVFF  00,73
....................          delay_ms(3); 
14A4:  MOVLW  03
14A6:  MOVWF  x95
14A8:  CALL   071E
....................          
....................         if(valor==0xFF){ 
14AC:  MOVFF  76,92
14B0:  MOVFF  75,91
14B4:  MOVFF  74,90
14B8:  MOVFF  73,8F
14BC:  CLRF   x96
14BE:  CLRF   x95
14C0:  MOVLW  7F
14C2:  MOVWF  x94
14C4:  MOVLW  86
14C6:  MOVWF  x93
14C8:  CALL   0B18
14CC:  BNZ   14D2
....................             espacio_vacio=true; 
14CE:  BSF    0E.2
....................             
....................         }else{ 
14D0:  BRA    14D6
....................               adres=adres+0x08; 
14D2:  MOVLW  08
14D4:  ADDWF  x6E,F
....................         } 
....................       contador=contador+1; 
14D6:  MOVLW  01
14D8:  ADDWF  x8B,F
....................     }while((adres<=0xF0)  && (espacio_vacio==false)); 
14DA:  MOVF   x6E,W
14DC:  SUBLW  F0
14DE:  BNC   14E4
14E0:  BTFSS  0E.2
14E2:  BRA    1480
....................     //time[0]=contador; 
.................... } 
14E4:  RETLW  00
....................  
.................... void hacer_reporte(){ 
....................    ds1307_get_date(day, mth, year, dow ); 
....................    ds1307_get_time(hour, min, sec); 
....................     time[0]=contador; 
*
1680:  MOVFF  8B,83
....................     time[1]= day; 
1684:  MOVFF  7E,84
....................     time[2]= mth; 
1688:  MOVFF  7F,85
....................     time[3]= year; 
168C:  MOVFF  80,86
....................     time[4]= hour; 
1690:  MOVFF  7C,87
....................     time[5]= min; 
1694:  MOVFF  7D,88
....................     time[6]= sec; 
1698:  MOVFF  82,89
....................     time[7]= ide; 
169C:  MOVFF  7B,8A
.................... } 
16A0:  RETLW  00
....................  
....................  
....................  
....................  
.................... void mostrar_reporte(){ 
....................      adres=0x08; 
16A2:  MOVLW  08
16A4:  MOVWF  x6E
....................      cantidad=0; 
16A6:  CLRF   x71
....................  do{ 
....................        for(i=0;i<8;i++){ 
16A8:  CLRF   x60
16AA:  MOVF   x60,W
16AC:  SUBLW  07
16AE:  BNC   16E8
....................           time[i]=read_ext_eeprom(adres); 
16B0:  CLRF   03
16B2:  MOVF   x60,W
16B4:  ADDLW  83
16B6:  MOVWF  01
16B8:  MOVLW  00
16BA:  ADDWFC 03,F
16BC:  MOVFF  01,8D
16C0:  MOVFF  03,8E
16C4:  CLRF   x90
16C6:  MOVFF  6E,8F
16CA:  CALL   0A0C
16CE:  MOVFF  8E,FEA
16D2:  MOVFF  8D,FE9
16D6:  MOVFF  01,FEF
....................           delay_ms(3); 
16DA:  MOVLW  03
16DC:  MOVWF  x95
16DE:  CALL   071E
....................           adres++; 
16E2:  INCF   x6E,F
....................         } 
16E4:  INCF   x60,F
16E6:  BRA    16AA
....................              lcd_putc('\f'); 
16E8:  MOVLW  0C
16EA:  MOVWF  x94
16EC:  CALL   0888
....................              lcd_gotoxy(1,1); 
16F0:  MOVLW  01
16F2:  MOVWF  x95
16F4:  MOVWF  x96
16F6:  CALL   082C
....................              printf(lcd_putc,"##DDMMAAHHMMSSID"); 
16FA:  CLRF   x8D
16FC:  MOVF   x8D,W
16FE:  CALL   0078
1702:  INCF   x8D,F
1704:  MOVWF  00
1706:  MOVWF  x94
1708:  CALL   0888
170C:  MOVLW  10
170E:  SUBWF  x8D,W
1710:  BNZ   16FC
....................              lcd_gotoxy(1,2); 
1712:  MOVLW  01
1714:  MOVWF  x95
1716:  MOVLW  02
1718:  MOVWF  x96
171A:  CALL   082C
....................              printf(lcd_putc,"%2d",time[0]); 
171E:  MOVFF  83,8E
1722:  MOVLW  11
1724:  MOVWF  x8F
1726:  RCALL  10EE
....................              lcd_gotoxy(3,2); 
1728:  MOVLW  03
172A:  MOVWF  x95
172C:  MOVLW  02
172E:  MOVWF  x96
1730:  CALL   082C
....................              printf(lcd_putc,"%2d",time[1]); 
1734:  MOVFF  84,8E
1738:  MOVLW  11
173A:  MOVWF  x8F
173C:  RCALL  10EE
....................              lcd_gotoxy(5,2); 
173E:  MOVLW  05
1740:  MOVWF  x95
1742:  MOVLW  02
1744:  MOVWF  x96
1746:  CALL   082C
....................              printf(lcd_putc,"%2d",time[2]); 
174A:  MOVFF  85,8E
174E:  MOVLW  11
1750:  MOVWF  x8F
1752:  RCALL  10EE
....................              lcd_gotoxy(7,2); 
1754:  MOVLW  07
1756:  MOVWF  x95
1758:  MOVLW  02
175A:  MOVWF  x96
175C:  CALL   082C
....................              printf(lcd_putc,"%2d",time[3]); 
1760:  MOVFF  86,8E
1764:  MOVLW  11
1766:  MOVWF  x8F
1768:  RCALL  10EE
....................              lcd_gotoxy(9,2); 
176A:  MOVLW  09
176C:  MOVWF  x95
176E:  MOVLW  02
1770:  MOVWF  x96
1772:  CALL   082C
....................              printf(lcd_putc,"%2d",time[4]); 
1776:  MOVFF  87,8E
177A:  MOVLW  11
177C:  MOVWF  x8F
177E:  RCALL  10EE
....................              lcd_gotoxy(11,2); 
1780:  MOVLW  0B
1782:  MOVWF  x95
1784:  MOVLW  02
1786:  MOVWF  x96
1788:  CALL   082C
....................              printf(lcd_putc,"%2d",time[5]); 
178C:  MOVFF  88,8E
1790:  MOVLW  11
1792:  MOVWF  x8F
1794:  RCALL  10EE
....................              lcd_gotoxy(13,2); 
1796:  MOVLW  0D
1798:  MOVWF  x95
179A:  MOVLW  02
179C:  MOVWF  x96
179E:  CALL   082C
....................              printf(lcd_putc,"%2d",time[6]); 
17A2:  MOVFF  89,8E
17A6:  MOVLW  11
17A8:  MOVWF  x8F
17AA:  RCALL  10EE
....................              lcd_gotoxy(15,2); 
17AC:  MOVLW  0F
17AE:  MOVWF  x95
17B0:  MOVLW  02
17B2:  MOVWF  x96
17B4:  CALL   082C
....................              printf(lcd_putc,"%2d",time[7]); 
17B8:  MOVFF  8A,8E
17BC:  MOVLW  11
17BE:  MOVWF  x8F
17C0:  RCALL  10EE
....................              delay_ms(3000); 
17C2:  MOVLW  0C
17C4:  MOVWF  x8D
17C6:  MOVLW  FA
17C8:  MOVWF  x95
17CA:  CALL   071E
17CE:  DECFSZ x8D,F
17D0:  BRA    17C6
....................               
....................        }while(cantidad<=50); 
17D2:  MOVF   x71,W
17D4:  SUBLW  32
17D6:  BTFSC  FD8.0
17D8:  BRA    16A8
.................... } 
17DA:  RETLW  00
....................  
.................... void borrar(){ 
....................    for(i=0;i<80;i++){    
....................       write_ext_eeprom(i, 0xFF); 
....................       delay_ms(2); 
....................     }  
....................   } 
....................    
.................... void motorderecha(){ 
....................   for(i=0;i<256;i++){ 
17DC:  CLRF   x60
....................    
....................      output_high(PIN_D0);           //paso 1    
17DE:  BCF    F95.0
17E0:  BSF    F8C.0
....................      output_high(PIN_D1);           
17E2:  BCF    F95.1
17E4:  BSF    F8C.1
....................      output_low(PIN_D2);            
17E6:  BCF    F95.2
17E8:  BCF    F8C.2
....................      output_low(PIN_D3);            
17EA:  BCF    F95.3
17EC:  BCF    F8C.3
....................      delay_ms(demora); 
17EE:  MOVFF  8C,95
17F2:  CALL   071E
....................       
....................      output_low(PIN_D0);            //paso 2 
17F6:  BCF    F95.0
17F8:  BCF    F8C.0
....................      output_high(PIN_D1);           
17FA:  BCF    F95.1
17FC:  BSF    F8C.1
....................      output_high(PIN_D2);           
17FE:  BCF    F95.2
1800:  BSF    F8C.2
....................      output_low(PIN_D3);            
1802:  BCF    F95.3
1804:  BCF    F8C.3
....................      delay_ms(demora); 
1806:  MOVFF  8C,95
180A:  CALL   071E
....................       
....................      output_low(PIN_D0);           //paso 3 
180E:  BCF    F95.0
1810:  BCF    F8C.0
....................      output_low(PIN_D1);           
1812:  BCF    F95.1
1814:  BCF    F8C.1
....................      output_high(PIN_D2);           
1816:  BCF    F95.2
1818:  BSF    F8C.2
....................      output_high(PIN_D3);           
181A:  BCF    F95.3
181C:  BSF    F8C.3
....................      delay_ms(demora); 
181E:  MOVFF  8C,95
1822:  CALL   071E
....................       
....................       
....................      output_high(PIN_D0);          //paso 4 
1826:  BCF    F95.0
1828:  BSF    F8C.0
....................      output_low(PIN_D1);            
182A:  BCF    F95.1
182C:  BCF    F8C.1
....................      output_low(PIN_D2);            
182E:  BCF    F95.2
1830:  BCF    F8C.2
....................      output_high(PIN_D3);           
1832:  BCF    F95.3
1834:  BSF    F8C.3
....................      delay_ms(demora); 
1836:  MOVFF  8C,95
183A:  CALL   071E
....................       
....................    } 
183E:  INCF   x60,F
1840:  BRA    17DE
....................     
....................      output_low(PIN_D0);           
1842:  BCF    F95.0
1844:  BCF    F8C.0
....................      output_low(PIN_D1);            
1846:  BCF    F95.1
1848:  BCF    F8C.1
....................      output_low(PIN_D2);            
184A:  BCF    F95.2
184C:  BCF    F8C.2
....................      output_low(PIN_D3);           
184E:  BCF    F95.3
1850:  BCF    F8C.3
....................      delay_ms(5000); 
1852:  MOVLW  14
1854:  MOVWF  x8D
1856:  MOVLW  FA
1858:  MOVWF  x95
185A:  CALL   071E
185E:  DECFSZ x8D,F
1860:  BRA    1856
....................  } 
1862:  RETLW  00
....................        
.................... void motorizquierda(){ 
....................    for(i=0;i<256;i++) 
1864:  CLRF   x60
....................    { 
....................      output_low(PIN_D0);          //paso 4 
1866:  BCF    F95.0
1868:  BCF    F8C.0
....................      output_low(PIN_D1);            
186A:  BCF    F95.1
186C:  BCF    F8C.1
....................      output_low(PIN_D2);            
186E:  BCF    F95.2
1870:  BCF    F8C.2
....................      output_high(PIN_D3);           
1872:  BCF    F95.3
1874:  BSF    F8C.3
....................      delay_ms(demora); 
1876:  MOVFF  8C,95
187A:  CALL   071E
....................       
....................      output_low(PIN_D0);           //paso 3 
187E:  BCF    F95.0
1880:  BCF    F8C.0
....................      output_low(PIN_D1);           
1882:  BCF    F95.1
1884:  BCF    F8C.1
....................      output_high(PIN_D2);           
1886:  BCF    F95.2
1888:  BSF    F8C.2
....................      output_low(PIN_D3);           
188A:  BCF    F95.3
188C:  BCF    F8C.3
....................      delay_ms(demora); 
188E:  MOVFF  8C,95
1892:  CALL   071E
....................       
....................      output_low(PIN_D0);            //paso 2 
1896:  BCF    F95.0
1898:  BCF    F8C.0
....................      output_high(PIN_D1);           
189A:  BCF    F95.1
189C:  BSF    F8C.1
....................      output_low(PIN_D2);           
189E:  BCF    F95.2
18A0:  BCF    F8C.2
....................      output_low(PIN_D3);            
18A2:  BCF    F95.3
18A4:  BCF    F8C.3
....................      delay_ms(demora); 
18A6:  MOVFF  8C,95
18AA:  CALL   071E
....................       
....................      output_high(PIN_D0);           //paso 1    
18AE:  BCF    F95.0
18B0:  BSF    F8C.0
....................      output_low(PIN_D1);           
18B2:  BCF    F95.1
18B4:  BCF    F8C.1
....................      output_low(PIN_D2);            
18B6:  BCF    F95.2
18B8:  BCF    F8C.2
....................      output_low(PIN_D3);            
18BA:  BCF    F95.3
18BC:  BCF    F8C.3
....................      delay_ms(demora); 
18BE:  MOVFF  8C,95
18C2:  CALL   071E
....................       
....................      } 
18C6:  INCF   x60,F
18C8:  BRA    1866
....................         output_low(PIN_D0);           
18CA:  BCF    F95.0
18CC:  BCF    F8C.0
....................         output_low(PIN_D1);            
18CE:  BCF    F95.1
18D0:  BCF    F8C.1
....................         output_low(PIN_D2);            
18D2:  BCF    F95.2
18D4:  BCF    F8C.2
....................         output_low(PIN_D3);           
18D6:  BCF    F95.3
18D8:  BCF    F8C.3
....................         delay_ms(5000); 
18DA:  MOVLW  14
18DC:  MOVWF  x8D
18DE:  MOVLW  FA
18E0:  MOVWF  x95
18E2:  CALL   071E
18E6:  DECFSZ x8D,F
18E8:  BRA    18DE
.................... }      
18EA:  RETLW  00
....................    
.................... /************************** 
.................... PROGRAMA PRINCIPAL 
.................... ************************/   
....................  
.................... void main() 
.................... {#zero_ram 
18EC:  CLRF   FF8
18EE:  BCF    FD0.7
18F0:  MOVLW  FE
18F2:  MOVWF  00
18F4:  MOVLW  08
18F6:  MOVWF  01
18F8:  MOVLW  02
18FA:  MOVWF  FE9
18FC:  MOVLW  00
18FE:  MOVWF  FEA
1900:  CLRF   FEE
1902:  DECFSZ 00,F
1904:  BRA    1900
1906:  DECFSZ 01,F
1908:  BRA    1900
190A:  CLRF   FEA
190C:  CLRF   FE9
190E:  MOVF   FC1,W
1910:  ANDLW  C0
1912:  IORLW  0F
1914:  MOVWF  FC1
1916:  MOVLW  07
1918:  MOVWF  FB4
191A:  CLRF   05
191C:  CLRF   06
191E:  CLRF   0D
1920:  BCF    0E.0
1922:  CLRF   0F
1924:  CLRF   10
1926:  MOVLW  4C
1928:  MOVWF  11
192A:  MOVLW  75
192C:  MOVWF  12
192E:  MOVLW  6E
1930:  MOVWF  13
1932:  MOVLW  65
1934:  MOVWF  14
1936:  MOVLW  73
1938:  MOVWF  15
193A:  CLRF   16
193C:  CLRF   17
193E:  CLRF   18
1940:  CLRF   19
1942:  CLRF   1A
1944:  CLRF   1B
1946:  MOVLW  4D
1948:  MOVWF  1C
194A:  MOVLW  61
194C:  MOVWF  1D
194E:  MOVLW  72
1950:  MOVWF  1E
1952:  MOVLW  74
1954:  MOVWF  1F
1956:  MOVLW  65
1958:  MOVWF  20
195A:  MOVLW  73
195C:  MOVWF  21
195E:  CLRF   22
1960:  CLRF   23
1962:  CLRF   24
1964:  CLRF   25
1966:  CLRF   26
1968:  MOVLW  4D
196A:  MOVWF  27
196C:  MOVLW  69
196E:  MOVWF  28
1970:  MOVLW  E9
1972:  MOVWF  29
1974:  MOVLW  72
1976:  MOVWF  2A
1978:  MOVLW  63
197A:  MOVWF  2B
197C:  MOVLW  6F
197E:  MOVWF  2C
1980:  MOVLW  6C
1982:  MOVWF  2D
1984:  MOVLW  65
1986:  MOVWF  2E
1988:  MOVLW  73
198A:  MOVWF  2F
198C:  CLRF   30
198E:  CLRF   31
1990:  MOVLW  4A
1992:  MOVWF  32
1994:  MOVLW  75
1996:  MOVWF  33
1998:  MOVLW  65
199A:  MOVWF  34
199C:  MOVLW  76
199E:  MOVWF  35
19A0:  MOVLW  65
19A2:  MOVWF  36
19A4:  MOVLW  73
19A6:  MOVWF  37
19A8:  CLRF   38
19AA:  CLRF   39
19AC:  CLRF   3A
19AE:  CLRF   3B
19B0:  CLRF   3C
19B2:  MOVLW  56
19B4:  MOVWF  3D
19B6:  MOVLW  69
19B8:  MOVWF  3E
19BA:  MOVLW  65
19BC:  MOVWF  3F
19BE:  MOVLW  72
19C0:  MOVWF  40
19C2:  MOVLW  6E
19C4:  MOVWF  41
19C6:  MOVLW  65
19C8:  MOVWF  42
19CA:  MOVLW  73
19CC:  MOVWF  43
19CE:  CLRF   44
19D0:  CLRF   45
19D2:  CLRF   46
19D4:  CLRF   47
19D6:  MOVLW  53
19D8:  MOVWF  48
19DA:  MOVLW  E1
19DC:  MOVWF  49
19DE:  MOVLW  62
19E0:  MOVWF  4A
19E2:  MOVLW  61
19E4:  MOVWF  4B
19E6:  MOVLW  64
19E8:  MOVWF  4C
19EA:  MOVLW  6F
19EC:  MOVWF  4D
19EE:  CLRF   4E
19F0:  CLRF   4F
19F2:  CLRF   50
19F4:  CLRF   51
19F6:  CLRF   52
19F8:  MOVLW  44
19FA:  MOVWF  53
19FC:  MOVLW  6F
19FE:  MOVWF  54
1A00:  MOVLW  6D
1A02:  MOVWF  55
1A04:  MOVLW  69
1A06:  MOVWF  56
1A08:  MOVLW  6E
1A0A:  MOVWF  57
1A0C:  MOVLW  67
1A0E:  MOVWF  58
1A10:  MOVLW  6F
1A12:  MOVWF  59
1A14:  CLRF   5A
1A16:  CLRF   5B
1A18:  CLRF   5E
1A1A:  MOVLW  14
1A1C:  MOVWF  x8C
.................... inicio:                       //etiquetas siempre a la izquierda 
....................     set_tris_A(0x28);         /*0010 1000 EL 28 SALE ES DIVIDIENDO LOS 8BITS EN 4 DIGITOS Y TOMAR A QUE NUMERO CORRESPONCEN 
1A1E:  MOVLW  28
1A20:  MOVWF  F92
....................     RA0 PIN 2  FREE 
....................     RA1 PIN 3  FREE 
....................     RA2 PIN 4  FREE 
....................     RA3 PIN 5  FREE 
....................     RA4 PIN 6  FREE 
....................     RA5 PIN 7  FREE 
....................     RA6 PIN 14 FREE 
....................     RA7 NO EXISTE */ 
....................      
....................     set_tris_B(0x00); /*0000 0000 EL 28 SALE ES DIVIDIENDO LOS 8BITS EN 4 DIGITOS Y TOMAR A QUE NUMERO CORRESPONCEN 
1A22:  MOVLW  00
1A24:  MOVWF  F93
....................     RB0 PIN 33  LED1 
....................     RB1 PIN 34  LED2 
....................     RB2 PIN 35  LED4 
....................     RB3 PIN 36  LED5 
....................     RB4 PIN 37  LED6 
....................     RB5 PIN 38  LED7 
....................     RB6 PIN 39  LED8 
....................     RB7 PIN 40  LED8 */ 
....................      
....................     set_tris_D(0x00); /*0000 0000 EL 28 SALE ES DIVIDIENDO LOS 8BITS EN 4 DIGITOS Y TOMAR A QUE NUMERO CORRESPONCEN 
1A26:  MOVWF  F95
....................     RB0 PIN 33  LED1 
....................     RB1 PIN 34  LED2 
....................     RB2 PIN 35  LED4 
....................     RB3 PIN 36  LED5 
....................     RB4 PIN 37  LED6 
....................     RB5 PIN 38  LED7 
....................     RB6 PIN 39  LED8 
....................     RB7 PIN 40  LED8 */ 
....................      
....................     lcd_init(); 
1A28:  GOTO   07C6
....................     kbd_init(); 
1A2C:  GOTO   0828
....................     output_A(0x00);                            //Limpiar el puerto A 
1A30:  CLRF   F92
1A32:  CLRF   F89
....................     output_B(0x00);                           //Limipiar el puerto B 
1A34:  CLRF   F93
1A36:  CLRF   F8A
....................     output_D(0x00);                           //Limipiar el puerto D 
1A38:  CLRF   F95
1A3A:  CLRF   F8C
....................    
....................     //actualizar(); 
....................     // borrar(); 
.................... menu: 
....................      lcd_putc('\f');                            //Limpiar pantalla comando 
1A3C:  MOVLW  0C
1A3E:  MOVWF  x94
1A40:  CALL   0888
....................      lcd_gotoxy(1,1);                           //escribir en a primera fila primera posicion  
1A44:  MOVLW  01
1A46:  MOVWF  x95
1A48:  MOVWF  x96
1A4A:  CALL   082C
....................      lcd_putc("   BIENVENIDOS  ");              //lo que se escribe 
1A4E:  CLRF   x8D
1A50:  MOVF   x8D,W
1A52:  CALL   009A
1A56:  IORLW  00
1A58:  BZ    1A64
1A5A:  INCF   x8D,F
1A5C:  MOVWF  x94
1A5E:  CALL   0888
1A62:  BRA    1A50
....................      lcd_gotoxy(1,2);                           //escribir en a primera fila primera posicion  
1A64:  MOVLW  01
1A66:  MOVWF  x95
1A68:  MOVLW  02
1A6A:  MOVWF  x96
1A6C:  CALL   082C
....................      lcd_putc("ARQ. COMP. TARDE"); 
1A70:  CLRF   x8D
1A72:  MOVF   x8D,W
1A74:  CALL   00BC
1A78:  IORLW  00
1A7A:  BZ    1A86
1A7C:  INCF   x8D,F
1A7E:  MOVWF  x94
1A80:  CALL   0888
1A84:  BRA    1A72
....................      delay_ms(3000); 
1A86:  MOVLW  0C
1A88:  MOVWF  x8D
1A8A:  MOVLW  FA
1A8C:  MOVWF  x95
1A8E:  CALL   071E
1A92:  DECFSZ x8D,F
1A94:  BRA    1A8A
....................     
....................      lcd_putc('\f');                            //Limpiar pantalla comando 
1A96:  MOVLW  0C
1A98:  MOVWF  x94
1A9A:  CALL   0888
....................      lcd_gotoxy(1,1);                           //escribir en a primera fila primera posicion  
1A9E:  MOVLW  01
1AA0:  MOVWF  x95
1AA2:  MOVWF  x96
1AA4:  CALL   082C
....................      lcd_putc("MIGUEL MENDEZ");                 //lo que se escribe 
1AA8:  CLRF   x8D
1AAA:  MOVF   x8D,W
1AAC:  CALL   00DE
1AB0:  IORLW  00
1AB2:  BZ    1ABE
1AB4:  INCF   x8D,F
1AB6:  MOVWF  x94
1AB8:  CALL   0888
1ABC:  BRA    1AAA
....................      lcd_gotoxy(1,2);                           //escribir en a primera fila primera posicion  
1ABE:  MOVLW  01
1AC0:  MOVWF  x95
1AC2:  MOVLW  02
1AC4:  MOVWF  x96
1AC6:  CALL   082C
....................      lcd_putc(" DAVID MARTINEZ "); 
1ACA:  CLRF   x8D
1ACC:  MOVF   x8D,W
1ACE:  CALL   00FC
1AD2:  IORLW  00
1AD4:  BZ    1AE0
1AD6:  INCF   x8D,F
1AD8:  MOVWF  x94
1ADA:  CALL   0888
1ADE:  BRA    1ACC
....................      //printf(lcd_putc,"\f   MIGUEL MENDEZ\n DAVID MARTINEZ ");// /n pase a sigueinet linea 
....................      delay_ms(3000); 
1AE0:  MOVLW  0C
1AE2:  MOVWF  x8D
1AE4:  MOVLW  FA
1AE6:  MOVWF  x95
1AE8:  CALL   071E
1AEC:  DECFSZ x8D,F
1AEE:  BRA    1AE4
....................     
....................      lcd_putc('\f');                           //Limpiar pantalla comando 
1AF0:  MOVLW  0C
1AF2:  MOVWF  x94
1AF4:  CALL   0888
....................      lcd_gotoxy(3,1);                          //escribir en a primera fila primera posicion  
1AF8:  MOVLW  03
1AFA:  MOVWF  x95
1AFC:  MOVLW  01
1AFE:  MOVWF  x96
1B00:  CALL   082C
....................      lcd_putc("GRUPO");                        //lo que se escribe 
1B04:  CLRF   x8D
1B06:  MOVF   x8D,W
1B08:  CALL   011E
1B0C:  IORLW  00
1B0E:  BZ    1B1A
1B10:  INCF   x8D,F
1B12:  MOVWF  x94
1B14:  CALL   0888
1B18:  BRA    1B06
....................      lcd_gotoxy(2,2);                          //escribir en a primera fila primera posicion  
1B1A:  MOVLW  02
1B1C:  MOVWF  x95
1B1E:  MOVWF  x96
1B20:  CALL   082C
....................      lcd_putc(" NUMERO"); 
1B24:  CLRF   x8D
1B26:  MOVF   x8D,W
1B28:  CALL   0134
1B2C:  IORLW  00
1B2E:  BZ    1B3A
1B30:  INCF   x8D,F
1B32:  MOVWF  x94
1B34:  CALL   0888
1B38:  BRA    1B26
....................      //printf(lcd_putc,"\f        GRUPO   \n       NUMERO    ");// /n pase a sigueinet linea 
....................      delay_ms(3000); 
1B3A:  MOVLW  0C
1B3C:  MOVWF  x8D
1B3E:  MOVLW  FA
1B40:  MOVWF  x95
1B42:  CALL   071E
1B46:  DECFSZ x8D,F
1B48:  BRA    1B3E
....................     
....................      lcd_putc('\f');                          //Limpiar pantalla comando 
1B4A:  MOVLW  0C
1B4C:  MOVWF  x94
1B4E:  CALL   0888
....................      lcd_gotoxy(2,1);                         //escribir en a primera fila primera posicion  
1B52:  MOVLW  02
1B54:  MOVWF  x95
1B56:  MOVLW  01
1B58:  MOVWF  x96
1B5A:  CALL   082C
....................      lcd_putc("POR FAVOR");                   //lo que se escribe 
1B5E:  CLRF   x8D
1B60:  MOVF   x8D,W
1B62:  CALL   014C
1B66:  IORLW  00
1B68:  BZ    1B74
1B6A:  INCF   x8D,F
1B6C:  MOVWF  x94
1B6E:  CALL   0888
1B72:  BRA    1B60
....................      lcd_gotoxy(1,2);                         //escribir en a primera fila primera posicion  
1B74:  MOVLW  01
1B76:  MOVWF  x95
1B78:  MOVLW  02
1B7A:  MOVWF  x96
1B7C:  CALL   082C
....................      lcd_putc("INGRESE CLAVE"); 
1B80:  CLRF   x8D
1B82:  MOVF   x8D,W
1B84:  CALL   0166
1B88:  IORLW  00
1B8A:  BZ    1B96
1B8C:  INCF   x8D,F
1B8E:  MOVWF  x94
1B90:  CALL   0888
1B94:  BRA    1B82
....................      //printf(lcd_putc,"\f    POR FAVOR   \n INGRESE CLAVE");// /n pase a sigueinet linea 
....................      delay_ms(3000); 
1B96:  MOVLW  0C
1B98:  MOVWF  x8D
1B9A:  MOVLW  FA
1B9C:  MOVWF  x95
1B9E:  CALL   071E
1BA2:  DECFSZ x8D,F
1BA4:  BRA    1B9A
....................     
....................     
....................     
....................      leer();                                    //datoi[0]= clave que le demos datoi[1]=clave que le demos 
1BA6:  GOTO   08FC
....................      leer_men_ext(); 
1BAA:  GOTO   0AA4
....................      teclado();                                 //clave [0]=0x34, clave[1]=0x78 
1BAE:  CALL   0CA6
....................       
....................  if(clave[0]==0x12 & clave[1]==0x34) 
1BB2:  MOVF   x62,W
1BB4:  SUBLW  12
1BB6:  BZ    1BBC
1BB8:  MOVLW  00
1BBA:  BRA    1BBE
1BBC:  MOVLW  01
1BBE:  MOVWF  x8D
1BC0:  MOVF   x63,W
1BC2:  SUBLW  34
1BC4:  BZ    1BCA
1BC6:  MOVLW  00
1BC8:  BRA    1BCC
1BCA:  MOVLW  01
1BCC:  ANDWF  x8D,W
1BCE:  BTFSC  FD8.2
1BD0:  BRA    1D96
....................    { 
.................... admin:  
....................       lcd_putc('\f');                           //Limpiar pantalla comando 
1BD2:  MOVLW  0C
1BD4:  MOVWF  x94
1BD6:  CALL   0888
....................       lcd_gotoxy(1,1);                          //escribir en a primera fila primera posicion  
1BDA:  MOVLW  01
1BDC:  MOVWF  x95
1BDE:  MOVWF  x96
1BE0:  CALL   082C
....................       lcd_putc("BIENVENIDOS AL");               //lo que se escribe 
1BE4:  CLRF   x8D
1BE6:  MOVF   x8D,W
1BE8:  CALL   0184
1BEC:  IORLW  00
1BEE:  BZ    1BFA
1BF0:  INCF   x8D,F
1BF2:  MOVWF  x94
1BF4:  CALL   0888
1BF8:  BRA    1BE6
....................       lcd_gotoxy(4,2);                          //escribir en a primera fila primera posicion  
1BFA:  MOVLW  04
1BFC:  MOVWF  x95
1BFE:  MOVLW  02
1C00:  MOVWF  x96
1C02:  CALL   082C
....................       lcd_putc(" MENU"); 
1C06:  CLRF   x8D
1C08:  MOVF   x8D,W
1C0A:  CALL   01A4
1C0E:  IORLW  00
1C10:  BZ    1C1C
1C12:  INCF   x8D,F
1C14:  MOVWF  x94
1C16:  CALL   0888
1C1A:  BRA    1C08
....................       //printf(lcd_putc,"\f    POR FAVOR   \n INGRESE CLAVE");// /n pase a sigueinet linea 
....................       delay_ms(3000); 
1C1C:  MOVLW  0C
1C1E:  MOVWF  x8D
1C20:  MOVLW  FA
1C22:  MOVWF  x95
1C24:  CALL   071E
1C28:  DECFSZ x8D,F
1C2A:  BRA    1C20
....................       
....................       lcd_putc('\f');                         //Limpiar pantalla comando 
1C2C:  MOVLW  0C
1C2E:  MOVWF  x94
1C30:  CALL   0888
....................       lcd_gotoxy(1,1);                        //escribir en a primera fila primera posicion  
1C34:  MOVLW  01
1C36:  MOVWF  x95
1C38:  MOVWF  x96
1C3A:  CALL   082C
....................       lcd_putc("MARQUE 1 PARA EL");           //lo que se escribe 
1C3E:  CLRF   x8D
1C40:  MOVF   x8D,W
1C42:  CALL   01BA
1C46:  IORLW  00
1C48:  BZ    1C54
1C4A:  INCF   x8D,F
1C4C:  MOVWF  x94
1C4E:  CALL   0888
1C52:  BRA    1C40
....................       lcd_gotoxy(1,2);                        //escribir en a primera fila primera posicion  
1C54:  MOVLW  01
1C56:  MOVWF  x95
1C58:  MOVLW  02
1C5A:  MOVWF  x96
1C5C:  CALL   082C
....................       lcd_putc("MENU DE DAVID"); 
1C60:  CLRF   x8D
1C62:  MOVF   x8D,W
1C64:  CALL   01DC
1C68:  IORLW  00
1C6A:  BZ    1C76
1C6C:  INCF   x8D,F
1C6E:  MOVWF  x94
1C70:  CALL   0888
1C74:  BRA    1C62
....................       //printf(lcd_putc,"\f    POR FAVOR   \n INGRESE CLAVE");// /n pase a sigueinet linea 
....................       delay_ms(3000); 
1C76:  MOVLW  0C
1C78:  MOVWF  x8D
1C7A:  MOVLW  FA
1C7C:  MOVWF  x95
1C7E:  CALL   071E
1C82:  DECFSZ x8D,F
1C84:  BRA    1C7A
....................     
....................       lcd_putc('\f');                         //Limpiar pantalla comando 
1C86:  MOVLW  0C
1C88:  MOVWF  x94
1C8A:  CALL   0888
....................       lcd_gotoxy(1,1);                        //escribir en a primera fila primera posicion  
1C8E:  MOVLW  01
1C90:  MOVWF  x95
1C92:  MOVWF  x96
1C94:  CALL   082C
....................       lcd_putc("MARQUE 2 PARA EL");           //lo que se escribe 
1C98:  CLRF   x8D
1C9A:  MOVF   x8D,W
1C9C:  CALL   01FA
1CA0:  IORLW  00
1CA2:  BZ    1CAE
1CA4:  INCF   x8D,F
1CA6:  MOVWF  x94
1CA8:  CALL   0888
1CAC:  BRA    1C9A
....................       lcd_gotoxy(1,2);                        //escribir en a primera fila primera posicion  
1CAE:  MOVLW  01
1CB0:  MOVWF  x95
1CB2:  MOVLW  02
1CB4:  MOVWF  x96
1CB6:  CALL   082C
....................       lcd_putc("MENU DE MIGUEL"); 
1CBA:  CLRF   x8D
1CBC:  MOVF   x8D,W
1CBE:  CALL   021C
1CC2:  IORLW  00
1CC4:  BZ    1CD0
1CC6:  INCF   x8D,F
1CC8:  MOVWF  x94
1CCA:  CALL   0888
1CCE:  BRA    1CBC
....................       //printf(lcd_putc,"\f    POR FAVOR   \n INGRESE CLAVE");// /n pase a sigueinet linea 
....................       delay_ms(3000); 
1CD0:  MOVLW  0C
1CD2:  MOVWF  x8D
1CD4:  MOVLW  FA
1CD6:  MOVWF  x95
1CD8:  CALL   071E
1CDC:  DECFSZ x8D,F
1CDE:  BRA    1CD4
....................      
....................       lcd_putc('\f');                         //Limpiar pantalla comando 
1CE0:  MOVLW  0C
1CE2:  MOVWF  x94
1CE4:  CALL   0888
....................       lcd_gotoxy(1,1);                        //escribir en a primera fila primera posicion  
1CE8:  MOVLW  01
1CEA:  MOVWF  x95
1CEC:  MOVWF  x96
1CEE:  CALL   082C
....................       lcd_putc("MARQUE 3 PARA ");             //lo que se escribe 
1CF2:  CLRF   x8D
1CF4:  MOVF   x8D,W
1CF6:  CALL   023C
1CFA:  IORLW  00
1CFC:  BZ    1D08
1CFE:  INCF   x8D,F
1D00:  MOVWF  x94
1D02:  CALL   0888
1D06:  BRA    1CF4
....................       lcd_gotoxy(1,2);                        //escribir en a primera fila primera posicion  
1D08:  MOVLW  01
1D0A:  MOVWF  x95
1D0C:  MOVLW  02
1D0E:  MOVWF  x96
1D10:  CALL   082C
....................       lcd_putc("SALIR"); 
1D14:  CLRF   x8D
1D16:  MOVF   x8D,W
1D18:  CALL   025C
1D1C:  IORLW  00
1D1E:  BZ    1D2A
1D20:  INCF   x8D,F
1D22:  MOVWF  x94
1D24:  CALL   0888
1D28:  BRA    1D16
....................       //printf(lcd_putc,"\f    POR FAVOR   \n INGRESE CLAVE");// /n pase a sigueinet linea 
....................        delay_ms(3000); 
1D2A:  MOVLW  0C
1D2C:  MOVWF  x8D
1D2E:  MOVLW  FA
1D30:  MOVWF  x95
1D32:  CALL   071E
1D36:  DECFSZ x8D,F
1D38:  BRA    1D2E
....................     
....................     
....................        //bienvenidos al menu del diseador 
....................        //marque 1 para menu de MIGUEL 
....................        //marque 2 para menu de David 
....................        //marque 3 salir  */ 
....................         
....................         
....................      un_digito(); 
1D3A:  CALL   0E44
....................     if(datom==0x01) 
1D3E:  DECFSZ x72,W
1D40:  BRA    1D46
....................      { 
....................         goto David; 
1D42:  GOTO   2694
....................      } 
....................      if(datom==0x02) 
1D46:  MOVF   x72,W
1D48:  SUBLW  02
1D4A:  BNZ   1D4E
....................      { 
....................         goto Miguel; 
1D4C:  BRA    1DB8
....................      } 
....................      if(datom==0x03) 
1D4E:  MOVF   x72,W
1D50:  SUBLW  03
1D52:  BNZ   1D56
....................      { 
....................         reset_cpu();                        //salir 
1D54:  RESET
....................      } 
....................      lcd_putc('\f');                        //Limpiar pantalla comando 
1D56:  MOVLW  0C
1D58:  MOVWF  x94
1D5A:  CALL   0888
....................      lcd_gotoxy(1,2);                       //escribir en a primera fila primera posicion  
1D5E:  MOVLW  01
1D60:  MOVWF  x95
1D62:  MOVLW  02
1D64:  MOVWF  x96
1D66:  CALL   082C
....................      lcd_putc("ERROR DE NUMERO");           //lo que se escribe 
1D6A:  CLRF   x8D
1D6C:  MOVF   x8D,W
1D6E:  CALL   0272
1D72:  IORLW  00
1D74:  BZ    1D80
1D76:  INCF   x8D,F
1D78:  MOVWF  x94
1D7A:  CALL   0888
1D7E:  BRA    1D6C
....................      delay_ms(3000); 
1D80:  MOVLW  0C
1D82:  MOVWF  x8D
1D84:  MOVLW  FA
1D86:  MOVWF  x95
1D88:  CALL   071E
1D8C:  DECFSZ x8D,F
1D8E:  BRA    1D84
....................      goto admin; 
1D90:  BRA    1BD2
....................      }  
....................      else if(clave[0]==datoe[0] & clave[1]==datoe[1]) 
1D92:  GOTO   2F86
1D96:  MOVF   x6A,W
1D98:  SUBWF  x62,W
1D9A:  BZ    1DA0
1D9C:  MOVLW  00
1D9E:  BRA    1DA2
1DA0:  MOVLW  01
1DA2:  MOVWF  x8D
1DA4:  MOVF   x6B,W
1DA6:  SUBWF  x63,W
1DA8:  BZ    1DAE
1DAA:  MOVLW  00
1DAC:  BRA    1DB0
1DAE:  MOVLW  01
1DB0:  ANDWF  x8D,W
1DB2:  BTFSC  FD8.2
1DB4:  GOTO   2672
....................       { 
.................... Miguel:adres=0x00; 
1DB8:  CLRF   x6E
....................        /*escribirle al lcd 
....................        bienvenidos al menu del diseador 
....................        marque 1 para cambiar clave 
....................        marque 2 para fecha y hora 
....................        marque 3 para reportes 
....................        marque 4 para motor paso a paso 
....................        marque 5 para servomotor 
....................        marque 6 para cad 
....................        marque 7 para DTMF 
....................        marque 8 para sensores 
....................        marque 9 para salir*/ 
....................       
....................     lcd_putc('\f');                       //Limpiar pantalla comando 
1DBA:  MOVLW  0C
1DBC:  MOVWF  x94
1DBE:  CALL   0888
....................     lcd_gotoxy(1,1);                      //escribir en a primera fila primera posicion  
1DC2:  MOVLW  01
1DC4:  MOVWF  x95
1DC6:  MOVWF  x96
1DC8:  CALL   082C
....................     lcd_putc("MENU USUAR.");              //lo que se escribe 
1DCC:  CLRF   x8D
1DCE:  MOVF   x8D,W
1DD0:  CALL   0292
1DD4:  IORLW  00
1DD6:  BZ    1DE2
1DD8:  INCF   x8D,F
1DDA:  MOVWF  x94
1DDC:  CALL   0888
1DE0:  BRA    1DCE
....................     lcd_gotoxy(1,2);                      //escribir en a primera fila primera posicion  
1DE2:  MOVLW  01
1DE4:  MOVWF  x95
1DE6:  MOVLW  02
1DE8:  MOVWF  x96
1DEA:  CALL   082C
....................     lcd_putc("MIGUEL"); 
1DEE:  CLRF   x8D
1DF0:  MOVF   x8D,W
1DF2:  CALL   02AE
1DF6:  IORLW  00
1DF8:  BZ    1E04
1DFA:  INCF   x8D,F
1DFC:  MOVWF  x94
1DFE:  CALL   0888
1E02:  BRA    1DF0
....................     delay_ms(3000);  
1E04:  MOVLW  0C
1E06:  MOVWF  x8D
1E08:  MOVLW  FA
1E0A:  MOVWF  x95
1E0C:  CALL   071E
1E10:  DECFSZ x8D,F
1E12:  BRA    1E08
....................         
....................     lcd_putc('\f');                       //Limpiar pantalla comando 
1E14:  MOVLW  0C
1E16:  MOVWF  x94
1E18:  CALL   0888
....................     lcd_gotoxy(1,1);                      //escribir en a primera fila primera posicion  
1E1C:  MOVLW  01
1E1E:  MOVWF  x95
1E20:  MOVWF  x96
1E22:  CALL   082C
....................     lcd_putc("MARQUE NUM PARA");          //lo que se escribe 
1E26:  CLRF   x8D
1E28:  MOVF   x8D,W
1E2A:  CALL   02C6
1E2E:  IORLW  00
1E30:  BZ    1E3C
1E32:  INCF   x8D,F
1E34:  MOVWF  x94
1E36:  CALL   0888
1E3A:  BRA    1E28
....................     lcd_gotoxy(1,2);                      //escribir en a primera fila primera posicion  
1E3C:  MOVLW  01
1E3E:  MOVWF  x95
1E40:  MOVLW  02
1E42:  MOVWF  x96
1E44:  CALL   082C
....................     lcd_putc("1 CAMBIAR CLAVE"); 
1E48:  CLRF   x8D
1E4A:  MOVF   x8D,W
1E4C:  CALL   02E6
1E50:  IORLW  00
1E52:  BZ    1E5E
1E54:  INCF   x8D,F
1E56:  MOVWF  x94
1E58:  CALL   0888
1E5C:  BRA    1E4A
....................     delay_ms(3000);   
1E5E:  MOVLW  0C
1E60:  MOVWF  x8D
1E62:  MOVLW  FA
1E64:  MOVWF  x95
1E66:  CALL   071E
1E6A:  DECFSZ x8D,F
1E6C:  BRA    1E62
....................      
....................     lcd_putc('\f');                      //Limpiar pantalla comando 
1E6E:  MOVLW  0C
1E70:  MOVWF  x94
1E72:  CALL   0888
....................     lcd_gotoxy(1,1);                     //escribir en a primera fila primera posicion  
1E76:  MOVLW  01
1E78:  MOVWF  x95
1E7A:  MOVWF  x96
1E7C:  CALL   082C
....................     lcd_putc("2 FECHA Y HORA");          //lo que se escribe 
1E80:  CLRF   x8D
1E82:  MOVF   x8D,W
1E84:  CALL   0306
1E88:  IORLW  00
1E8A:  BZ    1E96
1E8C:  INCF   x8D,F
1E8E:  MOVWF  x94
1E90:  CALL   0888
1E94:  BRA    1E82
....................     lcd_gotoxy(1,2);                     //escribir en a primera fila primera posicion  
1E96:  MOVLW  01
1E98:  MOVWF  x95
1E9A:  MOVLW  02
1E9C:  MOVWF  x96
1E9E:  CALL   082C
....................     lcd_putc("3 REPORTES"); 
1EA2:  CLRF   x8D
1EA4:  MOVF   x8D,W
1EA6:  CALL   0326
1EAA:  IORLW  00
1EAC:  BZ    1EB8
1EAE:  INCF   x8D,F
1EB0:  MOVWF  x94
1EB2:  CALL   0888
1EB6:  BRA    1EA4
....................     delay_ms(3000); 
1EB8:  MOVLW  0C
1EBA:  MOVWF  x8D
1EBC:  MOVLW  FA
1EBE:  MOVWF  x95
1EC0:  CALL   071E
1EC4:  DECFSZ x8D,F
1EC6:  BRA    1EBC
....................      
....................     lcd_putc('\f');                      //Limpiar pantalla comando 
1EC8:  MOVLW  0C
1ECA:  MOVWF  x94
1ECC:  CALL   0888
....................     lcd_gotoxy(1,1);                     //escribir en a primera fila primera posicion  
1ED0:  MOVLW  01
1ED2:  MOVWF  x95
1ED4:  MOVWF  x96
1ED6:  CALL   082C
....................     lcd_putc("4 MOTOR PASAPAS");        //lo que se escribe 
1EDA:  CLRF   x8D
1EDC:  MOVF   x8D,W
1EDE:  CALL   0342
1EE2:  IORLW  00
1EE4:  BZ    1EF0
1EE6:  INCF   x8D,F
1EE8:  MOVWF  x94
1EEA:  CALL   0888
1EEE:  BRA    1EDC
....................     lcd_gotoxy(1,2);                     //escribir en a primera fila primera posicion  
1EF0:  MOVLW  01
1EF2:  MOVWF  x95
1EF4:  MOVLW  02
1EF6:  MOVWF  x96
1EF8:  CALL   082C
....................     lcd_putc("5 SERVOMOTOR"); 
1EFC:  CLRF   x8D
1EFE:  MOVF   x8D,W
1F00:  CALL   0362
1F04:  IORLW  00
1F06:  BZ    1F12
1F08:  INCF   x8D,F
1F0A:  MOVWF  x94
1F0C:  CALL   0888
1F10:  BRA    1EFE
....................     delay_ms(3000); 
1F12:  MOVLW  0C
1F14:  MOVWF  x8D
1F16:  MOVLW  FA
1F18:  MOVWF  x95
1F1A:  CALL   071E
1F1E:  DECFSZ x8D,F
1F20:  BRA    1F16
....................      
....................     lcd_putc('\f');                      //Limpiar pantalla comando 
1F22:  MOVLW  0C
1F24:  MOVWF  x94
1F26:  CALL   0888
....................     lcd_gotoxy(1,1);                     //escribir en a primera fila primera posicion  
1F2A:  MOVLW  01
1F2C:  MOVWF  x95
1F2E:  MOVWF  x96
1F30:  CALL   082C
....................     lcd_putc("6 CAD");                   //lo que se escribe 
1F34:  CLRF   x8D
1F36:  MOVF   x8D,W
1F38:  CALL   0380
1F3C:  IORLW  00
1F3E:  BZ    1F4A
1F40:  INCF   x8D,F
1F42:  MOVWF  x94
1F44:  CALL   0888
1F48:  BRA    1F36
....................     lcd_gotoxy(1,2);                     //escribir en a primera fila primera posicion  
1F4A:  MOVLW  01
1F4C:  MOVWF  x95
1F4E:  MOVLW  02
1F50:  MOVWF  x96
1F52:  CALL   082C
....................     lcd_putc("7 DTMF"); 
1F56:  CLRF   x8D
1F58:  MOVF   x8D,W
1F5A:  CALL   0396
1F5E:  IORLW  00
1F60:  BZ    1F6C
1F62:  INCF   x8D,F
1F64:  MOVWF  x94
1F66:  CALL   0888
1F6A:  BRA    1F58
....................     delay_ms(3000); 
1F6C:  MOVLW  0C
1F6E:  MOVWF  x8D
1F70:  MOVLW  FA
1F72:  MOVWF  x95
1F74:  CALL   071E
1F78:  DECFSZ x8D,F
1F7A:  BRA    1F70
....................      
....................     lcd_putc('\f');                      //Limpiar pantalla comando 
1F7C:  MOVLW  0C
1F7E:  MOVWF  x94
1F80:  CALL   0888
....................     lcd_gotoxy(1,1);                     //escribir en a primera fila primera posicion  
1F84:  MOVLW  01
1F86:  MOVWF  x95
1F88:  MOVWF  x96
1F8A:  CALL   082C
....................     lcd_putc("8 SENSORES");              //lo que se escribe 
1F8E:  CLRF   x8D
1F90:  MOVF   x8D,W
1F92:  CALL   03AE
1F96:  IORLW  00
1F98:  BZ    1FA4
1F9A:  INCF   x8D,F
1F9C:  MOVWF  x94
1F9E:  CALL   0888
1FA2:  BRA    1F90
....................     lcd_gotoxy(3,2);                     //escribir en a primera fila primera posicion  
1FA4:  MOVLW  03
1FA6:  MOVWF  x95
1FA8:  MOVLW  02
1FAA:  MOVWF  x96
1FAC:  CALL   082C
....................     lcd_putc("9 SALIR"); 
1FB0:  CLRF   x8D
1FB2:  MOVF   x8D,W
1FB4:  CALL   03CA
1FB8:  IORLW  00
1FBA:  BZ    1FC6
1FBC:  INCF   x8D,F
1FBE:  MOVWF  x94
1FC0:  CALL   0888
1FC4:  BRA    1FB2
....................     delay_ms(3000); 
1FC6:  MOVLW  0C
1FC8:  MOVWF  x8D
1FCA:  MOVLW  FA
1FCC:  MOVWF  x95
1FCE:  CALL   071E
1FD2:  DECFSZ x8D,F
1FD4:  BRA    1FCA
....................      
....................     un_digito(); 
1FD6:  CALL   0E44
....................     if(datom==0x01) 
1FDA:  DECFSZ x72,W
1FDC:  BRA    215E
....................      { 
....................         lcd_putc('\f');                   //Limpiar pantalla comando 
1FDE:  MOVLW  0C
1FE0:  MOVWF  x94
1FE2:  CALL   0888
....................         lcd_gotoxy(1,1);                  //escribir en a primera fila primera posicion  
1FE6:  MOVLW  01
1FE8:  MOVWF  x95
1FEA:  MOVWF  x96
1FEC:  CALL   082C
....................         lcd_putc("MEN CAMBIAR CLAV");     //lo que se escribe 
1FF0:  CLRF   x8D
1FF2:  MOVF   x8D,W
1FF4:  CALL   03E2
1FF8:  IORLW  00
1FFA:  BZ    2006
1FFC:  INCF   x8D,F
1FFE:  MOVWF  x94
2000:  CALL   0888
2004:  BRA    1FF2
....................         lcd_gotoxy(3,2);                  //escribir en a primera fila primera posicion  
2006:  MOVLW  03
2008:  MOVWF  x95
200A:  MOVLW  02
200C:  MOVWF  x96
200E:  CALL   082C
....................         lcd_putc("DIGITE NU. CLAVE");     //clave[0]= y clave[1]= 
2012:  CLRF   x8D
2014:  MOVF   x8D,W
2016:  CALL   0404
201A:  IORLW  00
201C:  BZ    2028
201E:  INCF   x8D,F
2020:  MOVWF  x94
2022:  CALL   0888
2026:  BRA    2014
....................         delay_ms(3000); 
2028:  MOVLW  0C
202A:  MOVWF  x8D
202C:  MOVLW  FA
202E:  MOVWF  x95
2030:  CALL   071E
2034:  DECFSZ x8D,F
2036:  BRA    202C
....................         teclado(); 
2038:  CALL   0CA6
....................         
....................         dato1=clave[0]; 
203C:  MOVFF  62,6F
....................         dato2=clave[1]; 
2040:  MOVFF  63,70
....................         
....................         lcd_putc('\f');                   //Limpiar pantalla comando 
2044:  MOVLW  0C
2046:  MOVWF  x94
2048:  CALL   0888
....................         lcd_gotoxy(1,1);                  //escribir en a primera fila primera posicion  
204C:  MOVLW  01
204E:  MOVWF  x95
2050:  MOVWF  x96
2052:  CALL   082C
....................         lcd_putc("POR FAVOR DIGITE");     //lo que se escribe 
2056:  CLRF   x8D
2058:  MOVF   x8D,W
205A:  CALL   0426
205E:  IORLW  00
2060:  BZ    206C
2062:  INCF   x8D,F
2064:  MOVWF  x94
2066:  CALL   0888
206A:  BRA    2058
....................         lcd_gotoxy(1,2);                  //escribir en a primera fila primera posicion  
206C:  MOVLW  01
206E:  MOVWF  x95
2070:  MOVLW  02
2072:  MOVWF  x96
2074:  CALL   082C
....................         lcd_putc("DIGITE NUE.CLAVE");    
2078:  CLRF   x8D
207A:  MOVF   x8D,W
207C:  CALL   0448
2080:  IORLW  00
2082:  BZ    208E
2084:  INCF   x8D,F
2086:  MOVWF  x94
2088:  CALL   0888
208C:  BRA    207A
....................         delay_ms(3000); 
208E:  MOVLW  0C
2090:  MOVWF  x8D
2092:  MOVLW  FA
2094:  MOVWF  x95
2096:  CALL   071E
209A:  DECFSZ x8D,F
209C:  BRA    2092
....................         
....................         teclado(); 
209E:  CALL   0CA6
....................         
....................        if(clave[0]==dato1 & clave[1]==dato2) 
20A2:  MOVF   x6F,W
20A4:  SUBWF  x62,W
20A6:  BZ    20AC
20A8:  MOVLW  00
20AA:  BRA    20AE
20AC:  MOVLW  01
20AE:  MOVWF  x8D
20B0:  MOVF   x70,W
20B2:  SUBWF  x63,W
20B4:  BZ    20BA
20B6:  MOVLW  00
20B8:  BRA    20BC
20BA:  MOVLW  01
20BC:  ANDWF  x8D,W
20BE:  BZ    2122
....................        { 
....................          escribir_memoria_ext(); 
20C0:  CALL   0F98
....................          lcd_putc('\f');                   //Limpiar pantalla comando 
20C4:  MOVLW  0C
20C6:  MOVWF  x94
20C8:  CALL   0888
....................          lcd_gotoxy(1,1);                  //escribir en a primera fila primera posicion  
20CC:  MOVLW  01
20CE:  MOVWF  x95
20D0:  MOVWF  x96
20D2:  CALL   082C
....................          lcd_putc("CLAVE MODIFICADA");     //lo que se escribe 
20D6:  CLRF   x8D
20D8:  MOVF   x8D,W
20DA:  CALL   046A
20DE:  IORLW  00
20E0:  BZ    20EC
20E2:  INCF   x8D,F
20E4:  MOVWF  x94
20E6:  CALL   0888
20EA:  BRA    20D8
....................          lcd_gotoxy(3,2);                  //escribir en a primera fila primera posicion  
20EC:  MOVLW  03
20EE:  MOVWF  x95
20F0:  MOVLW  02
20F2:  MOVWF  x96
20F4:  CALL   082C
....................          lcd_putc("CON EXITO");    
20F8:  CLRF   x8D
20FA:  MOVF   x8D,W
20FC:  CALL   048C
2100:  IORLW  00
2102:  BZ    210E
2104:  INCF   x8D,F
2106:  MOVWF  x94
2108:  CALL   0888
210C:  BRA    20FA
....................          delay_ms(3000); 
210E:  MOVLW  0C
2110:  MOVWF  x8D
2112:  MOVLW  FA
2114:  MOVWF  x95
2116:  CALL   071E
211A:  DECFSZ x8D,F
211C:  BRA    2112
....................          goto Miguel; 
211E:  BRA    1DB8
....................        } 
....................        else{ 
2120:  BRA    215C
....................             lcd_putc('\f');                   //Limpiar pantalla comando 
2122:  MOVLW  0C
2124:  MOVWF  x94
2126:  CALL   0888
....................             lcd_gotoxy(1,1);                  //escribir en a primera fila primera posicion  
212A:  MOVLW  01
212C:  MOVWF  x95
212E:  MOVWF  x96
2130:  CALL   082C
....................             lcd_putc("ERROR DE CLAVE");     //lo que se escribe 
2134:  CLRF   x8D
2136:  MOVF   x8D,W
2138:  CALL   04A6
213C:  IORLW  00
213E:  BZ    214A
2140:  INCF   x8D,F
2142:  MOVWF  x94
2144:  CALL   0888
2148:  BRA    2136
....................             delay_ms(3000); 
214A:  MOVLW  0C
214C:  MOVWF  x8D
214E:  MOVLW  FA
2150:  MOVWF  x95
2152:  CALL   071E
2156:  DECFSZ x8D,F
2158:  BRA    214E
....................             goto Miguel; 
215A:  BRA    1DB8
....................             } 
....................        
....................        
....................      } 
....................      else if(datom==0x02) 
215C:  BRA    266E
215E:  MOVF   x72,W
2160:  SUBLW  02
2162:  BNZ   21B4
....................      { 
....................        lcd_putc('\f');                  //Limpiar pantalla comando 
2164:  MOVLW  0C
2166:  MOVWF  x94
2168:  CALL   0888
....................        lcd_gotoxy(1,1);                 //escribir en a primera fila primera posicion  
216C:  MOVLW  01
216E:  MOVWF  x95
2170:  MOVWF  x96
2172:  CALL   082C
....................        lcd_putc("MEN FECHA Y HORA");    //lo que se escribe 
2176:  CLRF   x8D
2178:  MOVF   x8D,W
217A:  CALL   04C6
217E:  IORLW  00
2180:  BZ    218C
2182:  INCF   x8D,F
2184:  MOVWF  x94
2186:  CALL   0888
218A:  BRA    2178
....................        delay_ms(3000); 
218C:  MOVLW  0C
218E:  MOVWF  x8D
2190:  MOVLW  FA
2192:  MOVWF  x95
2194:  CALL   071E
2198:  DECFSZ x8D,F
219A:  BRA    2190
....................        hora_fecha(); 
219C:  CALL   11BE
....................        delay_ms(10000); 
21A0:  MOVLW  28
21A2:  MOVWF  x8D
21A4:  MOVLW  FA
21A6:  MOVWF  x95
21A8:  CALL   071E
21AC:  DECFSZ x8D,F
21AE:  BRA    21A4
....................        goto Miguel; 
21B0:  BRA    1DB8
....................      } 
....................      else if(datom==0x03)///////////////////////////////////////// 
21B2:  BRA    266E
21B4:  MOVF   x72,W
21B6:  SUBLW  03
21B8:  BTFSS  FD8.2
21BA:  BRA    239A
....................      { 
....................        ide=0x13; 
21BC:  MOVLW  13
21BE:  MOVWF  x7B
....................        lcd_putc('\f');                                         //Limpiar pantalla comando 
21C0:  MOVLW  0C
21C2:  MOVWF  x94
21C4:  CALL   0888
....................        lcd_gotoxy(1,1);                                        //escribir en a primera fila primera posicion  
21C8:  MOVLW  01
21CA:  MOVWF  x95
21CC:  MOVWF  x96
21CE:  CALL   082C
....................        lcd_putc("MENU REPORTES");                              //lo que se escribe 
21D2:  CLRF   x8D
21D4:  MOVF   x8D,W
21D6:  CALL   04E8
21DA:  IORLW  00
21DC:  BZ    21E8
21DE:  INCF   x8D,F
21E0:  MOVWF  x94
21E2:  CALL   0888
21E6:  BRA    21D4
....................        delay_ms(3000); 
21E8:  MOVLW  0C
21EA:  MOVWF  x8D
21EC:  MOVLW  FA
21EE:  MOVWF  x95
21F0:  CALL   071E
21F4:  DECFSZ x8D,F
21F6:  BRA    21EC
....................         
....................        lcd_putc('\f');                                         //Limpiar pantalla comando 
21F8:  MOVLW  0C
21FA:  MOVWF  x94
21FC:  CALL   0888
....................        lcd_gotoxy(1,1);                                        //escribir en a primera fila primera posicion  
2200:  MOVLW  01
2202:  MOVWF  x95
2204:  MOVWF  x96
2206:  CALL   082C
....................        lcd_putc("1 GENERAR.REPORT");                           //lo que se escribe 
220A:  CLRF   x8D
220C:  MOVF   x8D,W
220E:  CALL   0506
2212:  IORLW  00
2214:  BZ    2220
2216:  INCF   x8D,F
2218:  MOVWF  x94
221A:  CALL   0888
221E:  BRA    220C
....................        lcd_gotoxy(1,2);                                        //escribir en a primera fila primera posicion  
2220:  MOVLW  01
2222:  MOVWF  x95
2224:  MOVLW  02
2226:  MOVWF  x96
2228:  CALL   082C
....................        lcd_putc("2 MOSTRAR.REPORT");                           //lo que se escribe 
222C:  CLRF   x8D
222E:  MOVF   x8D,W
2230:  CALL   0528
2234:  IORLW  00
2236:  BZ    2242
2238:  INCF   x8D,F
223A:  MOVWF  x94
223C:  CALL   0888
2240:  BRA    222E
....................        delay_ms(3000); 
2242:  MOVLW  0C
2244:  MOVWF  x8D
2246:  MOVLW  FA
2248:  MOVWF  x95
224A:  CALL   071E
224E:  DECFSZ x8D,F
2250:  BRA    2246
....................        un_digito(); 
2252:  CALL   0E44
....................      if(datom==0x01){ 
2256:  DECFSZ x72,W
2258:  BRA    2336
....................          buscar_pos();                                           //CONTADOR, ADDRESS, ESPACIO_VACIO=TRU 
225A:  CALL   1478
....................        if(espacio_vacio==true){ 
225E:  BTFSS  0E.2
2260:  BRA    22FA
....................            
....................             hacer_reporte(); 
2262:  CALL   14E6
....................           for(i=0;i<8;i++){ 
2266:  CLRF   x60
2268:  MOVF   x60,W
226A:  SUBLW  07
226C:  BNC   229C
....................                write_ext_eeprom(adres, time[i]); 
226E:  CLRF   03
2270:  MOVF   x60,W
2272:  ADDLW  83
2274:  MOVWF  FE9
2276:  MOVLW  00
2278:  ADDWFC 03,W
227A:  MOVWF  FEA
227C:  MOVFF  FEF,8D
2280:  CLRF   x8F
2282:  MOVFF  6E,8E
2286:  MOVFF  8D,90
228A:  CALL   0EA6
....................                adres++; 
228E:  INCF   x6E,F
....................                delay_ms(5); 
2290:  MOVLW  05
2292:  MOVWF  x95
2294:  CALL   071E
....................                 
....................           } 
2298:  INCF   x60,F
229A:  BRA    2268
....................            lcd_putc('\f');                    //Limpiar pantalla comando 
229C:  MOVLW  0C
229E:  MOVWF  x94
22A0:  CALL   0888
....................                lcd_gotoxy(1,1);               //escribir en a primera fila primera posicion  
22A4:  MOVLW  01
22A6:  MOVWF  x95
22A8:  MOVWF  x96
22AA:  CALL   082C
....................                lcd_putc("REPORTE GUARDADO");  //lo que se escribe 
22AE:  CLRF   x8D
22B0:  MOVF   x8D,W
22B2:  CALL   054A
22B6:  IORLW  00
22B8:  BZ    22C4
22BA:  INCF   x8D,F
22BC:  MOVWF  x94
22BE:  CALL   0888
22C2:  BRA    22B0
....................                lcd_gotoxy(1,2);               //escribir en a primera fila primera posicion  
22C4:  MOVLW  01
22C6:  MOVWF  x95
22C8:  MOVLW  02
22CA:  MOVWF  x96
22CC:  CALL   082C
....................                lcd_putc("CON EXITO");         //lo que se escribe 
22D0:  CLRF   x8D
22D2:  MOVF   x8D,W
22D4:  CALL   048C
22D8:  IORLW  00
22DA:  BZ    22E6
22DC:  INCF   x8D,F
22DE:  MOVWF  x94
22E0:  CALL   0888
22E4:  BRA    22D2
....................                delay_ms(3000); 
22E6:  MOVLW  0C
22E8:  MOVWF  x8D
22EA:  MOVLW  FA
22EC:  MOVWF  x95
22EE:  CALL   071E
22F2:  DECFSZ x8D,F
22F4:  BRA    22EA
....................                goto Miguel; 
22F6:  BRA    1DB8
....................         }else{ 
22F8:  BRA    2334
....................                lcd_putc('\f');               //Limpiar pantalla comando 
22FA:  MOVLW  0C
22FC:  MOVWF  x94
22FE:  CALL   0888
....................                lcd_gotoxy(1,1);              //escribir en a primera fila primera posicion  
2302:  MOVLW  01
2304:  MOVWF  x95
2306:  MOVWF  x96
2308:  CALL   082C
....................                lcd_putc("MEMORIA LLENA");    //lo que se escribe 
230C:  CLRF   x8D
230E:  MOVF   x8D,W
2310:  CALL   056C
2314:  IORLW  00
2316:  BZ    2322
2318:  INCF   x8D,F
231A:  MOVWF  x94
231C:  CALL   0888
2320:  BRA    230E
....................                delay_ms(3000); 
2322:  MOVLW  0C
2324:  MOVWF  x8D
2326:  MOVLW  FA
2328:  MOVWF  x95
232A:  CALL   071E
232E:  DECFSZ x8D,F
2330:  BRA    2326
....................                goto Miguel; 
2332:  BRA    1DB8
....................                 
....................               } 
....................      }else if (datom==0x02) { 
2334:  BRA    2398
2336:  MOVF   x72,W
2338:  SUBLW  02
233A:  BNZ   2344
....................                 mostrar_reporte(); 
233C:  CALL   16A2
....................                 goto Miguel; 
2340:  BRA    1DB8
....................                 } 
....................                  else{ lcd_gotoxy(1,1);               //escribir en a primera fila primera posicion  
2342:  BRA    2398
2344:  MOVLW  01
2346:  MOVWF  x95
2348:  MOVWF  x96
234A:  CALL   082C
....................                        lcd_putc("NUMERO");            //lo que se escribe 
234E:  CLRF   x8D
2350:  MOVF   x8D,W
2352:  CALL   058A
2356:  IORLW  00
2358:  BZ    2364
235A:  INCF   x8D,F
235C:  MOVWF  x94
235E:  CALL   0888
2362:  BRA    2350
....................                        lcd_gotoxy(1,2);               //escribir en a primera fila primera posicion  
2364:  MOVLW  01
2366:  MOVWF  x95
2368:  MOVLW  02
236A:  MOVWF  x96
236C:  CALL   082C
....................                        lcd_putc("ERROR");             //lo que se escribe 
2370:  CLRF   x8D
2372:  MOVF   x8D,W
2374:  CALL   05A2
2378:  IORLW  00
237A:  BZ    2386
237C:  INCF   x8D,F
237E:  MOVWF  x94
2380:  CALL   0888
2384:  BRA    2372
....................                        delay_ms(3000); 
2386:  MOVLW  0C
2388:  MOVWF  x8D
238A:  MOVLW  FA
238C:  MOVWF  x95
238E:  CALL   071E
2392:  DECFSZ x8D,F
2394:  BRA    238A
....................                        goto Miguel;} 
2396:  BRA    1DB8
....................                
....................                 
....................      } 
....................      else if(datom==0x04) 
2398:  BRA    266E
239A:  MOVF   x72,W
239C:  SUBLW  04
239E:  BTFSS  FD8.2
23A0:  BRA    2490
....................      { 
....................        lcd_putc('\f');                        //Limpiar pantalla comando 
23A2:  MOVLW  0C
23A4:  MOVWF  x94
23A6:  CALL   0888
....................        lcd_gotoxy(1,1);                       //escribir en a primera fila primera posicion  
23AA:  MOVLW  01
23AC:  MOVWF  x95
23AE:  MOVWF  x96
23B0:  CALL   082C
....................        lcd_putc("MEN MOTOR PAS A.");          //lo que se escribe 
23B4:  CLRF   x8D
23B6:  MOVF   x8D,W
23B8:  CALL   05B8
23BC:  IORLW  00
23BE:  BZ    23CA
23C0:  INCF   x8D,F
23C2:  MOVWF  x94
23C4:  CALL   0888
23C8:  BRA    23B6
....................        delay_ms(3000); 
23CA:  MOVLW  0C
23CC:  MOVWF  x8D
23CE:  MOVLW  FA
23D0:  MOVWF  x95
23D2:  CALL   071E
23D6:  DECFSZ x8D,F
23D8:  BRA    23CE
....................         
....................        lcd_putc('\f');                        //Limpiar pantalla comando 
23DA:  MOVLW  0C
23DC:  MOVWF  x94
23DE:  CALL   0888
....................        lcd_gotoxy(1,1);                       //escribir en a primera fila primera posicion  
23E2:  MOVLW  01
23E4:  MOVWF  x95
23E6:  MOVWF  x96
23E8:  CALL   082C
....................        lcd_putc("1 PARA DERECHA");            //lo que se escribe 
23EC:  CLRF   x8D
23EE:  MOVF   x8D,W
23F0:  CALL   05DA
23F4:  IORLW  00
23F6:  BZ    2402
23F8:  INCF   x8D,F
23FA:  MOVWF  x94
23FC:  CALL   0888
2400:  BRA    23EE
....................        lcd_gotoxy(1,2);                       //escribir en a primera fila primera posicion  
2402:  MOVLW  01
2404:  MOVWF  x95
2406:  MOVLW  02
2408:  MOVWF  x96
240A:  CALL   082C
....................        lcd_putc("2 PARA IZQUIERDA");          //lo que se escribe 
240E:  CLRF   x8D
2410:  MOVF   x8D,W
2412:  CALL   05FA
2416:  IORLW  00
2418:  BZ    2424
241A:  INCF   x8D,F
241C:  MOVWF  x94
241E:  CALL   0888
2422:  BRA    2410
....................        delay_ms(3000); 
2424:  MOVLW  0C
2426:  MOVWF  x8D
2428:  MOVLW  FA
242A:  MOVWF  x95
242C:  CALL   071E
2430:  DECFSZ x8D,F
2432:  BRA    2428
....................         
....................        un_digito(); 
2434:  CALL   0E44
....................        if(datom==1) 
2438:  DECFSZ x72,W
243A:  BRA    2444
....................        {   
....................           motorderecha(); 
243C:  CALL   17DC
....................           goto Miguel; 
2440:  BRA    1DB8
....................         } 
....................         else if(datom==2) 
2442:  BRA    248C
2444:  MOVF   x72,W
2446:  SUBLW  02
2448:  BNZ   2452
....................           {motorizquierda(); 
244A:  CALL   1864
....................            goto Miguel; 
244E:  BRA    1DB8
....................           }else {lcd_putc('\f');                        //Limpiar pantalla comando 
2450:  BRA    248C
2452:  MOVLW  0C
2454:  MOVWF  x94
2456:  CALL   0888
....................                  lcd_gotoxy(1,1);                       //escribir en a primera fila primera posicion  
245A:  MOVLW  01
245C:  MOVWF  x95
245E:  MOVWF  x96
2460:  CALL   082C
....................                  lcd_putc("ERROR DE NUMERO");            //lo que se escribe 
2464:  CLRF   x8D
2466:  MOVF   x8D,W
2468:  CALL   0272
246C:  IORLW  00
246E:  BZ    247A
2470:  INCF   x8D,F
2472:  MOVWF  x94
2474:  CALL   0888
2478:  BRA    2466
....................                   delay_ms(3000); 
247A:  MOVLW  0C
247C:  MOVWF  x8D
247E:  MOVLW  FA
2480:  MOVWF  x95
2482:  CALL   071E
2486:  DECFSZ x8D,F
2488:  BRA    247E
....................                   goto Miguel; 
248A:  BRA    1DB8
....................                   } 
....................         
....................         
....................        goto Miguel; 
248C:  BRA    1DB8
....................      } 
....................      else if(datom==0x05) 
248E:  BRA    266E
2490:  MOVF   x72,W
2492:  SUBLW  05
2494:  BNZ   24F4
....................      { 
....................        lcd_putc('\f');              //Limpiar pantalla comando 
2496:  MOVLW  0C
2498:  MOVWF  x94
249A:  CALL   0888
....................        lcd_gotoxy(1,1);             //escribir en a primera fila primera posicion  
249E:  MOVLW  01
24A0:  MOVWF  x95
24A2:  MOVWF  x96
24A4:  CALL   082C
....................        lcd_putc("MEN SERVOMOTOR");  //lo que se escribe 
24A8:  CLRF   x8D
24AA:  MOVF   x8D,W
24AC:  CALL   061C
24B0:  IORLW  00
24B2:  BZ    24BE
24B4:  INCF   x8D,F
24B6:  MOVWF  x94
24B8:  CALL   0888
24BC:  BRA    24AA
....................        lcd_gotoxy(3,2);             //escribir en a primera fila primera posicion  
24BE:  MOVLW  03
24C0:  MOVWF  x95
24C2:  MOVLW  02
24C4:  MOVWF  x96
24C6:  CALL   082C
....................        lcd_putc("EN CONSTRUCCION"); 
24CA:  CLRF   x8D
24CC:  MOVF   x8D,W
24CE:  CALL   063C
24D2:  IORLW  00
24D4:  BZ    24E0
24D6:  INCF   x8D,F
24D8:  MOVWF  x94
24DA:  CALL   0888
24DE:  BRA    24CC
....................        delay_ms(3000); 
24E0:  MOVLW  0C
24E2:  MOVWF  x8D
24E4:  MOVLW  FA
24E6:  MOVWF  x95
24E8:  CALL   071E
24EC:  DECFSZ x8D,F
24EE:  BRA    24E4
....................        goto Miguel; 
24F0:  BRA    1DB8
....................      } 
....................      else if(datom==0x06) 
24F2:  BRA    266E
24F4:  MOVF   x72,W
24F6:  SUBLW  06
24F8:  BNZ   2558
....................      { 
....................        lcd_putc('\f');               //Limpiar pantalla comando 
24FA:  MOVLW  0C
24FC:  MOVWF  x94
24FE:  CALL   0888
....................        lcd_gotoxy(1,1);              //escribir en a primera fila primera posicion  
2502:  MOVLW  01
2504:  MOVWF  x95
2506:  MOVWF  x96
2508:  CALL   082C
....................        lcd_putc("MENU CAD");         //lo que se escribe 
250C:  CLRF   x8D
250E:  MOVF   x8D,W
2510:  CALL   065C
2514:  IORLW  00
2516:  BZ    2522
2518:  INCF   x8D,F
251A:  MOVWF  x94
251C:  CALL   0888
2520:  BRA    250E
....................        lcd_gotoxy(3,2);              //escribir en a primera fila primera posicion  
2522:  MOVLW  03
2524:  MOVWF  x95
2526:  MOVLW  02
2528:  MOVWF  x96
252A:  CALL   082C
....................        lcd_putc("EN CONSTRUCCION"); 
252E:  CLRF   x8D
2530:  MOVF   x8D,W
2532:  CALL   063C
2536:  IORLW  00
2538:  BZ    2544
253A:  INCF   x8D,F
253C:  MOVWF  x94
253E:  CALL   0888
2542:  BRA    2530
....................        delay_ms(3000); 
2544:  MOVLW  0C
2546:  MOVWF  x8D
2548:  MOVLW  FA
254A:  MOVWF  x95
254C:  CALL   071E
2550:  DECFSZ x8D,F
2552:  BRA    2548
....................        goto Miguel; 
2554:  BRA    1DB8
....................      } 
....................      else if(datom==0x07) 
2556:  BRA    266E
2558:  MOVF   x72,W
255A:  SUBLW  07
255C:  BNZ   25BE
....................      { 
....................        lcd_putc('\f');               //Limpiar pantalla comando 
255E:  MOVLW  0C
2560:  MOVWF  x94
2562:  CALL   0888
....................        lcd_gotoxy(1,1);              //escribir en a primera fila primera posicion  
2566:  MOVLW  01
2568:  MOVWF  x95
256A:  MOVWF  x96
256C:  CALL   082C
....................        lcd_putc("MEN DTMF");         //lo que se escribe 
2570:  CLRF   x8D
2572:  MOVF   x8D,W
2574:  CALL   0676
2578:  IORLW  00
257A:  BZ    2586
257C:  INCF   x8D,F
257E:  MOVWF  x94
2580:  CALL   0888
2584:  BRA    2572
....................        lcd_gotoxy(3,2);              //escribir en a primera fila primera posicion  
2586:  MOVLW  03
2588:  MOVWF  x95
258A:  MOVLW  02
258C:  MOVWF  x96
258E:  CALL   082C
....................        lcd_putc("EN CONSTRUCCION"); 
2592:  CLRF   x8D
2594:  MOVF   x8D,W
2596:  CALL   063C
259A:  IORLW  00
259C:  BZ    25A8
259E:  INCF   x8D,F
25A0:  MOVWF  x94
25A2:  CALL   0888
25A6:  BRA    2594
....................        delay_ms(3000); 
25A8:  MOVLW  0C
25AA:  MOVWF  x8D
25AC:  MOVLW  FA
25AE:  MOVWF  x95
25B0:  CALL   071E
25B4:  DECFSZ x8D,F
25B6:  BRA    25AC
....................       goto Miguel; 
25B8:  GOTO   1DB8
....................      } 
....................      else if(datom==0x08) 
25BC:  BRA    266E
25BE:  MOVF   x72,W
25C0:  SUBLW  08
25C2:  BNZ   2624
....................      { 
....................        lcd_putc('\f');              //Limpiar pantalla comando 
25C4:  MOVLW  0C
25C6:  MOVWF  x94
25C8:  CALL   0888
....................        lcd_gotoxy(1,1);             //escribir en a primera fila primera posicion  
25CC:  MOVLW  01
25CE:  MOVWF  x95
25D0:  MOVWF  x96
25D2:  CALL   082C
....................        lcd_putc("MEN SENSORES");    //lo que se escribe 
25D6:  CLRF   x8D
25D8:  MOVF   x8D,W
25DA:  CALL   0690
25DE:  IORLW  00
25E0:  BZ    25EC
25E2:  INCF   x8D,F
25E4:  MOVWF  x94
25E6:  CALL   0888
25EA:  BRA    25D8
....................        lcd_gotoxy(3,2);             //escribir en a primera fila primera posicion  
25EC:  MOVLW  03
25EE:  MOVWF  x95
25F0:  MOVLW  02
25F2:  MOVWF  x96
25F4:  CALL   082C
....................        lcd_putc("EN CONSTRUCCION"); 
25F8:  CLRF   x8D
25FA:  MOVF   x8D,W
25FC:  CALL   063C
2600:  IORLW  00
2602:  BZ    260E
2604:  INCF   x8D,F
2606:  MOVWF  x94
2608:  CALL   0888
260C:  BRA    25FA
....................        delay_ms(3000); 
260E:  MOVLW  0C
2610:  MOVWF  x8D
2612:  MOVLW  FA
2614:  MOVWF  x95
2616:  CALL   071E
261A:  DECFSZ x8D,F
261C:  BRA    2612
....................        goto Miguel; 
261E:  GOTO   1DB8
....................      } 
....................      else if(datom==0x09) 
2622:  BRA    266E
2624:  MOVF   x72,W
2626:  SUBLW  09
2628:  BNZ   2630
....................      { 
....................       goto admin; 
262A:  GOTO   1BD2
....................      } 
....................      else{ 
262E:  BRA    266E
....................           lcd_putc('\f');                 //Limpiar pantalla comando 
2630:  MOVLW  0C
2632:  MOVWF  x94
2634:  CALL   0888
....................           lcd_gotoxy(1,2);                //escribir en a primera fila primera posicion  
2638:  MOVLW  01
263A:  MOVWF  x95
263C:  MOVLW  02
263E:  MOVWF  x96
2640:  CALL   082C
....................           lcd_putc("ERROR DE NUMERO");   //lo que se escribe 
2644:  CLRF   x8D
2646:  MOVF   x8D,W
2648:  CALL   0272
264C:  IORLW  00
264E:  BZ    265A
2650:  INCF   x8D,F
2652:  MOVWF  x94
2654:  CALL   0888
2658:  BRA    2646
....................           delay_ms(3000); 
265A:  MOVLW  0C
265C:  MOVWF  x8D
265E:  MOVLW  FA
2660:  MOVWF  x95
2662:  CALL   071E
2666:  DECFSZ x8D,F
2668:  BRA    265E
....................           goto menu; 
266A:  GOTO   1A3C
....................            
....................         } 
....................      } 
....................    
....................     else if(clave[0]==datoe[2] & clave[1]==datoe[3]) 
266E:  GOTO   2F86
2672:  MOVF   x6C,W
2674:  SUBWF  x62,W
2676:  BZ    267C
2678:  MOVLW  00
267A:  BRA    267E
267C:  MOVLW  01
267E:  MOVWF  x8D
2680:  MOVF   x6D,W
2682:  SUBWF  x63,W
2684:  BZ    268A
2686:  MOVLW  00
2688:  BRA    268C
268A:  MOVLW  01
268C:  ANDWF  x8D,W
268E:  BTFSC  FD8.2
2690:  GOTO   2F48
....................     { 
.................... David:adres=0x02; 
2694:  MOVLW  02
2696:  MOVWF  x6E
....................        /*escribirle al lcd 
....................        bienvenidos al menu del diseador 
....................        marque 1 para cambiar clave 
....................        marque 2 para fecha y hora 
....................        marque 3 para reportes 
....................        marque 4 para motor paso a paso 
....................        marque 5 para servomotor 
....................        marque 6 para cad 
....................        marque 7 para DTMF 
....................        marque 8 para sensores 
....................        marque 9 para salir*/ 
....................       
....................     lcd_putc('\f');                       //Limpiar pantalla comando 
2698:  MOVLW  0C
269A:  MOVWF  x94
269C:  CALL   0888
....................     lcd_gotoxy(1,1);                      //escribir en a primera fila primera posicion  
26A0:  MOVLW  01
26A2:  MOVWF  x95
26A4:  MOVWF  x96
26A6:  CALL   082C
....................     lcd_putc("MENU USUAR.");              //lo que se escribe 
26AA:  CLRF   x8D
26AC:  MOVF   x8D,W
26AE:  CALL   0292
26B2:  IORLW  00
26B4:  BZ    26C0
26B6:  INCF   x8D,F
26B8:  MOVWF  x94
26BA:  CALL   0888
26BE:  BRA    26AC
....................     lcd_gotoxy(4,2);                      //escribir en a primera fila primera posicion  
26C0:  MOVLW  04
26C2:  MOVWF  x95
26C4:  MOVLW  02
26C6:  MOVWF  x96
26C8:  CALL   082C
....................     lcd_putc("DAVID"); 
26CC:  CLRF   x8D
26CE:  MOVF   x8D,W
26D0:  CALL   06AE
26D4:  IORLW  00
26D6:  BZ    26E2
26D8:  INCF   x8D,F
26DA:  MOVWF  x94
26DC:  CALL   0888
26E0:  BRA    26CE
....................     delay_ms(3000);  
26E2:  MOVLW  0C
26E4:  MOVWF  x8D
26E6:  MOVLW  FA
26E8:  MOVWF  x95
26EA:  CALL   071E
26EE:  DECFSZ x8D,F
26F0:  BRA    26E6
....................         
....................     lcd_putc('\f');                       //Limpiar pantalla comando 
26F2:  MOVLW  0C
26F4:  MOVWF  x94
26F6:  CALL   0888
....................     lcd_gotoxy(1,1);                      //escribir en a primera fila primera posicion  
26FA:  MOVLW  01
26FC:  MOVWF  x95
26FE:  MOVWF  x96
2700:  CALL   082C
....................     lcd_putc("MARQUE NUM PARA");          //lo que se escribe 
2704:  CLRF   x8D
2706:  MOVF   x8D,W
2708:  CALL   02C6
270C:  IORLW  00
270E:  BZ    271A
2710:  INCF   x8D,F
2712:  MOVWF  x94
2714:  CALL   0888
2718:  BRA    2706
....................     lcd_gotoxy(1,2);                      //escribir en a primera fila primera posicion  
271A:  MOVLW  01
271C:  MOVWF  x95
271E:  MOVLW  02
2720:  MOVWF  x96
2722:  CALL   082C
....................     lcd_putc("1 CAMBIAR CLAVE"); 
2726:  CLRF   x8D
2728:  MOVF   x8D,W
272A:  CALL   02E6
272E:  IORLW  00
2730:  BZ    273C
2732:  INCF   x8D,F
2734:  MOVWF  x94
2736:  CALL   0888
273A:  BRA    2728
....................     delay_ms(3000);   
273C:  MOVLW  0C
273E:  MOVWF  x8D
2740:  MOVLW  FA
2742:  MOVWF  x95
2744:  CALL   071E
2748:  DECFSZ x8D,F
274A:  BRA    2740
....................      
....................     lcd_putc('\f');                      //Limpiar pantalla comando 
274C:  MOVLW  0C
274E:  MOVWF  x94
2750:  CALL   0888
....................     lcd_gotoxy(1,1);                     //escribir en a primera fila primera posicion  
2754:  MOVLW  01
2756:  MOVWF  x95
2758:  MOVWF  x96
275A:  CALL   082C
....................     lcd_putc("2 FECHA Y HORA");          //lo que se escribe 
275E:  CLRF   x8D
2760:  MOVF   x8D,W
2762:  CALL   0306
2766:  IORLW  00
2768:  BZ    2774
276A:  INCF   x8D,F
276C:  MOVWF  x94
276E:  CALL   0888
2772:  BRA    2760
....................     lcd_gotoxy(1,2);                     //escribir en a primera fila primera posicion  
2774:  MOVLW  01
2776:  MOVWF  x95
2778:  MOVLW  02
277A:  MOVWF  x96
277C:  CALL   082C
....................     lcd_putc("3 REPORTES"); 
2780:  CLRF   x8D
2782:  MOVF   x8D,W
2784:  CALL   0326
2788:  IORLW  00
278A:  BZ    2796
278C:  INCF   x8D,F
278E:  MOVWF  x94
2790:  CALL   0888
2794:  BRA    2782
....................     delay_ms(3000); 
2796:  MOVLW  0C
2798:  MOVWF  x8D
279A:  MOVLW  FA
279C:  MOVWF  x95
279E:  CALL   071E
27A2:  DECFSZ x8D,F
27A4:  BRA    279A
....................      
....................     lcd_putc('\f');                     //Limpiar pantalla comando 
27A6:  MOVLW  0C
27A8:  MOVWF  x94
27AA:  CALL   0888
....................     lcd_gotoxy(1,1);                    //escribir en a primera fila primera posicion  
27AE:  MOVLW  01
27B0:  MOVWF  x95
27B2:  MOVWF  x96
27B4:  CALL   082C
....................     lcd_putc("4 MOTOR PAS A PA");       //lo que se escribe 
27B8:  CLRF   x8D
27BA:  MOVF   x8D,W
27BC:  CALL   06C4
27C0:  IORLW  00
27C2:  BZ    27CE
27C4:  INCF   x8D,F
27C6:  MOVWF  x94
27C8:  CALL   0888
27CC:  BRA    27BA
....................     lcd_gotoxy(1,2);                     //escribir en a primera fila primera posicion  
27CE:  MOVLW  01
27D0:  MOVWF  x95
27D2:  MOVLW  02
27D4:  MOVWF  x96
27D6:  CALL   082C
....................     lcd_putc("5 SERVOMOTOR"); 
27DA:  CLRF   x8D
27DC:  MOVF   x8D,W
27DE:  CALL   0362
27E2:  IORLW  00
27E4:  BZ    27F0
27E6:  INCF   x8D,F
27E8:  MOVWF  x94
27EA:  CALL   0888
27EE:  BRA    27DC
....................     delay_ms(3000); 
27F0:  MOVLW  0C
27F2:  MOVWF  x8D
27F4:  MOVLW  FA
27F6:  MOVWF  x95
27F8:  CALL   071E
27FC:  DECFSZ x8D,F
27FE:  BRA    27F4
....................      
....................     lcd_putc('\f');                      //Limpiar pantalla comando 
2800:  MOVLW  0C
2802:  MOVWF  x94
2804:  CALL   0888
....................     lcd_gotoxy(1,1);                     //escribir en a primera fila primera posicion  
2808:  MOVLW  01
280A:  MOVWF  x95
280C:  MOVWF  x96
280E:  CALL   082C
....................     lcd_putc("6 CAD");                   //lo que se escribe 
2812:  CLRF   x8D
2814:  MOVF   x8D,W
2816:  CALL   0380
281A:  IORLW  00
281C:  BZ    2828
281E:  INCF   x8D,F
2820:  MOVWF  x94
2822:  CALL   0888
2826:  BRA    2814
....................     lcd_gotoxy(1,2);                     //escribir en a primera fila primera posicion  
2828:  MOVLW  01
282A:  MOVWF  x95
282C:  MOVLW  02
282E:  MOVWF  x96
2830:  CALL   082C
....................     lcd_putc("7 DTMF"); 
2834:  CLRF   x8D
2836:  MOVF   x8D,W
2838:  CALL   0396
283C:  IORLW  00
283E:  BZ    284A
2840:  INCF   x8D,F
2842:  MOVWF  x94
2844:  CALL   0888
2848:  BRA    2836
....................     delay_ms(3000); 
284A:  MOVLW  0C
284C:  MOVWF  x8D
284E:  MOVLW  FA
2850:  MOVWF  x95
2852:  CALL   071E
2856:  DECFSZ x8D,F
2858:  BRA    284E
....................      
....................     lcd_putc('\f');                      //Limpiar pantalla comando 
285A:  MOVLW  0C
285C:  MOVWF  x94
285E:  CALL   0888
....................     lcd_gotoxy(1,1);                     //escribir en a primera fila primera posicion  
2862:  MOVLW  01
2864:  MOVWF  x95
2866:  MOVWF  x96
2868:  CALL   082C
....................     lcd_putc("8 SENSORES");              //lo que se escribe 
286C:  CLRF   x8D
286E:  MOVF   x8D,W
2870:  CALL   03AE
2874:  IORLW  00
2876:  BZ    2882
2878:  INCF   x8D,F
287A:  MOVWF  x94
287C:  CALL   0888
2880:  BRA    286E
....................     lcd_gotoxy(3,2);                     //escribir en a primera fila primera posicion  
2882:  MOVLW  03
2884:  MOVWF  x95
2886:  MOVLW  02
2888:  MOVWF  x96
288A:  CALL   082C
....................     lcd_putc("9 SALIR"); 
288E:  CLRF   x8D
2890:  MOVF   x8D,W
2892:  CALL   03CA
2896:  IORLW  00
2898:  BZ    28A4
289A:  INCF   x8D,F
289C:  MOVWF  x94
289E:  CALL   0888
28A2:  BRA    2890
....................     delay_ms(3000); 
28A4:  MOVLW  0C
28A6:  MOVWF  x8D
28A8:  MOVLW  FA
28AA:  MOVWF  x95
28AC:  CALL   071E
28B0:  DECFSZ x8D,F
28B2:  BRA    28A8
....................      
....................     un_digito(); 
28B4:  CALL   0E44
....................     if(datom==0x01) 
28B8:  DECFSZ x72,W
28BA:  BRA    2A3C
....................      { 
....................        lcd_putc('\f');                   //Limpiar pantalla comando 
28BC:  MOVLW  0C
28BE:  MOVWF  x94
28C0:  CALL   0888
....................        lcd_gotoxy(1,1);                  //escribir en a primera fila primera posicion  
28C4:  MOVLW  01
28C6:  MOVWF  x95
28C8:  MOVWF  x96
28CA:  CALL   082C
....................        lcd_putc("MEN CAMBIAR CLAV");     //lo que se escribe 
28CE:  CLRF   x8D
28D0:  MOVF   x8D,W
28D2:  CALL   03E2
28D6:  IORLW  00
28D8:  BZ    28E4
28DA:  INCF   x8D,F
28DC:  MOVWF  x94
28DE:  CALL   0888
28E2:  BRA    28D0
....................        lcd_gotoxy(3,2);                  //escribir en a primera fila primera posicion  
28E4:  MOVLW  03
28E6:  MOVWF  x95
28E8:  MOVLW  02
28EA:  MOVWF  x96
28EC:  CALL   082C
....................        lcd_putc("DIGITE NU. CLAVE");     //clave[0]= y clave[1]= 
28F0:  CLRF   x8D
28F2:  MOVF   x8D,W
28F4:  CALL   0404
28F8:  IORLW  00
28FA:  BZ    2906
28FC:  INCF   x8D,F
28FE:  MOVWF  x94
2900:  CALL   0888
2904:  BRA    28F2
....................        delay_ms(3000); 
2906:  MOVLW  0C
2908:  MOVWF  x8D
290A:  MOVLW  FA
290C:  MOVWF  x95
290E:  CALL   071E
2912:  DECFSZ x8D,F
2914:  BRA    290A
....................        teclado(); 
2916:  CALL   0CA6
....................         
....................        dato1=clave[0]; 
291A:  MOVFF  62,6F
....................        dato2=clave[1]; 
291E:  MOVFF  63,70
....................         
....................        lcd_putc('\f');                   //Limpiar pantalla comando 
2922:  MOVLW  0C
2924:  MOVWF  x94
2926:  CALL   0888
....................        lcd_gotoxy(1,1);                  //escribir en a primera fila primera posicion  
292A:  MOVLW  01
292C:  MOVWF  x95
292E:  MOVWF  x96
2930:  CALL   082C
....................        lcd_putc("POR FAVOR DIGITE");     //lo que se escribe 
2934:  CLRF   x8D
2936:  MOVF   x8D,W
2938:  CALL   0426
293C:  IORLW  00
293E:  BZ    294A
2940:  INCF   x8D,F
2942:  MOVWF  x94
2944:  CALL   0888
2948:  BRA    2936
....................        lcd_gotoxy(1,2);                  //escribir en a primera fila primera posicion  
294A:  MOVLW  01
294C:  MOVWF  x95
294E:  MOVLW  02
2950:  MOVWF  x96
2952:  CALL   082C
....................        lcd_putc("DIGITE NUE.CLAVE");    
2956:  CLRF   x8D
2958:  MOVF   x8D,W
295A:  CALL   0448
295E:  IORLW  00
2960:  BZ    296C
2962:  INCF   x8D,F
2964:  MOVWF  x94
2966:  CALL   0888
296A:  BRA    2958
....................        delay_ms(3000); 
296C:  MOVLW  0C
296E:  MOVWF  x8D
2970:  MOVLW  FA
2972:  MOVWF  x95
2974:  CALL   071E
2978:  DECFSZ x8D,F
297A:  BRA    2970
....................         
....................        teclado(); 
297C:  CALL   0CA6
....................         
....................        if(clave[0]==dato1 & clave[1]==dato2) 
2980:  MOVF   x6F,W
2982:  SUBWF  x62,W
2984:  BZ    298A
2986:  MOVLW  00
2988:  BRA    298C
298A:  MOVLW  01
298C:  MOVWF  x8D
298E:  MOVF   x70,W
2990:  SUBWF  x63,W
2992:  BZ    2998
2994:  MOVLW  00
2996:  BRA    299A
2998:  MOVLW  01
299A:  ANDWF  x8D,W
299C:  BZ    2A00
....................        { 
....................         escribir_memoria_ext(); 
299E:  CALL   0F98
....................         lcd_putc('\f');                   //Limpiar pantalla comando 
29A2:  MOVLW  0C
29A4:  MOVWF  x94
29A6:  CALL   0888
....................         lcd_gotoxy(1,1);                  //escribir en a primera fila primera posicion  
29AA:  MOVLW  01
29AC:  MOVWF  x95
29AE:  MOVWF  x96
29B0:  CALL   082C
....................         lcd_putc("CLAVE MODIFICADA");     //lo que se escribe 
29B4:  CLRF   x8D
29B6:  MOVF   x8D,W
29B8:  CALL   046A
29BC:  IORLW  00
29BE:  BZ    29CA
29C0:  INCF   x8D,F
29C2:  MOVWF  x94
29C4:  CALL   0888
29C8:  BRA    29B6
....................         lcd_gotoxy(3,2);                  //escribir en a primera fila primera posicion  
29CA:  MOVLW  03
29CC:  MOVWF  x95
29CE:  MOVLW  02
29D0:  MOVWF  x96
29D2:  CALL   082C
....................         lcd_putc("CON EXITO");    
29D6:  CLRF   x8D
29D8:  MOVF   x8D,W
29DA:  CALL   048C
29DE:  IORLW  00
29E0:  BZ    29EC
29E2:  INCF   x8D,F
29E4:  MOVWF  x94
29E6:  CALL   0888
29EA:  BRA    29D8
....................         delay_ms(3000); 
29EC:  MOVLW  0C
29EE:  MOVWF  x8D
29F0:  MOVLW  FA
29F2:  MOVWF  x95
29F4:  CALL   071E
29F8:  DECFSZ x8D,F
29FA:  BRA    29F0
....................         goto David; 
29FC:  BRA    2694
....................        } 
....................        else{ 
29FE:  BRA    2A3A
....................        lcd_putc('\f');                   //Limpiar pantalla comando 
2A00:  MOVLW  0C
2A02:  MOVWF  x94
2A04:  CALL   0888
....................        lcd_gotoxy(1,1);                  //escribir en a primera fila primera posicion  
2A08:  MOVLW  01
2A0A:  MOVWF  x95
2A0C:  MOVWF  x96
2A0E:  CALL   082C
....................        lcd_putc("ERROR DE CLAVE");       //lo que se escribe 
2A12:  CLRF   x8D
2A14:  MOVF   x8D,W
2A16:  CALL   04A6
2A1A:  IORLW  00
2A1C:  BZ    2A28
2A1E:  INCF   x8D,F
2A20:  MOVWF  x94
2A22:  CALL   0888
2A26:  BRA    2A14
....................        delay_ms(3000); 
2A28:  MOVLW  0C
2A2A:  MOVWF  x8D
2A2C:  MOVLW  FA
2A2E:  MOVWF  x95
2A30:  CALL   071E
2A34:  DECFSZ x8D,F
2A36:  BRA    2A2C
....................        goto David; 
2A38:  BRA    2694
....................        } 
....................         
....................      } 
....................      else if(datom==0x02) 
2A3A:  BRA    2F46
2A3C:  MOVF   x72,W
2A3E:  SUBLW  02
2A40:  BNZ   2A92
....................      { 
....................       lcd_putc('\f');                   //Limpiar pantalla comando 
2A42:  MOVLW  0C
2A44:  MOVWF  x94
2A46:  CALL   0888
....................        lcd_gotoxy(1,1);                 //escribir en a primera fila primera posicion  
2A4A:  MOVLW  01
2A4C:  MOVWF  x95
2A4E:  MOVWF  x96
2A50:  CALL   082C
....................        lcd_putc("MEN FECHA Y HORA");    //lo que se escribe 
2A54:  CLRF   x8D
2A56:  MOVF   x8D,W
2A58:  CALL   04C6
2A5C:  IORLW  00
2A5E:  BZ    2A6A
2A60:  INCF   x8D,F
2A62:  MOVWF  x94
2A64:  CALL   0888
2A68:  BRA    2A56
....................        delay_ms(3000); 
2A6A:  MOVLW  0C
2A6C:  MOVWF  x8D
2A6E:  MOVLW  FA
2A70:  MOVWF  x95
2A72:  CALL   071E
2A76:  DECFSZ x8D,F
2A78:  BRA    2A6E
....................        hora_fecha(); 
2A7A:  CALL   11BE
....................        delay_ms(3000); 
2A7E:  MOVLW  0C
2A80:  MOVWF  x8D
2A82:  MOVLW  FA
2A84:  MOVWF  x95
2A86:  CALL   071E
2A8A:  DECFSZ x8D,F
2A8C:  BRA    2A82
....................        goto David; 
2A8E:  BRA    2694
....................      } 
....................      else  if(datom==0x03) 
2A90:  BRA    2F46
2A92:  MOVF   x72,W
2A94:  SUBLW  03
2A96:  BTFSS  FD8.2
2A98:  BRA    2C78
....................      { 
....................        ide=0x10; 
2A9A:  MOVLW  10
2A9C:  MOVWF  x7B
....................        lcd_putc('\f');                   //Limpiar pantalla comando 
2A9E:  MOVLW  0C
2AA0:  MOVWF  x94
2AA2:  CALL   0888
....................        lcd_gotoxy(1,1);                  //escribir en a primera fila primera posicion  
2AA6:  MOVLW  01
2AA8:  MOVWF  x95
2AAA:  MOVWF  x96
2AAC:  CALL   082C
....................        lcd_putc("REPORTE");              //lo que se escribe 
2AB0:  CLRF   x8D
2AB2:  MOVF   x8D,W
2AB4:  CALL   06E6
2AB8:  IORLW  00
2ABA:  BZ    2AC6
2ABC:  INCF   x8D,F
2ABE:  MOVWF  x94
2AC0:  CALL   0888
2AC4:  BRA    2AB2
....................        delay_ms(3000); 
2AC6:  MOVLW  0C
2AC8:  MOVWF  x8D
2ACA:  MOVLW  FA
2ACC:  MOVWF  x95
2ACE:  CALL   071E
2AD2:  DECFSZ x8D,F
2AD4:  BRA    2ACA
....................         
....................        lcd_putc('\f');                   //Limpiar pantalla comando 
2AD6:  MOVLW  0C
2AD8:  MOVWF  x94
2ADA:  CALL   0888
....................        lcd_gotoxy(1,1);                  //escribir en a primera fila primera posicion  
2ADE:  MOVLW  01
2AE0:  MOVWF  x95
2AE2:  MOVWF  x96
2AE4:  CALL   082C
....................        lcd_putc("1 GENERAR.REPORT");     //lo que se escribe 
2AE8:  CLRF   x8D
2AEA:  MOVF   x8D,W
2AEC:  CALL   0506
2AF0:  IORLW  00
2AF2:  BZ    2AFE
2AF4:  INCF   x8D,F
2AF6:  MOVWF  x94
2AF8:  CALL   0888
2AFC:  BRA    2AEA
....................        lcd_gotoxy(1,2);                  //escribir en a primera fila primera posicion  
2AFE:  MOVLW  01
2B00:  MOVWF  x95
2B02:  MOVLW  02
2B04:  MOVWF  x96
2B06:  CALL   082C
....................        lcd_putc("2 MOSTRAR.REPORT");     //lo que se escribe 
2B0A:  CLRF   x8D
2B0C:  MOVF   x8D,W
2B0E:  CALL   0528
2B12:  IORLW  00
2B14:  BZ    2B20
2B16:  INCF   x8D,F
2B18:  MOVWF  x94
2B1A:  CALL   0888
2B1E:  BRA    2B0C
....................        delay_ms(3000); 
2B20:  MOVLW  0C
2B22:  MOVWF  x8D
2B24:  MOVLW  FA
2B26:  MOVWF  x95
2B28:  CALL   071E
2B2C:  DECFSZ x8D,F
2B2E:  BRA    2B24
....................        un_digito(); 
2B30:  CALL   0E44
....................      if(datom==0x01){ 
2B34:  DECFSZ x72,W
2B36:  BRA    2C14
....................        buscar_pos();                     //CONTADOR, ADDRESS, ESPACIO_VACIO=TRU 
2B38:  CALL   1478
....................        if(espacio_vacio==true){ 
2B3C:  BTFSS  0E.2
2B3E:  BRA    2BD8
....................            
....................           hacer_reporte(); 
2B40:  CALL   14E6
....................           for(i=0;i<8;i++){ 
2B44:  CLRF   x60
2B46:  MOVF   x60,W
2B48:  SUBLW  07
2B4A:  BNC   2B7A
....................                write_ext_eeprom(adres, time[i]); 
2B4C:  CLRF   03
2B4E:  MOVF   x60,W
2B50:  ADDLW  83
2B52:  MOVWF  FE9
2B54:  MOVLW  00
2B56:  ADDWFC 03,W
2B58:  MOVWF  FEA
2B5A:  MOVFF  FEF,8D
2B5E:  CLRF   x8F
2B60:  MOVFF  6E,8E
2B64:  MOVFF  8D,90
2B68:  CALL   0EA6
....................                adres++; 
2B6C:  INCF   x6E,F
....................                delay_ms(5); 
2B6E:  MOVLW  05
2B70:  MOVWF  x95
2B72:  CALL   071E
....................           } 
2B76:  INCF   x60,F
2B78:  BRA    2B46
....................            lcd_putc('\f');                    //Limpiar pantalla comando 
2B7A:  MOVLW  0C
2B7C:  MOVWF  x94
2B7E:  CALL   0888
....................                lcd_gotoxy(1,1);               //escribir en a primera fila primera posicion  
2B82:  MOVLW  01
2B84:  MOVWF  x95
2B86:  MOVWF  x96
2B88:  CALL   082C
....................                lcd_putc("REPORTE GUARDADO");  //lo que se escribe 
2B8C:  CLRF   x8D
2B8E:  MOVF   x8D,W
2B90:  CALL   054A
2B94:  IORLW  00
2B96:  BZ    2BA2
2B98:  INCF   x8D,F
2B9A:  MOVWF  x94
2B9C:  CALL   0888
2BA0:  BRA    2B8E
....................                lcd_gotoxy(1,2);               //escribir en a primera fila primera posicion  
2BA2:  MOVLW  01
2BA4:  MOVWF  x95
2BA6:  MOVLW  02
2BA8:  MOVWF  x96
2BAA:  CALL   082C
....................                lcd_putc("CON EXITO");         //lo que se escribe 
2BAE:  CLRF   x8D
2BB0:  MOVF   x8D,W
2BB2:  CALL   048C
2BB6:  IORLW  00
2BB8:  BZ    2BC4
2BBA:  INCF   x8D,F
2BBC:  MOVWF  x94
2BBE:  CALL   0888
2BC2:  BRA    2BB0
....................                delay_ms(3000); 
2BC4:  MOVLW  0C
2BC6:  MOVWF  x8D
2BC8:  MOVLW  FA
2BCA:  MOVWF  x95
2BCC:  CALL   071E
2BD0:  DECFSZ x8D,F
2BD2:  BRA    2BC8
....................                goto David; 
2BD4:  BRA    2694
....................         }else{ 
2BD6:  BRA    2C12
....................                lcd_putc('\f');               //Limpiar pantalla comando 
2BD8:  MOVLW  0C
2BDA:  MOVWF  x94
2BDC:  CALL   0888
....................                lcd_gotoxy(1,1);              //escribir en a primera fila primera posicion  
2BE0:  MOVLW  01
2BE2:  MOVWF  x95
2BE4:  MOVWF  x96
2BE6:  CALL   082C
....................                lcd_putc("MEMORIA LLENA");    //lo que se escribe 
2BEA:  CLRF   x8D
2BEC:  MOVF   x8D,W
2BEE:  CALL   056C
2BF2:  IORLW  00
2BF4:  BZ    2C00
2BF6:  INCF   x8D,F
2BF8:  MOVWF  x94
2BFA:  CALL   0888
2BFE:  BRA    2BEC
....................                delay_ms(3000); 
2C00:  MOVLW  0C
2C02:  MOVWF  x8D
2C04:  MOVLW  FA
2C06:  MOVWF  x95
2C08:  CALL   071E
2C0C:  DECFSZ x8D,F
2C0E:  BRA    2C04
....................                goto David; 
2C10:  BRA    2694
....................                 
....................               } 
....................      }else if (datom==0x02) { 
2C12:  BRA    2C76
2C14:  MOVF   x72,W
2C16:  SUBLW  02
2C18:  BNZ   2C22
....................                   mostrar_reporte(); 
2C1A:  CALL   16A2
....................                   goto David; 
2C1E:  BRA    2694
....................                 } 
....................                    else{ lcd_gotoxy(1,1);               //escribir en a primera fila primera posicion  
2C20:  BRA    2C76
2C22:  MOVLW  01
2C24:  MOVWF  x95
2C26:  MOVWF  x96
2C28:  CALL   082C
....................                        lcd_putc("NUMERO");              //lo que se escribe 
2C2C:  CLRF   x8D
2C2E:  MOVF   x8D,W
2C30:  CALL   058A
2C34:  IORLW  00
2C36:  BZ    2C42
2C38:  INCF   x8D,F
2C3A:  MOVWF  x94
2C3C:  CALL   0888
2C40:  BRA    2C2E
....................                        lcd_gotoxy(1,2);                //escribir en a primera fila primera posicion  
2C42:  MOVLW  01
2C44:  MOVWF  x95
2C46:  MOVLW  02
2C48:  MOVWF  x96
2C4A:  CALL   082C
....................                        lcd_putc("ERROR");              //lo que se escribe 
2C4E:  CLRF   x8D
2C50:  MOVF   x8D,W
2C52:  CALL   05A2
2C56:  IORLW  00
2C58:  BZ    2C64
2C5A:  INCF   x8D,F
2C5C:  MOVWF  x94
2C5E:  CALL   0888
2C62:  BRA    2C50
....................                        delay_ms(3000); 
2C64:  MOVLW  0C
2C66:  MOVWF  x8D
2C68:  MOVLW  FA
2C6A:  MOVWF  x95
2C6C:  CALL   071E
2C70:  DECFSZ x8D,F
2C72:  BRA    2C68
....................                        goto David;} 
2C74:  BRA    2694
....................                 
....................      } 
....................      else if(datom==0x04) 
2C76:  BRA    2F46
2C78:  MOVF   x72,W
2C7A:  SUBLW  04
2C7C:  BTFSS  FD8.2
2C7E:  BRA    2D6A
....................      { 
....................        lcd_putc('\f');                        //Limpiar pantalla comando 
2C80:  MOVLW  0C
2C82:  MOVWF  x94
2C84:  CALL   0888
....................        lcd_gotoxy(1,1);                       //escribir en a primera fila primera posicion  
2C88:  MOVLW  01
2C8A:  MOVWF  x95
2C8C:  MOVWF  x96
2C8E:  CALL   082C
....................        lcd_putc("MEN MOTOR PAS A.");          //lo que se escribe 
2C92:  CLRF   x8D
2C94:  MOVF   x8D,W
2C96:  CALL   05B8
2C9A:  IORLW  00
2C9C:  BZ    2CA8
2C9E:  INCF   x8D,F
2CA0:  MOVWF  x94
2CA2:  CALL   0888
2CA6:  BRA    2C94
....................        delay_ms(3000); 
2CA8:  MOVLW  0C
2CAA:  MOVWF  x8D
2CAC:  MOVLW  FA
2CAE:  MOVWF  x95
2CB0:  CALL   071E
2CB4:  DECFSZ x8D,F
2CB6:  BRA    2CAC
....................         
....................        lcd_putc('\f');                        //Limpiar pantalla comando 
2CB8:  MOVLW  0C
2CBA:  MOVWF  x94
2CBC:  CALL   0888
....................        lcd_gotoxy(1,1);                       //escribir en a primera fila primera posicion  
2CC0:  MOVLW  01
2CC2:  MOVWF  x95
2CC4:  MOVWF  x96
2CC6:  CALL   082C
....................        lcd_putc("1 PARA DERECHA");            //lo que se escribe 
2CCA:  CLRF   x8D
2CCC:  MOVF   x8D,W
2CCE:  CALL   05DA
2CD2:  IORLW  00
2CD4:  BZ    2CE0
2CD6:  INCF   x8D,F
2CD8:  MOVWF  x94
2CDA:  CALL   0888
2CDE:  BRA    2CCC
....................        lcd_gotoxy(1,2);                       //escribir en a primera fila primera posicion  
2CE0:  MOVLW  01
2CE2:  MOVWF  x95
2CE4:  MOVLW  02
2CE6:  MOVWF  x96
2CE8:  CALL   082C
....................        lcd_putc("2 PARA IZQUIERDA");          //lo que se escribe 
2CEC:  CLRF   x8D
2CEE:  MOVF   x8D,W
2CF0:  CALL   05FA
2CF4:  IORLW  00
2CF6:  BZ    2D02
2CF8:  INCF   x8D,F
2CFA:  MOVWF  x94
2CFC:  CALL   0888
2D00:  BRA    2CEE
....................        delay_ms(3000); 
2D02:  MOVLW  0C
2D04:  MOVWF  x8D
2D06:  MOVLW  FA
2D08:  MOVWF  x95
2D0A:  CALL   071E
2D0E:  DECFSZ x8D,F
2D10:  BRA    2D06
....................         
....................        un_digito(); 
2D12:  CALL   0E44
....................        if(datom==1) 
2D16:  DECFSZ x72,W
2D18:  BRA    2D20
....................         
....................        { motorderecha(); 
2D1A:  CALL   17DC
....................        }else if(datom==2) 
2D1E:  BRA    2D66
2D20:  MOVF   x72,W
2D22:  SUBLW  02
2D24:  BNZ   2D2C
....................           {motorizquierda(); 
2D26:  CALL   1864
....................           }else {lcd_putc('\f');                        //Limpiar pantalla comando 
2D2A:  BRA    2D66
2D2C:  MOVLW  0C
2D2E:  MOVWF  x94
2D30:  CALL   0888
....................                  lcd_gotoxy(1,1);                       //escribir en a primera fila primera posicion  
2D34:  MOVLW  01
2D36:  MOVWF  x95
2D38:  MOVWF  x96
2D3A:  CALL   082C
....................                  lcd_putc("ERROR DE NUMERO");            //lo que se escribe 
2D3E:  CLRF   x8D
2D40:  MOVF   x8D,W
2D42:  CALL   0272
2D46:  IORLW  00
2D48:  BZ    2D54
2D4A:  INCF   x8D,F
2D4C:  MOVWF  x94
2D4E:  CALL   0888
2D52:  BRA    2D40
....................                   delay_ms(3000); 
2D54:  MOVLW  0C
2D56:  MOVWF  x8D
2D58:  MOVLW  FA
2D5A:  MOVWF  x95
2D5C:  CALL   071E
2D60:  DECFSZ x8D,F
2D62:  BRA    2D58
....................                   goto David; 
2D64:  BRA    2694
....................                   } 
....................         
....................         
....................        goto David; 
2D66:  BRA    2694
....................      } 
....................      else if(datom==0x05) 
2D68:  BRA    2F46
2D6A:  MOVF   x72,W
2D6C:  SUBLW  05
2D6E:  BNZ   2DCE
....................      { 
....................        lcd_putc('\f');              //Limpiar pantalla comando 
2D70:  MOVLW  0C
2D72:  MOVWF  x94
2D74:  CALL   0888
....................        lcd_gotoxy(1,1);             //escribir en a primera fila primera posicion  
2D78:  MOVLW  01
2D7A:  MOVWF  x95
2D7C:  MOVWF  x96
2D7E:  CALL   082C
....................        lcd_putc("MEN SERVOMOTOR");  //lo que se escribe 
2D82:  CLRF   x8D
2D84:  MOVF   x8D,W
2D86:  CALL   061C
2D8A:  IORLW  00
2D8C:  BZ    2D98
2D8E:  INCF   x8D,F
2D90:  MOVWF  x94
2D92:  CALL   0888
2D96:  BRA    2D84
....................        lcd_gotoxy(3,2);             //escribir en a primera fila primera posicion  
2D98:  MOVLW  03
2D9A:  MOVWF  x95
2D9C:  MOVLW  02
2D9E:  MOVWF  x96
2DA0:  CALL   082C
....................        lcd_putc("EN CONSTRUCCION"); 
2DA4:  CLRF   x8D
2DA6:  MOVF   x8D,W
2DA8:  CALL   063C
2DAC:  IORLW  00
2DAE:  BZ    2DBA
2DB0:  INCF   x8D,F
2DB2:  MOVWF  x94
2DB4:  CALL   0888
2DB8:  BRA    2DA6
....................        delay_ms(3000); 
2DBA:  MOVLW  0C
2DBC:  MOVWF  x8D
2DBE:  MOVLW  FA
2DC0:  MOVWF  x95
2DC2:  CALL   071E
2DC6:  DECFSZ x8D,F
2DC8:  BRA    2DBE
....................        goto David; 
2DCA:  BRA    2694
....................      } 
....................      else if(datom==0x06) 
2DCC:  BRA    2F46
2DCE:  MOVF   x72,W
2DD0:  SUBLW  06
2DD2:  BNZ   2E32
....................      { 
....................        lcd_putc('\f');               //Limpiar pantalla comando 
2DD4:  MOVLW  0C
2DD6:  MOVWF  x94
2DD8:  CALL   0888
....................        lcd_gotoxy(1,1);              //escribir en a primera fila primera posicion  
2DDC:  MOVLW  01
2DDE:  MOVWF  x95
2DE0:  MOVWF  x96
2DE2:  CALL   082C
....................        lcd_putc("MENU CAD");         //lo que se escribe 
2DE6:  CLRF   x8D
2DE8:  MOVF   x8D,W
2DEA:  CALL   065C
2DEE:  IORLW  00
2DF0:  BZ    2DFC
2DF2:  INCF   x8D,F
2DF4:  MOVWF  x94
2DF6:  CALL   0888
2DFA:  BRA    2DE8
....................        lcd_gotoxy(3,2);              //escribir en a primera fila primera posicion  
2DFC:  MOVLW  03
2DFE:  MOVWF  x95
2E00:  MOVLW  02
2E02:  MOVWF  x96
2E04:  CALL   082C
....................        lcd_putc("EN CONSTRUCCION"); 
2E08:  CLRF   x8D
2E0A:  MOVF   x8D,W
2E0C:  CALL   063C
2E10:  IORLW  00
2E12:  BZ    2E1E
2E14:  INCF   x8D,F
2E16:  MOVWF  x94
2E18:  CALL   0888
2E1C:  BRA    2E0A
....................        delay_ms(3000); 
2E1E:  MOVLW  0C
2E20:  MOVWF  x8D
2E22:  MOVLW  FA
2E24:  MOVWF  x95
2E26:  CALL   071E
2E2A:  DECFSZ x8D,F
2E2C:  BRA    2E22
....................        goto David; 
2E2E:  BRA    2694
....................      } 
....................      else if(datom==0x07) 
2E30:  BRA    2F46
2E32:  MOVF   x72,W
2E34:  SUBLW  07
2E36:  BNZ   2E96
....................      { 
....................        lcd_putc('\f');               //Limpiar pantalla comando 
2E38:  MOVLW  0C
2E3A:  MOVWF  x94
2E3C:  CALL   0888
....................        lcd_gotoxy(1,1);              //escribir en a primera fila primera posicion  
2E40:  MOVLW  01
2E42:  MOVWF  x95
2E44:  MOVWF  x96
2E46:  CALL   082C
....................        lcd_putc("MEN DTMF");         //lo que se escribe 
2E4A:  CLRF   x8D
2E4C:  MOVF   x8D,W
2E4E:  CALL   0676
2E52:  IORLW  00
2E54:  BZ    2E60
2E56:  INCF   x8D,F
2E58:  MOVWF  x94
2E5A:  CALL   0888
2E5E:  BRA    2E4C
....................        lcd_gotoxy(3,2);              //escribir en a primera fila primera posicion  
2E60:  MOVLW  03
2E62:  MOVWF  x95
2E64:  MOVLW  02
2E66:  MOVWF  x96
2E68:  CALL   082C
....................        lcd_putc("EN CONSTRUCCION"); 
2E6C:  CLRF   x8D
2E6E:  MOVF   x8D,W
2E70:  CALL   063C
2E74:  IORLW  00
2E76:  BZ    2E82
2E78:  INCF   x8D,F
2E7A:  MOVWF  x94
2E7C:  CALL   0888
2E80:  BRA    2E6E
....................        delay_ms(3000); 
2E82:  MOVLW  0C
2E84:  MOVWF  x8D
2E86:  MOVLW  FA
2E88:  MOVWF  x95
2E8A:  CALL   071E
2E8E:  DECFSZ x8D,F
2E90:  BRA    2E86
....................        goto David; 
2E92:  BRA    2694
....................      } 
....................      else if(datom==0x08) 
2E94:  BRA    2F46
2E96:  MOVF   x72,W
2E98:  SUBLW  08
2E9A:  BNZ   2EFC
....................      { 
....................        lcd_putc('\f');              //Limpiar pantalla comando 
2E9C:  MOVLW  0C
2E9E:  MOVWF  x94
2EA0:  CALL   0888
....................        lcd_gotoxy(1,1);             //escribir en a primera fila primera posicion  
2EA4:  MOVLW  01
2EA6:  MOVWF  x95
2EA8:  MOVWF  x96
2EAA:  CALL   082C
....................        lcd_putc("MEN SENSORES");    //lo que se escribe 
2EAE:  CLRF   x8D
2EB0:  MOVF   x8D,W
2EB2:  CALL   0690
2EB6:  IORLW  00
2EB8:  BZ    2EC4
2EBA:  INCF   x8D,F
2EBC:  MOVWF  x94
2EBE:  CALL   0888
2EC2:  BRA    2EB0
....................        lcd_gotoxy(3,2);             //escribir en a primera fila primera posicion  
2EC4:  MOVLW  03
2EC6:  MOVWF  x95
2EC8:  MOVLW  02
2ECA:  MOVWF  x96
2ECC:  CALL   082C
....................        lcd_putc("EN CONSTRUCCION"); 
2ED0:  CLRF   x8D
2ED2:  MOVF   x8D,W
2ED4:  CALL   063C
2ED8:  IORLW  00
2EDA:  BZ    2EE6
2EDC:  INCF   x8D,F
2EDE:  MOVWF  x94
2EE0:  CALL   0888
2EE4:  BRA    2ED2
....................        delay_ms(3000); 
2EE6:  MOVLW  0C
2EE8:  MOVWF  x8D
2EEA:  MOVLW  FA
2EEC:  MOVWF  x95
2EEE:  CALL   071E
2EF2:  DECFSZ x8D,F
2EF4:  BRA    2EEA
....................        goto David; 
2EF6:  GOTO   2694
....................      } 
....................      else if(datom==0x09) 
2EFA:  BRA    2F46
2EFC:  MOVF   x72,W
2EFE:  SUBLW  09
2F00:  BNZ   2F08
....................      { 
....................       goto admin; 
2F02:  GOTO   1BD2
....................      } 
....................      else{ 
2F06:  BRA    2F46
....................           lcd_putc('\f');                 //Limpiar pantalla comando 
2F08:  MOVLW  0C
2F0A:  MOVWF  x94
2F0C:  CALL   0888
....................           lcd_gotoxy(1,2);                //escribir en a primera fila primera posicion  
2F10:  MOVLW  01
2F12:  MOVWF  x95
2F14:  MOVLW  02
2F16:  MOVWF  x96
2F18:  CALL   082C
....................           lcd_putc("ERROR DE NUMERO");   //lo que se escribe 
2F1C:  CLRF   x8D
2F1E:  MOVF   x8D,W
2F20:  CALL   0272
2F24:  IORLW  00
2F26:  BZ    2F32
2F28:  INCF   x8D,F
2F2A:  MOVWF  x94
2F2C:  CALL   0888
2F30:  BRA    2F1E
....................           delay_ms(3000); 
2F32:  MOVLW  0C
2F34:  MOVWF  x8D
2F36:  MOVLW  FA
2F38:  MOVWF  x95
2F3A:  CALL   071E
2F3E:  DECFSZ x8D,F
2F40:  BRA    2F36
....................           goto menu; 
2F42:  GOTO   1A3C
....................       } 
....................      }else{ 
2F46:  BRA    2F86
....................      lcd_putc('\f');                 //Limpiar pantalla comando 
2F48:  MOVLW  0C
2F4A:  MOVWF  x94
2F4C:  CALL   0888
....................      lcd_gotoxy(1,2);                //escribir en a primera fila primera posicion  
2F50:  MOVLW  01
2F52:  MOVWF  x95
2F54:  MOVLW  02
2F56:  MOVWF  x96
2F58:  CALL   082C
....................      lcd_putc("CONTRA. ERRONEA");   //lo que se escribe 
2F5C:  CLRF   x8D
2F5E:  MOVF   x8D,W
2F60:  CALL   06FE
2F64:  IORLW  00
2F66:  BZ    2F72
2F68:  INCF   x8D,F
2F6A:  MOVWF  x94
2F6C:  CALL   0888
2F70:  BRA    2F5E
....................      delay_ms(3000); 
2F72:  MOVLW  0C
2F74:  MOVWF  x8D
2F76:  MOVLW  FA
2F78:  MOVWF  x95
2F7A:  CALL   071E
2F7E:  DECFSZ x8D,F
2F80:  BRA    2F76
....................      goto menu; 
2F82:  GOTO   1A3C
....................      } 
....................    } 
2F86:  SLEEP 

Configuration Fuses:
   Word  1: 0C00   NOIESO NOFCMEN HS PLL1 CPUDIV1 NOUSBDIV
   Word  2: 1E18   NOBROWNOUT NOWDT BORV20 PUT WDT32768 NOVREGEN
   Word  3: 0300   PBADEN CCP2C1 NOMCLR NOLPT1OSC
   Word  4: 0081   STVREN NODEBUG NOLVP NOXINST NOICPRT
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: E00F   NOWRT NOWRTD NOWRTC NOWRTB
   Word  7: 400F   NOEBTR NOEBTRB

ROM data:
F00000: 23 45 34 56 
