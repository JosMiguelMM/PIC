CCS PCH C Compiler, Version 4.093, 51109               10-oct.-21 21:21

               Filename: C:\Proyecto arquitectura c\Memoria\memoriaex.lst

               ROM used: 8290 bytes (25%)
                         Largest free fragment is 24478
               RAM used: 45 (2%) at main() level
                         57 (3%) worst case
               Stack:    5 locations

*
0000:  GOTO   0ED6
.................... #include <18F4550.h> 
.................... //////// Standard Header file for the PIC18F4550 device //////////////// 
.................... #device PIC18F4550 
.................... #list 
....................  
.................... #fuses     HS,NOPROTECT,NOBROWNOUT,NOWDT,PUT,NOCPD,NODEBUG,NOLVP,NOMCLR  
.................... #use       delay(clock=20000000) 
*
0590:  CLRF   FEA
0592:  MOVLW  2F
0594:  MOVWF  FE9
0596:  MOVF   FEF,W
0598:  BZ    05B4
059A:  MOVLW  06
059C:  MOVWF  01
059E:  CLRF   00
05A0:  DECFSZ 00,F
05A2:  BRA    05A0
05A4:  DECFSZ 01,F
05A6:  BRA    059E
05A8:  MOVLW  7B
05AA:  MOVWF  00
05AC:  DECFSZ 00,F
05AE:  BRA    05AC
05B0:  DECFSZ FEF,F
05B2:  BRA    059A
05B4:  RETLW  00
.................... #include   <stdlib.h>           //LIBRERIAS MATEMATICAS IGUAL LA DE ABAJO 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = TRUE, sign = FALSE, point = FALSE; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = FALSE; 
....................          if (c == '+') 
....................          { 
....................             sign = FALSE; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = TRUE; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = TRUE; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = TRUE, sign = FALSE, point = FALSE; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = FALSE; 
....................          if (c == '+') 
....................          { 
....................             sign = FALSE; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = TRUE; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = TRUE; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = TRUE, sign = FALSE, point = FALSE; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = FALSE; 
....................          if (c == '+') 
....................          { 
....................             sign = FALSE; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = TRUE; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = TRUE; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    BYTE t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=TRUE; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = FALSE; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include   <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float32)l); 
....................   res = 32768.0*(float32)l; 
....................   res += (float32)(unsigned int16)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float48)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float48)l); 
....................   res = 32768.0*(float32)l; 
....................   res += (float48)(unsigned int16)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float48)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float64)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float64)l); 
....................   res = 32768.0*(float64)l; 
....................   res += (float64)(unsigned int16)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float64)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y/LN2 - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y/LN2 - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y/LN2 - (float64)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {0.45145214, -9.0558803, 26.940971, -19.860189}; 
.................... float32 const ql[4] = {1.0000000,  -8.1354259, 16.780517, -9.9300943}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................    bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................       res = res*y2 + pl[2]; 
....................       res = res*y2 + pl[3]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + ql[2]; 
....................       r = r*y2 + ql[3]; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................     
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................    
....................       if(bit_test(data2,7)) 
....................          bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................       res = res*y2 + pl[2]; 
....................       res = res*y2 + pl[3]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + ql[2]; 
....................       r = r*y2 + ql[3]; 
....................  
....................       res = y*res/r; 
....................  
....................     data1 = *(((unsigned int8 *)(&x)+5)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+4)); 
....................     if(bit_test (data2,7)) 
....................        bit_set(data1,0); 
....................       
....................     n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................          r = -(float48)-n; 
....................       else 
....................          r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float32 const pl_64[4] = {0.45145214, -9.0558803, 26.940971, -19.860189}; 
.................... float32 const ql_64[4] = {1.0000000,  -8.1354259, 16.780517, -9.9300943}; 
.................... #endif 
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................       bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................     bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................    bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................      bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #define TWOBYPI          0.6366197723675813 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[4] = { 
....................       -0.499999993585, 
....................        0.041666636258, 
....................       -0.0013888361399, 
....................        0.00002476016134 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 3; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[4] = { 
....................       -0.499999993585, 
....................        0.041666636258, 
....................       -0.0013888361399, 
....................        0.00002476016134 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 3; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float48 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p[4] = { 
....................       -0.499999993585, 
....................        0.041666636258, 
....................       -0.0013888361399, 
....................        0.00002476016134 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 3; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #define   LCD_E    PIN_E2 
.................... #define   LCD_CK   PIN_E1 
.................... #define   LCD_DAT  PIN_E0 
.................... #include <LCD4x20_3PIN.c> 
.................... // flex_lcd_3_pins.c 
....................  
.................... //Modificacin de Flex_lcd por Duende_Azul y Akenafab 
.................... //Trabaja con 3 pines y 74VHC164 
.................... //8-Bit Serial-In, Parallel-Out Shift Register 
....................  
.................... //La LCD se usa en modo 4bits 
.................... //Revisar diagrama de conexion Adjunto 
....................  
.................... //No esta habilitada la lectura del LCD 
.................... //RW debe ir a gnd 
....................  
.................... //Definir pines antes de llamar libreria// 
.................... //#define LCD_E     PIN_A0 
.................... //#define LCD_CK    PIN_A1    
.................... //#define LCD_DAT   PIN_A2 
....................  
.................... //======================================== 
.................... int RS_bit; 
.................... #define lcd_type 2        // 0=5x7, 1=5x10, 2=2 lines 
.................... #define lcd_line_two 0x40 // LCD RAM address for the 2nd line 
....................  
....................  
.................... int8 const LCD_INIT_STRING[4] = 
.................... { 
....................  0x20 | (lcd_type << 2), // Func set: 4-bit, 2 lines, 5x8 dots 
....................  0xc,                    // Display on 
....................  1,                      // Clear display 
....................  6                       // Increment cursor 
....................  }; 
.................... BYTE lcdline; 
....................  
.................... //------------------------------------- 
.................... void lcd_send_nibble(int8 nibble, int rs_bit) 
.................... { 
....................  
.................... int x; 
.................... if(RS_bit==1) 
05B6:  DECFSZ 37,W
05B8:  BRA    05BC
....................    nibble=nibble|0x10; 
05BA:  BSF    36.4
....................  
.................... for(x=0;x<5;x++){ 
05BC:  CLRF   38
05BE:  MOVF   38,W
05C0:  SUBLW  04
05C2:  BNC   05E6
....................          output_bit(LCD_DAT,shift_right(&nibble,1,0)); 
05C4:  BCF    FD8.0
05C6:  RRCF   36,F
05C8:  BC    05CE
05CA:  BCF    F8D.0
05CC:  BRA    05D0
05CE:  BSF    F8D.0
05D0:  BCF    F96.0
....................          delay_cycles(1); 
05D2:  NOP   
....................          output_low(LCD_CK); 
05D4:  BCF    F96.1
05D6:  BCF    F8D.1
....................          delay_us(1); 
05D8:  BRA    05DA
05DA:  BRA    05DC
05DC:  NOP   
....................          output_high(LCD_CK);} 
05DE:  BCF    F96.1
05E0:  BSF    F8D.1
05E2:  INCF   38,F
05E4:  BRA    05BE
....................  
....................  
....................  
....................  output_high(LCD_E); 
05E6:  BCF    F96.2
05E8:  BSF    F8D.2
....................  delay_us(2); 
05EA:  MOVLW  03
05EC:  MOVWF  00
05EE:  DECFSZ 00,F
05F0:  BRA    05EE
....................  output_low(LCD_E); 
05F2:  BCF    F96.2
05F4:  BCF    F8D.2
.................... } 
05F6:  RETLW  00
....................  
.................... //----------------------------------- 
.................... //---------------------------------------- 
.................... // Send a byte to the LCD. 
.................... void lcd_send_byte(int8 address, int8 n) 
.................... { 
.................... //output_low(LCD_RS); 
.................... RS_bit=0; 
05F8:  CLRF   0B
.................... delay_us(100); 
05FA:  MOVLW  A6
05FC:  MOVWF  00
05FE:  DECFSZ 00,F
0600:  BRA    05FE
0602:  NOP   
....................  
....................  
.................... if(address) 
0604:  MOVF   33,F
0606:  BZ    060E
....................    //output_high(LCD_RS); 
....................    RS_bit=1; 
0608:  MOVLW  01
060A:  MOVWF  0B
.................... else 
060C:  BRA    0610
....................    //output_low(LCD_RS); 
....................    RS_bit=0; 
060E:  CLRF   0B
....................  
....................  delay_cycles(1); 
0610:  NOP   
....................  
....................  
.................... output_low(LCD_E); 
0612:  BCF    F96.2
0614:  BCF    F8D.2
....................  
.................... lcd_send_nibble(n >> 4,RS_bit); 
0616:  SWAPF  34,W
0618:  MOVWF  35
061A:  MOVLW  0F
061C:  ANDWF  35,F
061E:  MOVFF  35,36
0622:  MOVFF  0B,37
0626:  RCALL  05B6
.................... lcd_send_nibble(n & 0xf,RS_bit); 
0628:  MOVF   34,W
062A:  ANDLW  0F
062C:  MOVWF  35
062E:  MOVWF  36
0630:  MOVFF  0B,37
0634:  RCALL  05B6
.................... } 
0636:  RETLW  00
....................  
.................... //---------------------------- 
.................... void lcd_init(void) 
.................... { 
.................... int8 i; 
....................  
.................... //output_low(LCD_RS); 
.................... RS_bit=0; 
0638:  CLRF   0B
....................  
.................... output_low(LCD_E); 
063A:  BCF    F96.2
063C:  BCF    F8D.2
....................  
.................... delay_ms(20); 
063E:  MOVLW  14
0640:  MOVWF  2F
0642:  RCALL  0590
....................  
.................... for(i=0 ;i < 3; i++) 
0644:  CLRF   2C
0646:  MOVF   2C,W
0648:  SUBLW  02
064A:  BNC   0660
....................    { 
....................     lcd_send_nibble(0x03,RS_bit); 
064C:  MOVLW  03
064E:  MOVWF  36
0650:  MOVFF  0B,37
0654:  RCALL  05B6
....................     delay_ms(5); 
0656:  MOVLW  05
0658:  MOVWF  2F
065A:  RCALL  0590
....................    } 
065C:  INCF   2C,F
065E:  BRA    0646
....................  
.................... lcd_send_nibble(0x02,RS_bit); 
0660:  MOVLW  02
0662:  MOVWF  36
0664:  MOVFF  0B,37
0668:  RCALL  05B6
....................  
.................... for(i=0; i < sizeof(LCD_INIT_STRING); i++) 
066A:  CLRF   2C
066C:  MOVF   2C,W
066E:  SUBLW  03
0670:  BNC   0694
....................    { 
....................     lcd_send_byte(0, LCD_INIT_STRING[i]); 
0672:  CLRF   03
0674:  MOVF   2C,W
0676:  MOVFF  FF2,2D
067A:  BCF    FF2.7
067C:  RCALL  0004
067E:  BTFSC  2D.7
0680:  BSF    FF2.7
0682:  MOVWF  2D
0684:  CLRF   33
0686:  MOVWF  34
0688:  RCALL  05F8
....................  
....................     delay_ms(5); 
068A:  MOVLW  05
068C:  MOVWF  2F
068E:  RCALL  0590
....................      
....................    } 
0690:  INCF   2C,F
0692:  BRA    066C
....................  
.................... } 
0694:  GOTO   0F1E (RETURN)
....................  
.................... //---------------------------- 
....................  
.................... void lcd_gotoxy(int8 x, int8 y) 
.................... { 
.................... int8 address; 
....................  
....................    switch(y) { 
*
069C:  MOVLW  01
069E:  SUBWF  30,W
06A0:  ADDLW  FC
06A2:  BC    06C2
06A4:  ADDLW  04
06A6:  GOTO   06D6
....................      case 1 : address=0x80;break; 
06AA:  MOVLW  80
06AC:  MOVWF  31
06AE:  BRA    06C2
....................      case 2 : address=0xc0;break; 
06B0:  MOVLW  C0
06B2:  MOVWF  31
06B4:  BRA    06C2
....................      case 3 : address=0x94;break; 
06B6:  MOVLW  94
06B8:  MOVWF  31
06BA:  BRA    06C2
....................      case 4 : address=0xd4;break; 
06BC:  MOVLW  D4
06BE:  MOVWF  31
06C0:  BRA    06C2
....................    } 
.................... address += x-1; 
06C2:  MOVLW  01
06C4:  SUBWF  2F,W
06C6:  ADDWF  31,F
.................... lcd_send_byte(0, 0x80 | address); 
06C8:  MOVF   31,W
06CA:  IORLW  80
06CC:  MOVWF  32
06CE:  CLRF   33
06D0:  MOVWF  34
06D2:  RCALL  05F8
.................... } 
06D4:  RETLW  00
....................  
.................... //----------------------------- 
.................... void lcd_putc(char c) 
.................... { 
....................  switch(c) 
....................    { 
*
06F8:  MOVF   2E,W
06FA:  XORLW  0C
06FC:  BZ    0714
06FE:  XORLW  06
0700:  BZ    0728
0702:  XORLW  02
0704:  BZ    0736
0706:  XORLW  6B
0708:  BZ    0740
070A:  XORLW  04
070C:  BZ    074A
070E:  XORLW  0F
0710:  BZ    0754
0712:  BRA    075E
....................     case '\f':                //limpia pantalla 
....................       lcd_send_byte(0,1); 
0714:  CLRF   33
0716:  MOVLW  01
0718:  MOVWF  34
071A:  RCALL  05F8
....................       lcdline=1; 
071C:  MOVLW  01
071E:  MOVWF  0C
....................       delay_ms(8); 
0720:  MOVLW  08
0722:  MOVWF  2F
0724:  RCALL  0590
....................       break; 
0726:  BRA    076A
....................  
....................     case '\n':                //cambio de linea 
....................        lcd_gotoxy(1,++lcdline); 
0728:  INCF   0C,F
072A:  MOVLW  01
072C:  MOVWF  2F
072E:  MOVFF  0C,30
0732:  RCALL  069C
....................        break; 
0734:  BRA    076A
....................  
....................     case '\b':                //retrocede 1 caracter 
....................        lcd_send_byte(0,0x10); 
0736:  CLRF   33
0738:  MOVLW  10
073A:  MOVWF  34
073C:  RCALL  05F8
....................        break; 
073E:  BRA    076A
....................         
....................     case '\c':                //on display 
....................     lcd_send_byte(0,0x0c); 
0740:  CLRF   33
0742:  MOVLW  0C
0744:  MOVWF  34
0746:  RCALL  05F8
....................     break; 
0748:  BRA    076A
....................     
....................     case '\g':                 
....................     lcd_send_byte(0,0x0f);    // prende cursor y parpadea 
074A:  CLRF   33
074C:  MOVLW  0F
074E:  MOVWF  34
0750:  RCALL  05F8
....................     break;   
0752:  BRA    076A
....................  
....................     case '\h':                //retrocede 1 caracter 
....................     lcd_send_byte(0,0x0f);    // prende cursor y parpadea 
0754:  CLRF   33
0756:  MOVLW  0F
0758:  MOVWF  34
075A:  RCALL  05F8
....................     break; 
075C:  BRA    076A
....................      
....................     default: 
....................        lcd_send_byte(1,c); 
075E:  MOVLW  01
0760:  MOVWF  33
0762:  MOVFF  2E,34
0766:  RCALL  05F8
....................        break; 
0768:  BRA    076A
....................    } 
.................... } 
076A:  RETLW  00
....................  
.................... //------------------------------ 
....................  
.................... void lcd_cursor_vb(short visible, short blink) {  
....................   lcd_send_byte(0, 0xC|(visible<<1)|blink);  
.................... }  
....................  
....................  
.................... #include <KBD18F.c> 
.................... //////////////////////////////////////////////////////////////////////////////////// 
.................... //                                   KBD.C                                        // 
.................... //               FUNCIONES PARA ESCANEO DE UN TECLADO MATRICIAL                   // 
.................... //                         4X4 HEXADECIMAL, EN EL PORTB                           // 
.................... //       kbd_init()       Debe ser invocada antes que las otras funciones.         // 
.................... //       c=lcd_getc(c)    Si h sido presionada una tecla devuelve el caracter c    // 
.................... //                  y lo salva en el char c, sino se presiona una tecla       // 
.................... //                  retorna el valor /0, esta funcin puede invocarse         // 
.................... //                  frecuentemente para no perder teclas pulsadas.            // 
.................... //        NOTA: REQUIERE COLOCAR RESISTENCIAS (2.2K) EN LOS PINES DE COLUMNAS     // 
.................... //               PINES DE COLUMNAS DE RB0(COL0) A RB3(COL3))                   // 
.................... //               PINES DE FILAS DE RB4(ROW0)) A RB7(ROW3))                    //  
.................... //                  MODIF.: ING. FRANK GIRALDO - UD                       // 
.................... //////////////////////////////////////////////////////////////////////////////////// 
.................... /*//////////////////////////////////////////////////////////////////////////////////  
.................... *    RB0 RB1 RB2 RB3    
.................... *     |   |   |   | 
.................... *     c0  c1  c2  c3   
.................... *   | 1 | 2 | 3 | F | r0 - RB4 
.................... *   | 4 | 5 | 6 | E | r1 - RB5 
.................... *   | 7 | 8 | 9 | D | r2 - RB6 
.................... *   | A | 0 | B | C | r3 - RB7 
.................... * 
.................... *   COLUMNS=OUTs 
.................... *   ROWS=INs 
.................... *   SE HABILITAN PULL-UP INTERNAS  
.................... *   SE REQUIERE COLOCAR RESISTENCIAS (2.2K) EN LOS PINES DE COLUMNAS  
.................... * 
.................... */////////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... #byte portkbd = 0XF81                  //portkbd = portB 
.................... //Keypad connection:   (Column 0 es B0) 
.................... //                Bx: 
.................... #define COL0 (0 << 0) 
.................... #define COL1 (0 << 1) 
.................... #define COL2 (0 << 2) 
.................... #define COL3 (0 << 3) 
.................... #define ROW0 (1 << 4) 
.................... #define ROW1 (1 << 5) 
.................... #define ROW2 (1 << 6) 
.................... #define ROW3 (1 << 7) 
.................... #define ALL_ROWS (ROW3|ROW2|ROW1|ROW0) 
.................... #define ALL_PINS (ALL_ROWS|COL3|COL2|COL1|COL0) 
....................  
.................... char const KEYS[4][4] = {{'1','2','3','A'}, 
....................                          {'4','5','6','B'}, 
....................                          {'7','8','9','C'}, 
....................                          {'*','0','#','D'}}; 
....................  
.................... #define KBD_DEBOUNCE_FACTOR 0.2 
.................... // Modifique el valor de temporizacin antirrebote con (KBD_DEBOUNCE_FACTOR = n/333), 
.................... // en donde n es el nmero de veces por segundo en los que ud. invoca 
.................... //la funcin kbd_getc(). 
.................... // 
....................  
.................... void kbd_init(){ 
.................... } 
*
0698:  GOTO   0F22 (RETURN)
....................  
.................... char kbd_getc( ) 
.................... { 
....................    static BYTE kbd_call_count; 
....................    static short int kbd_down; 
....................    static char last_key; 
....................    static BYTE col; 
....................    BYTE kchar; 
....................    BYTE row; 
....................    port_b_pullups(TRUE); 
*
0A04:  BCF    FF1.7
....................    kchar='\0'; 
0A06:  CLRF   2C
....................  
....................    if(++kbd_call_count>KBD_DEBOUNCE_FACTOR) 
0A08:  INCF   0D,F
0A0A:  CLRF   2F
0A0C:  MOVFF  0D,2E
0A10:  BRA    0954
0A12:  MOVLW  CD
0A14:  MOVWF  31
0A16:  MOVLW  CC
0A18:  MOVWF  30
0A1A:  MOVLW  4C
0A1C:  MOVWF  2F
0A1E:  MOVLW  7C
0A20:  MOVWF  2E
0A22:  MOVFF  03,35
0A26:  MOVFF  02,34
0A2A:  MOVFF  01,33
0A2E:  MOVFF  00,32
0A32:  BRA    098C
0A34:  BNC   0AEC
....................    { 
....................        switch (col) 
....................        { 
0A36:  MOVF   10,W
0A38:  ADDLW  FC
0A3A:  BC    0A6A
0A3C:  ADDLW  04
0A3E:  GOTO   0AFA
....................          case 0   : set_tris_b(ALL_PINS&~COL0); 
0A42:  MOVLW  F0
0A44:  MOVWF  F93
....................                     portkbd=(0b1110); 
0A46:  MOVLW  0E
0A48:  MOVWF  F81
....................                     break; 
0A4A:  BRA    0A6A
....................  
....................          case 1   : set_tris_b(ALL_PINS&~COL1); 
0A4C:  MOVLW  F0
0A4E:  MOVWF  F93
....................                     portkbd=(0b1101); 
0A50:  MOVLW  0D
0A52:  MOVWF  F81
....................                     break; 
0A54:  BRA    0A6A
....................  
....................          case 2   : set_tris_b(ALL_PINS&~COL2); 
0A56:  MOVLW  F0
0A58:  MOVWF  F93
....................                     portkbd=(0b1011); 
0A5A:  MOVLW  0B
0A5C:  MOVWF  F81
....................                     break; 
0A5E:  BRA    0A6A
....................  
....................          case 3   : set_tris_b(ALL_PINS&~COL3); 
0A60:  MOVLW  F0
0A62:  MOVWF  F93
....................                     portkbd=(0b0111); 
0A64:  MOVLW  07
0A66:  MOVWF  F81
....................                     break; 
0A68:  BRA    0A6A
....................        } 
....................  
....................        if(kbd_down) 
0A6A:  BTFSS  0E.0
0A6C:  BRA    0A80
....................        { 
....................          if((portkbd & (ALL_ROWS))==(ALL_ROWS)) 
0A6E:  MOVF   F81,W
0A70:  ANDLW  F0
0A72:  SUBLW  F0
0A74:  BNZ   0A7E
....................          { 
....................            kbd_down=FALSE; 
0A76:  BCF    0E.0
....................            kchar=last_key; 
0A78:  MOVFF  0F,2C
....................            last_key='\0'; 
0A7C:  CLRF   0F
....................          } 
....................        } 
....................        else 
0A7E:  BRA    0AEA
....................        { 
....................           if((portkbd & (ALL_ROWS))!=(ALL_ROWS)) 
0A80:  MOVF   F81,W
0A82:  ANDLW  F0
0A84:  SUBLW  F0
0A86:  BZ    0AE0
....................           { 
....................              if((portkbd & ROW0) == 0) 
0A88:  MOVF   F81,W
0A8A:  ANDLW  10
0A8C:  BNZ   0A92
....................                row = 0; 
0A8E:  CLRF   2D
....................              else if((portkbd & ROW1) == 0) 
0A90:  BRA    0AB4
0A92:  MOVF   F81,W
0A94:  ANDLW  20
0A96:  BNZ   0A9E
....................                row = 1; 
0A98:  MOVLW  01
0A9A:  MOVWF  2D
....................              else if((portkbd & ROW2) == 0) 
0A9C:  BRA    0AB4
0A9E:  MOVF   F81,W
0AA0:  ANDLW  40
0AA2:  BNZ   0AAA
....................                row = 2; 
0AA4:  MOVLW  02
0AA6:  MOVWF  2D
....................              else if((portkbd & ROW3) == 0) 
0AA8:  BRA    0AB4
0AAA:  MOVF   F81,W
0AAC:  ANDLW  80
0AAE:  BNZ   0AB4
....................                row = 3; 
0AB0:  MOVLW  03
0AB2:  MOVWF  2D
....................              last_key = KEYS[row][col]; 
0AB4:  MOVF   2D,W
0AB6:  MULLW  04
0AB8:  MOVF   FF3,W
0ABA:  CLRF   2F
0ABC:  MOVWF  2E
0ABE:  CLRF   03
0AC0:  MOVF   10,W
0AC2:  ADDWF  2E,W
0AC4:  MOVWF  01
0AC6:  MOVF   2F,W
0AC8:  ADDWFC 03,F
0ACA:  MOVF   01,W
0ACC:  MOVFF  FF2,2E
0AD0:  BCF    FF2.7
0AD2:  CALL   0018
0AD6:  BTFSC  2E.7
0AD8:  BSF    FF2.7
0ADA:  MOVWF  0F
....................              kbd_down = TRUE; 
0ADC:  BSF    0E.0
....................           } 
....................           else 
0ADE:  BRA    0AEA
....................           { 
....................              ++col; 
0AE0:  INCF   10,F
....................              if(col==4) 
0AE2:  MOVF   10,W
0AE4:  SUBLW  04
0AE6:  BNZ   0AEA
....................              col=0; 
0AE8:  CLRF   10
....................           } 
....................        } 
....................       kbd_call_count=0; 
0AEA:  CLRF   0D
....................    } 
....................   kchar = last_key; 
0AEC:  MOVFF  0F,2C
....................   set_tris_b(ALL_PINS); 
0AF0:  MOVLW  F0
0AF2:  MOVWF  F93
....................   return(kchar); 
0AF4:  MOVFF  2C,01
.................... } 
0AF8:  RETLW  00
....................  
.................... /*char dato; 
.................... char tecla() 
.................... { 
....................    dato='\0'; 
....................    while(dato=='\0') 
....................    { 
....................       dato=kbd_getc(); 
....................       delay_ms(100); 
....................    } 
.................... return dato; 
.................... } */ 
....................  
.................... //#include <DS1307.c> 
.................... #include <24C512.c> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////   Library for a 24LC512 serial EEPROM                             //// 
.................... ////                                                                   //// 
.................... ////   init_ext_eeprom();    Call before the other functions are used  //// 
.................... ////                                                                   //// 
.................... ////   write_ext_eeprom(a, d);  Write the byte d to the address a      //// 
.................... ////                                                                   //// 
.................... ////   d = read_ext_eeprom(a);   Read the byte d from the address a    //// 
.................... ////                                                                   //// 
.................... ////   The main program may define eeprom_sda                          //// 
.................... ////   and eeprom_scl to override the defaults below.                  //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef EEPROM_SDA 
....................  
.................... #define EEPROM_SDA  PIN_A1 
.................... #define EEPROM_SCL  PIN_A0 
....................  
.................... #endif 
....................  
.................... #use i2c(master, sda=EEPROM_SDA, scl=EEPROM_SCL) 
*
07A8:  MOVLW  08
07AA:  MOVWF  01
07AC:  MOVLW  05
07AE:  MOVWF  00
07B0:  DECFSZ 00,F
07B2:  BRA    07B0
07B4:  BCF    F89.0
07B6:  BCF    F92.0
07B8:  MOVLW  06
07BA:  MOVWF  00
07BC:  DECFSZ 00,F
07BE:  BRA    07BC
07C0:  RLCF   33,F
07C2:  BCF    F89.1
07C4:  BTFSC  FD8.0
07C6:  BSF    F92.1
07C8:  BTFSS  FD8.0
07CA:  BCF    F92.1
07CC:  BSF    F92.0
07CE:  BTFSS  F80.0
07D0:  BRA    07CE
07D2:  DECFSZ 01,F
07D4:  BRA    07AC
07D6:  MOVLW  05
07D8:  MOVWF  00
07DA:  DECFSZ 00,F
07DC:  BRA    07DA
07DE:  BCF    F89.0
07E0:  BCF    F92.0
07E2:  NOP   
07E4:  BSF    F92.1
07E6:  MOVLW  06
07E8:  MOVWF  00
07EA:  DECFSZ 00,F
07EC:  BRA    07EA
07EE:  MOVLW  06
07F0:  MOVWF  00
07F2:  DECFSZ 00,F
07F4:  BRA    07F2
07F6:  BSF    F92.0
07F8:  BTFSS  F80.0
07FA:  BRA    07F8
07FC:  CLRF   01
07FE:  MOVLW  06
0800:  MOVWF  00
0802:  DECFSZ 00,F
0804:  BRA    0802
0806:  BTFSC  F80.1
0808:  BSF    01.0
080A:  BCF    F89.0
080C:  BCF    F92.0
080E:  BCF    F89.1
0810:  BCF    F92.1
0812:  RETLW  00
0814:  MOVLW  08
0816:  MOVWF  32
0818:  MOVFF  00,33
081C:  BSF    F92.1
081E:  MOVLW  06
0820:  MOVWF  00
0822:  DECFSZ 00,F
0824:  BRA    0822
0826:  BSF    F92.0
0828:  BTFSS  F80.0
082A:  BRA    0828
082C:  BTFSC  F80.1
082E:  BSF    FD8.0
0830:  BTFSS  F80.1
0832:  BCF    FD8.0
0834:  RLCF   01,F
0836:  MOVLW  05
0838:  MOVWF  00
083A:  DECFSZ 00,F
083C:  BRA    083A
083E:  BCF    F92.0
0840:  BCF    F89.0
0842:  DECFSZ 32,F
0844:  BRA    081C
0846:  BSF    F92.1
0848:  MOVLW  06
084A:  MOVWF  00
084C:  DECFSZ 00,F
084E:  BRA    084C
0850:  BCF    F89.1
0852:  MOVF   33,W
0854:  BTFSS  FD8.2
0856:  BCF    F92.1
0858:  NOP   
085A:  BSF    F92.0
085C:  BTFSS  F80.0
085E:  BRA    085C
0860:  MOVLW  05
0862:  MOVWF  00
0864:  DECFSZ 00,F
0866:  BRA    0864
0868:  BCF    F89.0
086A:  BCF    F92.0
086C:  MOVLW  06
086E:  MOVWF  00
0870:  DECFSZ 00,F
0872:  BRA    0870
0874:  BCF    F89.1
0876:  BCF    F92.1
0878:  GOTO   08EA (RETURN)
....................  
.................... #define EEPROM_ADDRESS long int 
.................... #define EEPROM_SIZE   65535 
....................  
.................... void init_ext_eeprom() 
.................... { 
....................    output_float(EEPROM_SCL); 
....................    output_float(EEPROM_SDA); 
....................  
.................... } 
....................  
.................... void write_ext_eeprom(long int address, BYTE data) 
.................... { 
....................    short int status; 
....................    i2c_start(); 
*
0DAC:  BSF    F92.1
0DAE:  MOVLW  05
0DB0:  MOVWF  00
0DB2:  DECFSZ 00,F
0DB4:  BRA    0DB2
0DB6:  BSF    F92.0
0DB8:  MOVLW  06
0DBA:  MOVWF  00
0DBC:  DECFSZ 00,F
0DBE:  BRA    0DBC
0DC0:  BCF    F89.1
0DC2:  BCF    F92.1
0DC4:  MOVLW  05
0DC6:  MOVWF  00
0DC8:  DECFSZ 00,F
0DCA:  BRA    0DC8
0DCC:  BCF    F89.0
0DCE:  BCF    F92.0
....................    i2c_write(0xa0); 
0DD0:  MOVLW  A0
0DD2:  MOVWF  33
0DD4:  RCALL  07A8
....................    i2c_write(address>>8); 
0DD6:  MOVFF  2E,31
0DDA:  CLRF   32
0DDC:  MOVFF  2E,33
0DE0:  RCALL  07A8
....................    i2c_write(address); 
0DE2:  MOVFF  2D,33
0DE6:  RCALL  07A8
....................    i2c_write(data); 
0DE8:  MOVFF  2F,33
0DEC:  RCALL  07A8
....................    i2c_stop(); 
0DEE:  BCF    F92.1
0DF0:  NOP   
0DF2:  BSF    F92.0
0DF4:  BTFSS  F80.0
0DF6:  BRA    0DF4
0DF8:  MOVLW  05
0DFA:  MOVWF  00
0DFC:  DECFSZ 00,F
0DFE:  BRA    0DFC
0E00:  BRA    0E02
0E02:  NOP   
0E04:  BSF    F92.1
0E06:  MOVLW  05
0E08:  MOVWF  00
0E0A:  DECFSZ 00,F
0E0C:  BRA    0E0A
....................    i2c_start(); 
0E0E:  BSF    F92.1
0E10:  MOVLW  05
0E12:  MOVWF  00
0E14:  DECFSZ 00,F
0E16:  BRA    0E14
0E18:  BSF    F92.0
0E1A:  MOVLW  06
0E1C:  MOVWF  00
0E1E:  DECFSZ 00,F
0E20:  BRA    0E1E
0E22:  BCF    F89.1
0E24:  BCF    F92.1
0E26:  MOVLW  05
0E28:  MOVWF  00
0E2A:  DECFSZ 00,F
0E2C:  BRA    0E2A
0E2E:  BCF    F89.0
0E30:  BCF    F92.0
....................    status=i2c_write(0xa0); 
0E32:  MOVLW  A0
0E34:  MOVWF  33
0E36:  RCALL  07A8
0E38:  MOVF   01,W
0E3A:  BCF    30.0
0E3C:  BTFSC  01.0
0E3E:  BSF    30.0
....................    while(status==1) 
....................    { 
0E40:  BTFSS  30.0
0E42:  BRA    0E7C
....................       i2c_start(); 
0E44:  BSF    F92.1
0E46:  MOVLW  05
0E48:  MOVWF  00
0E4A:  DECFSZ 00,F
0E4C:  BRA    0E4A
0E4E:  BSF    F92.0
0E50:  MOVLW  06
0E52:  MOVWF  00
0E54:  DECFSZ 00,F
0E56:  BRA    0E54
0E58:  BTFSS  F80.0
0E5A:  BRA    0E58
0E5C:  BCF    F89.1
0E5E:  BCF    F92.1
0E60:  MOVLW  05
0E62:  MOVWF  00
0E64:  DECFSZ 00,F
0E66:  BRA    0E64
0E68:  BCF    F89.0
0E6A:  BCF    F92.0
....................       status=i2c_write(0xa0); 
0E6C:  MOVLW  A0
0E6E:  MOVWF  33
0E70:  RCALL  07A8
0E72:  MOVF   01,W
0E74:  BCF    30.0
0E76:  BTFSC  01.0
0E78:  BSF    30.0
....................    } 
0E7A:  BRA    0E40
....................    i2c_stop(); 
0E7C:  BCF    F92.1
0E7E:  NOP   
0E80:  BSF    F92.0
0E82:  BTFSS  F80.0
0E84:  BRA    0E82
0E86:  MOVLW  05
0E88:  MOVWF  00
0E8A:  DECFSZ 00,F
0E8C:  BRA    0E8A
0E8E:  BRA    0E90
0E90:  NOP   
0E92:  BSF    F92.1
0E94:  MOVLW  05
0E96:  MOVWF  00
0E98:  DECFSZ 00,F
0E9A:  BRA    0E98
.................... } 
0E9C:  GOTO   0EC6 (RETURN)
....................  
.................... BYTE read_ext_eeprom(long int address) { 
....................    BYTE data; 
....................    i2c_start(); 
*
087C:  BSF    F92.1
087E:  MOVLW  05
0880:  MOVWF  00
0882:  DECFSZ 00,F
0884:  BRA    0882
0886:  BSF    F92.0
0888:  MOVLW  06
088A:  MOVWF  00
088C:  DECFSZ 00,F
088E:  BRA    088C
0890:  BCF    F89.1
0892:  BCF    F92.1
0894:  MOVLW  05
0896:  MOVWF  00
0898:  DECFSZ 00,F
089A:  BRA    0898
089C:  BCF    F89.0
089E:  BCF    F92.0
....................    i2c_write(0xa0); 
08A0:  MOVLW  A0
08A2:  MOVWF  33
08A4:  RCALL  07A8
....................    i2c_write(address>>8); 
08A6:  MOVFF  2F,31
08AA:  CLRF   32
08AC:  MOVFF  2F,33
08B0:  RCALL  07A8
....................    i2c_write(address); 
08B2:  MOVFF  2E,33
08B6:  RCALL  07A8
....................    i2c_start(); 
08B8:  BSF    F92.1
08BA:  MOVLW  05
08BC:  MOVWF  00
08BE:  DECFSZ 00,F
08C0:  BRA    08BE
08C2:  BSF    F92.0
08C4:  MOVLW  06
08C6:  MOVWF  00
08C8:  DECFSZ 00,F
08CA:  BRA    08C8
08CC:  BTFSS  F80.0
08CE:  BRA    08CC
08D0:  BCF    F89.1
08D2:  BCF    F92.1
08D4:  MOVLW  05
08D6:  MOVWF  00
08D8:  DECFSZ 00,F
08DA:  BRA    08D8
08DC:  BCF    F89.0
08DE:  BCF    F92.0
....................    i2c_write(0xa1); 
08E0:  MOVLW  A1
08E2:  MOVWF  33
08E4:  RCALL  07A8
....................    data=i2c_read(0); 
08E6:  CLRF   00
08E8:  BRA    0814
08EA:  MOVFF  01,30
....................    i2c_stop(); 
08EE:  BCF    F92.1
08F0:  NOP   
08F2:  BSF    F92.0
08F4:  BTFSS  F80.0
08F6:  BRA    08F4
08F8:  MOVLW  05
08FA:  MOVWF  00
08FC:  DECFSZ 00,F
08FE:  BRA    08FC
0900:  BRA    0902
0902:  NOP   
0904:  BSF    F92.1
0906:  MOVLW  05
0908:  MOVWF  00
090A:  DECFSZ 00,F
090C:  BRA    090A
....................    return(data); 
090E:  MOVFF  30,01
.................... } 
0912:  GOTO   093A (RETURN)
....................  
.................... #ROM     0xf00000={0x4523}     //colocar 0 para usuario 1, estan al reves primero esta los dos digitos ultimos y luego los otros 
.................... #ROM     0xf00002={0x5634}     //esto es asignacion de claves para los usuarios 
.................... #define SW PIN A5 
.................... //Vamos a nombrar los registros de proposito GRAL 
.................... int i, b, dato, clave[4], datoi[4], datoe[4], adres,  dato1, dato2; 
.................... char datom; 
.................... float valor; 
.................... short flag; 
.................... long segundos, auxsegundos; 
.................... //long contador; 
....................  
.................... /************************** 
.................... SECCION DE METODOS 
.................... ************************/ 
....................  
.................... void teclado() 
.................... {  
....................     lcd_putc('\f'); 
*
0B1C:  MOVLW  0C
0B1E:  MOVWF  2E
0B20:  RCALL  06F8
....................     segundos=0; 
0B22:  CLRF   29
0B24:  CLRF   28
....................     auxsegundos=0; 
0B26:  CLRF   2B
0B28:  CLRF   2A
....................     b=6; 
0B2A:  MOVLW  06
0B2C:  MOVWF  12
....................      for(i=0;i<4; i++) 
0B2E:  CLRF   11
0B30:  MOVF   11,W
0B32:  SUBLW  03
0B34:  BTFSS  FD8.0
0B36:  BRA    0D26
....................       { 
....................         do{ 
....................             datom=kbd_getc(); // escanea teclado 
0B38:  RCALL  0A04
0B3A:  MOVFF  01,23
....................             delay_ms(60); 
0B3E:  MOVLW  3C
0B40:  MOVWF  2F
0B42:  RCALL  0590
....................              if(datom!='\0')  //si hay dato valido 
0B44:  MOVF   23,F
0B46:  BTFSC  FD8.2
0B48:  BRA    0CCA
....................               { 
....................                  switch (i+1) 
....................                   { 
0B4A:  MOVLW  01
0B4C:  ADDWF  11,W
0B4E:  ADDLW  FF
0B50:  ADDLW  FC
0B52:  BTFSC  FD8.0
0B54:  BRA    0CB2
0B56:  ADDLW  04
0B58:  GOTO   0D28
....................                    case 1: 
....................                    lcd_gotoxy(6,1); 
0B5C:  MOVLW  06
0B5E:  MOVWF  2F
0B60:  MOVLW  01
0B62:  MOVWF  30
0B64:  RCALL  069C
....................                    printf(lcd_putc,datom); 
0B66:  CLRF   FEA
0B68:  MOVFF  23,FE9
0B6C:  MOVLW  00
0B6E:  IORWF  FEF,W
0B70:  BZ    0B90
0B72:  MOVFF  FEA,2D
0B76:  MOVFF  FE9,2C
0B7A:  MOVFF  FEF,2E
0B7E:  RCALL  06F8
0B80:  MOVFF  2D,FEA
0B84:  MOVFF  2C,FE9
0B88:  INCF   FE9,F
0B8A:  BTFSC  FD8.2
0B8C:  INCF   FEA,F
0B8E:  BRA    0B6C
....................                    clave[0]=datom-0X30; 
0B90:  MOVLW  30
0B92:  SUBWF  23,W
0B94:  MOVWF  14
....................                    swap(clave[0]); 
0B96:  SWAPF  14,F
....................                    lcd_gotoxy(6,2); 
0B98:  MOVLW  06
0B9A:  MOVWF  2F
0B9C:  MOVLW  02
0B9E:  MOVWF  30
0BA0:  RCALL  069C
....................                    printf(lcd_putc,"*"); 
0BA2:  MOVLW  2A
0BA4:  MOVWF  2E
0BA6:  RCALL  06F8
....................                    delay_ms(50); 
0BA8:  MOVLW  32
0BAA:  MOVWF  2F
0BAC:  RCALL  0590
....................                    break; 
0BAE:  BRA    0CB2
....................            
....................                    case 2: 
....................                    lcd_gotoxy(7,1); 
0BB0:  MOVLW  07
0BB2:  MOVWF  2F
0BB4:  MOVLW  01
0BB6:  MOVWF  30
0BB8:  RCALL  069C
....................                    printf(lcd_putc,datom); 
0BBA:  CLRF   FEA
0BBC:  MOVFF  23,FE9
0BC0:  MOVLW  00
0BC2:  IORWF  FEF,W
0BC4:  BZ    0BE4
0BC6:  MOVFF  FEA,2D
0BCA:  MOVFF  FE9,2C
0BCE:  MOVFF  FEF,2E
0BD2:  RCALL  06F8
0BD4:  MOVFF  2D,FEA
0BD8:  MOVFF  2C,FE9
0BDC:  INCF   FE9,F
0BDE:  BTFSC  FD8.2
0BE0:  INCF   FEA,F
0BE2:  BRA    0BC0
....................                    clave[1]=datom-0X30; 
0BE4:  MOVLW  30
0BE6:  SUBWF  23,W
0BE8:  MOVWF  15
....................                    clave[0]=clave[0]+clave[1]; 
0BEA:  MOVF   15,W
0BEC:  ADDWF  14,F
....................                    lcd_gotoxy(7,2); 
0BEE:  MOVLW  07
0BF0:  MOVWF  2F
0BF2:  MOVLW  02
0BF4:  MOVWF  30
0BF6:  RCALL  069C
....................                    printf(lcd_putc,"*"); 
0BF8:  MOVLW  2A
0BFA:  MOVWF  2E
0BFC:  RCALL  06F8
....................                    delay_ms(50); 
0BFE:  MOVLW  32
0C00:  MOVWF  2F
0C02:  RCALL  0590
....................                    break; 
0C04:  BRA    0CB2
....................               
....................                    case 3: 
....................                    lcd_gotoxy(8,1); 
0C06:  MOVLW  08
0C08:  MOVWF  2F
0C0A:  MOVLW  01
0C0C:  MOVWF  30
0C0E:  RCALL  069C
....................                    printf(lcd_putc,datom); 
0C10:  CLRF   FEA
0C12:  MOVFF  23,FE9
0C16:  MOVLW  00
0C18:  IORWF  FEF,W
0C1A:  BZ    0C3A
0C1C:  MOVFF  FEA,2D
0C20:  MOVFF  FE9,2C
0C24:  MOVFF  FEF,2E
0C28:  RCALL  06F8
0C2A:  MOVFF  2D,FEA
0C2E:  MOVFF  2C,FE9
0C32:  INCF   FE9,F
0C34:  BTFSC  FD8.2
0C36:  INCF   FEA,F
0C38:  BRA    0C16
....................                    clave[2]=datom-0X30; 
0C3A:  MOVLW  30
0C3C:  SUBWF  23,W
0C3E:  MOVWF  16
....................                    swap(clave[2]); 
0C40:  SWAPF  16,F
....................                    lcd_gotoxy(8,2); 
0C42:  MOVLW  08
0C44:  MOVWF  2F
0C46:  MOVLW  02
0C48:  MOVWF  30
0C4A:  RCALL  069C
....................                    printf(lcd_putc,"*"); 
0C4C:  MOVLW  2A
0C4E:  MOVWF  2E
0C50:  RCALL  06F8
....................                    delay_ms(50); 
0C52:  MOVLW  32
0C54:  MOVWF  2F
0C56:  RCALL  0590
....................                    break; 
0C58:  BRA    0CB2
....................               
....................                    case 4: 
....................                    lcd_gotoxy(9,1); 
0C5A:  MOVLW  09
0C5C:  MOVWF  2F
0C5E:  MOVLW  01
0C60:  MOVWF  30
0C62:  RCALL  069C
....................                    printf(lcd_putc,datom); 
0C64:  CLRF   FEA
0C66:  MOVFF  23,FE9
0C6A:  MOVLW  00
0C6C:  IORWF  FEF,W
0C6E:  BZ    0C8E
0C70:  MOVFF  FEA,2D
0C74:  MOVFF  FE9,2C
0C78:  MOVFF  FEF,2E
0C7C:  RCALL  06F8
0C7E:  MOVFF  2D,FEA
0C82:  MOVFF  2C,FE9
0C86:  INCF   FE9,F
0C88:  BTFSC  FD8.2
0C8A:  INCF   FEA,F
0C8C:  BRA    0C6A
....................                    clave[3]=datom-0X30; 
0C8E:  MOVLW  30
0C90:  SUBWF  23,W
0C92:  MOVWF  17
....................                    clave[1]=clave[2]+clave[3]; 
0C94:  MOVF   17,W
0C96:  ADDWF  16,W
0C98:  MOVWF  15
....................                    lcd_gotoxy(9,2); 
0C9A:  MOVLW  09
0C9C:  MOVWF  2F
0C9E:  MOVLW  02
0CA0:  MOVWF  30
0CA2:  RCALL  069C
....................                    printf(lcd_putc,"*"); 
0CA4:  MOVLW  2A
0CA6:  MOVWF  2E
0CA8:  RCALL  06F8
....................                    delay_ms(50); 
0CAA:  MOVLW  32
0CAC:  MOVWF  2F
0CAE:  RCALL  0590
....................                    break; 
0CB0:  BRA    0CB2
....................                  }  
....................                   i++; 
0CB2:  INCF   11,F
....................                   delay_ms(500); 
0CB4:  MOVLW  02
0CB6:  MOVWF  2C
0CB8:  MOVLW  FA
0CBA:  MOVWF  2F
0CBC:  RCALL  0590
0CBE:  DECFSZ 2C,F
0CC0:  BRA    0CB8
....................                   auxsegundos=0; 
0CC2:  CLRF   2B
0CC4:  CLRF   2A
....................                   segundos=0; 
0CC6:  CLRF   29
0CC8:  CLRF   28
....................            } 
....................            auxsegundos++; 
0CCA:  INCF   2A,F
0CCC:  BTFSC  FD8.2
0CCE:  INCF   2B,F
....................            if(auxsegundos > 20) 
0CD0:  MOVF   2B,F
0CD2:  BNZ   0CDA
0CD4:  MOVF   2A,W
0CD6:  SUBLW  14
0CD8:  BC    0CE4
....................             { 
....................               segundos++; 
0CDA:  INCF   28,F
0CDC:  BTFSC  FD8.2
0CDE:  INCF   29,F
....................               auxsegundos=0; 
0CE0:  CLRF   2B
0CE2:  CLRF   2A
....................             } 
....................          
....................       
....................     
....................     }while(i<4 && segundos<6); 
0CE4:  MOVF   11,W
0CE6:  SUBLW  03
0CE8:  BNC   0CF6
0CEA:  MOVF   29,F
0CEC:  BNZ   0CF6
0CEE:  MOVF   28,W
0CF0:  SUBLW  05
0CF2:  BTFSC  FD8.0
0CF4:  BRA    0B38
....................       clave[i]='#'; 
0CF6:  CLRF   03
0CF8:  MOVF   11,W
0CFA:  ADDLW  14
0CFC:  MOVWF  FE9
0CFE:  MOVLW  00
0D00:  ADDWFC 03,W
0D02:  MOVWF  FEA
0D04:  MOVLW  23
0D06:  MOVWF  FEF
....................       lcd_gotoxy(b,1); 
0D08:  MOVFF  12,2F
0D0C:  MOVLW  01
0D0E:  MOVWF  30
0D10:  RCALL  069C
....................       printf(lcd_putc,"*") ; 
0D12:  MOVLW  2A
0D14:  MOVWF  2E
0D16:  RCALL  06F8
....................       b++; 
0D18:  INCF   12,F
....................       auxsegundos=0; 
0D1A:  CLRF   2B
0D1C:  CLRF   2A
....................       segundos=0; 
0D1E:  CLRF   29
0D20:  CLRF   28
....................    } 
0D22:  INCF   11,F
0D24:  BRA    0B30
.................... } 
0D26:  RETLW  00
....................  
....................  
.................... void un_digito() 
.................... { lcd_putc('\f'); 
*
0D4A:  MOVLW  0C
0D4C:  MOVWF  2E
0D4E:  RCALL  06F8
....................   segundos=0; 
0D50:  CLRF   29
0D52:  CLRF   28
....................   auxsegundos=0; 
0D54:  CLRF   2B
0D56:  CLRF   2A
....................   flag=false; 
0D58:  BCF    0E.1
....................   do{ 
....................       datom=kbd_getc(); 
0D5A:  RCALL  0A04
0D5C:  MOVFF  01,23
....................       delay_ms(60); 
0D60:  MOVLW  3C
0D62:  MOVWF  2F
0D64:  RCALL  0590
....................       if(datom !='\0') 
0D66:  MOVF   23,F
0D68:  BZ    0D82
....................         { 
....................           lcd_gotoxy(8,1);  //coloque el numero digitado  en posicion del LCD 
0D6A:  MOVLW  08
0D6C:  MOVWF  2F
0D6E:  MOVLW  01
0D70:  MOVWF  30
0D72:  RCALL  069C
....................           lcd_putc(datom); //visualice datom 
0D74:  MOVFF  23,2E
0D78:  RCALL  06F8
....................           datom=datom-0x30; //quitele ASCII 
0D7A:  MOVLW  30
0D7C:  SUBWF  23,F
....................           flag=true; 
0D7E:  BSF    0E.1
....................            
....................         }else { 
0D80:  BRA    0D9C
....................                auxsegundos++; 
0D82:  INCF   2A,F
0D84:  BTFSC  FD8.2
0D86:  INCF   2B,F
....................                if(auxsegundos>20) 
0D88:  MOVF   2B,F
0D8A:  BNZ   0D92
0D8C:  MOVF   2A,W
0D8E:  SUBLW  14
0D90:  BC    0D9C
....................                { 
....................                  segundos++; 
0D92:  INCF   28,F
0D94:  BTFSC  FD8.2
0D96:  INCF   29,F
....................                  auxsegundos=0; 
0D98:  CLRF   2B
0D9A:  CLRF   2A
....................                 } 
....................        } 
....................          
....................   }while(segundos<6 && flag==false ); 
0D9C:  MOVF   29,F
0D9E:  BNZ   0DAA
0DA0:  MOVF   28,W
0DA2:  SUBLW  05
0DA4:  BNC   0DAA
0DA6:  BTFSS  0E.1
0DA8:  BRA    0D5A
.................... } 
0DAA:  RETLW  00
....................  
.................... void escribir_memoria() 
.................... { 
....................   for(i=0; i<2; i++) 
....................   {  write_eeprom(adres, clave[i]); 
....................      delay_ms(5); 
....................      adres++; 
....................   } 
.................... } 
....................  
.................... void escribir_memoria_ext() 
.................... { 
....................   for(i=0; i<2; i++) 
*
0EA0:  CLRF   11
0EA2:  MOVF   11,W
0EA4:  SUBLW  01
0EA6:  BNC   0ED4
....................   {  write_ext_eeprom(adres, clave[i]); 
0EA8:  CLRF   03
0EAA:  MOVF   11,W
0EAC:  ADDLW  14
0EAE:  MOVWF  FE9
0EB0:  MOVLW  00
0EB2:  ADDWFC 03,W
0EB4:  MOVWF  FEA
0EB6:  MOVFF  FEF,2C
0EBA:  CLRF   2E
0EBC:  MOVFF  20,2D
0EC0:  MOVFF  2C,2F
0EC4:  BRA    0DAC
....................      delay_ms(5); 
0EC6:  MOVLW  05
0EC8:  MOVWF  2F
0ECA:  CALL   0590
....................      adres++; 
0ECE:  INCF   20,F
....................   } 
0ED0:  INCF   11,F
0ED2:  BRA    0EA2
.................... } 
0ED4:  RETLW  00
....................  
....................  
.................... void leer() 
.................... { 
....................   for(i=0; i<4; i++) 
*
076C:  CLRF   11
076E:  MOVF   11,W
0770:  SUBLW  03
0772:  BNC   07A4
....................   { 
....................     datoi[i]=read_eeprom(i); 
0774:  CLRF   03
0776:  MOVF   11,W
0778:  ADDLW  18
077A:  MOVWF  FE9
077C:  MOVLW  00
077E:  ADDWFC 03,W
0780:  MOVWF  FEA
0782:  MOVFF  FF2,2E
0786:  BCF    FF2.7
0788:  MOVFF  11,FA9
078C:  BCF    FA6.6
078E:  BCF    FA6.7
0790:  BSF    FA6.0
0792:  MOVF   FA8,W
0794:  BTFSC  2E.7
0796:  BSF    FF2.7
0798:  MOVWF  FEF
....................     delay_ms(1); 
079A:  MOVLW  01
079C:  MOVWF  2F
079E:  RCALL  0590
....................   } 
07A0:  INCF   11,F
07A2:  BRA    076E
.................... } 
07A4:  GOTO   109C (RETURN)
....................  
....................  
.................... void leer_men_ext() 
.................... { 
....................   for(i=0; i<4; i++) 
*
0916:  CLRF   11
0918:  MOVF   11,W
091A:  SUBLW  03
091C:  BNC   0950
....................   { 
....................     datoe[i]=read_ext_eeprom(i); 
091E:  CLRF   03
0920:  MOVF   11,W
0922:  ADDLW  1C
0924:  MOVWF  01
0926:  MOVLW  00
0928:  ADDWFC 03,F
092A:  MOVFF  01,2C
092E:  MOVFF  03,2D
0932:  CLRF   2F
0934:  MOVFF  11,2E
0938:  BRA    087C
093A:  MOVFF  2D,FEA
093E:  MOVFF  2C,FE9
0942:  MOVFF  01,FEF
....................     delay_ms(1); 
0946:  MOVLW  01
0948:  MOVWF  2F
094A:  RCALL  0590
....................    } 
094C:  INCF   11,F
094E:  BRA    0918
.................... } 
0950:  GOTO   109E (RETURN)
....................  
....................  
....................    
.................... /************************** 
.................... PROGRAMA PRINCIPAL 
.................... ************************/   
....................  
.................... void main() 
.................... {#zero_ram 
*
0ED6:  CLRF   FF8
0ED8:  BCF    FD0.7
0EDA:  MOVLW  FE
0EDC:  MOVWF  00
0EDE:  MOVLW  08
0EE0:  MOVWF  01
0EE2:  MOVLW  02
0EE4:  MOVWF  FE9
0EE6:  MOVLW  00
0EE8:  MOVWF  FEA
0EEA:  CLRF   FEE
0EEC:  DECFSZ 00,F
0EEE:  BRA    0EEA
0EF0:  DECFSZ 01,F
0EF2:  BRA    0EEA
0EF4:  CLRF   FEA
0EF6:  CLRF   FE9
0EF8:  MOVF   FC1,W
0EFA:  ANDLW  C0
0EFC:  IORLW  0F
0EFE:  MOVWF  FC1
0F00:  MOVLW  07
0F02:  MOVWF  FB4
0F04:  CLRF   05
0F06:  CLRF   06
0F08:  CLRF   0D
0F0A:  BCF    0E.0
0F0C:  CLRF   0F
0F0E:  CLRF   10
.................... inicio:                       //etiquetas siempre a la izquierda 
....................     set_tris_A(0x28);         /*0010 1000 EL 28 SALE ES DIVIDIENDO LOS 8BITS EN 4 DIGITOS Y TOMAR A QUE NUMERO CORRESPONCEN 
0F10:  MOVLW  28
0F12:  MOVWF  F92
....................     RA0 PIN 2  FREE 
....................     RA1 PIN 3  FREE 
....................     RA2 PIN 4  FREE 
....................     RA3 PIN 5  FREE 
....................     RA4 PIN 6  FREE 
....................     RA5 PIN 7  FREE 
....................     RA6 PIN 14 FREE 
....................     RA7 NO EXISTE */ 
....................      
....................     set_tris_B(0x00); /*0000 0000 EL 28 SALE ES DIVIDIENDO LOS 8BITS EN 4 DIGITOS Y TOMAR A QUE NUMERO CORRESPONCEN 
0F14:  MOVLW  00
0F16:  MOVWF  F93
....................     RB0 PIN 33  LED1 
....................     RB1 PIN 34  LED2 
....................     RB2 PIN 35  LED4 
....................     RB3 PIN 36  LED5 
....................     RB4 PIN 37  LED6 
....................     RB5 PIN 38  LED7 
....................     RB6 PIN 39  LED8 
....................     RB7 PIN 40  LED8 */ 
....................      
....................     set_tris_D(0x00); /*0000 0000 EL 28 SALE ES DIVIDIENDO LOS 8BITS EN 4 DIGITOS Y TOMAR A QUE NUMERO CORRESPONCEN 
0F18:  MOVWF  F95
....................     RB0 PIN 33  LED1 
....................     RB1 PIN 34  LED2 
....................     RB2 PIN 35  LED4 
....................     RB3 PIN 36  LED5 
....................     RB4 PIN 37  LED6 
....................     RB5 PIN 38  LED7 
....................     RB6 PIN 39  LED8 
....................     RB7 PIN 40  LED8 */ 
....................      
....................     lcd_init(); 
0F1A:  GOTO   0638
....................     kbd_init(); 
0F1E:  GOTO   0698
....................     output_A(0x00);                            //Limpiar el puerto A 
0F22:  CLRF   F92
0F24:  CLRF   F89
....................     output_B(0x00);                           //Limipiar el puerto B 
0F26:  CLRF   F93
0F28:  CLRF   F8A
....................     output_D(0x00);                           //Limipiar el puerto D 
0F2A:  CLRF   F95
0F2C:  CLRF   F8C
....................     
.................... menu: 
....................    lcd_putc('\f');                            //Limpiar pantalla comando 
0F2E:  MOVLW  0C
0F30:  MOVWF  2E
0F32:  CALL   06F8
....................    lcd_gotoxy(1,1);                           //escribir en a primera fila primera posicion  
0F36:  MOVLW  01
0F38:  MOVWF  2F
0F3A:  MOVWF  30
0F3C:  CALL   069C
....................    lcd_putc("   BIENVENIDOS  ");              //lo que se escribe 
0F40:  CLRF   2C
0F42:  MOVF   2C,W
0F44:  CALL   0038
0F48:  IORLW  00
0F4A:  BZ    0F56
0F4C:  INCF   2C,F
0F4E:  MOVWF  2E
0F50:  CALL   06F8
0F54:  BRA    0F42
....................    lcd_gotoxy(1,2);                           //escribir en a primera fila primera posicion  
0F56:  MOVLW  01
0F58:  MOVWF  2F
0F5A:  MOVLW  02
0F5C:  MOVWF  30
0F5E:  CALL   069C
....................    lcd_putc("ARQ. COMP. TARDE"); 
0F62:  CLRF   2C
0F64:  MOVF   2C,W
0F66:  CALL   005A
0F6A:  IORLW  00
0F6C:  BZ    0F78
0F6E:  INCF   2C,F
0F70:  MOVWF  2E
0F72:  CALL   06F8
0F76:  BRA    0F64
....................    delay_ms(3000); 
0F78:  MOVLW  0C
0F7A:  MOVWF  2C
0F7C:  MOVLW  FA
0F7E:  MOVWF  2F
0F80:  CALL   0590
0F84:  DECFSZ 2C,F
0F86:  BRA    0F7C
....................     
....................    lcd_putc('\f');                            //Limpiar pantalla comando 
0F88:  MOVLW  0C
0F8A:  MOVWF  2E
0F8C:  CALL   06F8
....................    lcd_gotoxy(1,1);                           //escribir en a primera fila primera posicion  
0F90:  MOVLW  01
0F92:  MOVWF  2F
0F94:  MOVWF  30
0F96:  CALL   069C
....................    lcd_putc("MIGUEL MENDEZ");                 //lo que se escribe 
0F9A:  CLRF   2C
0F9C:  MOVF   2C,W
0F9E:  CALL   007C
0FA2:  IORLW  00
0FA4:  BZ    0FB0
0FA6:  INCF   2C,F
0FA8:  MOVWF  2E
0FAA:  CALL   06F8
0FAE:  BRA    0F9C
....................    lcd_gotoxy(1,2);                           //escribir en a primera fila primera posicion  
0FB0:  MOVLW  01
0FB2:  MOVWF  2F
0FB4:  MOVLW  02
0FB6:  MOVWF  30
0FB8:  CALL   069C
....................    lcd_putc(" DAVID MARTINEZ "); 
0FBC:  CLRF   2C
0FBE:  MOVF   2C,W
0FC0:  CALL   009A
0FC4:  IORLW  00
0FC6:  BZ    0FD2
0FC8:  INCF   2C,F
0FCA:  MOVWF  2E
0FCC:  CALL   06F8
0FD0:  BRA    0FBE
....................    //printf(lcd_putc,"\f   MIGUEL MENDEZ\n DAVID MARTINEZ ");// /n pase a sigueinet linea 
....................    delay_ms(3000); 
0FD2:  MOVLW  0C
0FD4:  MOVWF  2C
0FD6:  MOVLW  FA
0FD8:  MOVWF  2F
0FDA:  CALL   0590
0FDE:  DECFSZ 2C,F
0FE0:  BRA    0FD6
....................     
....................    lcd_putc('\f');                           //Limpiar pantalla comando 
0FE2:  MOVLW  0C
0FE4:  MOVWF  2E
0FE6:  CALL   06F8
....................    lcd_gotoxy(3,1);                          //escribir en a primera fila primera posicion  
0FEA:  MOVLW  03
0FEC:  MOVWF  2F
0FEE:  MOVLW  01
0FF0:  MOVWF  30
0FF2:  CALL   069C
....................    lcd_putc("GRUPO");                        //lo que se escribe 
0FF6:  CLRF   2C
0FF8:  MOVF   2C,W
0FFA:  CALL   00BC
0FFE:  IORLW  00
1000:  BZ    100C
1002:  INCF   2C,F
1004:  MOVWF  2E
1006:  CALL   06F8
100A:  BRA    0FF8
....................    lcd_gotoxy(2,2);                          //escribir en a primera fila primera posicion  
100C:  MOVLW  02
100E:  MOVWF  2F
1010:  MOVWF  30
1012:  CALL   069C
....................    lcd_putc(" NUMERO"); 
1016:  CLRF   2C
1018:  MOVF   2C,W
101A:  CALL   00D2
101E:  IORLW  00
1020:  BZ    102C
1022:  INCF   2C,F
1024:  MOVWF  2E
1026:  CALL   06F8
102A:  BRA    1018
....................    //printf(lcd_putc,"\f        GRUPO   \n       NUMERO    ");// /n pase a sigueinet linea 
....................    delay_ms(3000); 
102C:  MOVLW  0C
102E:  MOVWF  2C
1030:  MOVLW  FA
1032:  MOVWF  2F
1034:  CALL   0590
1038:  DECFSZ 2C,F
103A:  BRA    1030
....................     
....................    lcd_putc('\f');                          //Limpiar pantalla comando 
103C:  MOVLW  0C
103E:  MOVWF  2E
1040:  CALL   06F8
....................    lcd_gotoxy(2,1);                         //escribir en a primera fila primera posicion  
1044:  MOVLW  02
1046:  MOVWF  2F
1048:  MOVLW  01
104A:  MOVWF  30
104C:  CALL   069C
....................    lcd_putc("POR FAVOR");                   //lo que se escribe 
1050:  CLRF   2C
1052:  MOVF   2C,W
1054:  CALL   00EA
1058:  IORLW  00
105A:  BZ    1066
105C:  INCF   2C,F
105E:  MOVWF  2E
1060:  CALL   06F8
1064:  BRA    1052
....................    lcd_gotoxy(1,2);                         //escribir en a primera fila primera posicion  
1066:  MOVLW  01
1068:  MOVWF  2F
106A:  MOVLW  02
106C:  MOVWF  30
106E:  CALL   069C
....................    lcd_putc("INGRESE CLAVE"); 
1072:  CLRF   2C
1074:  MOVF   2C,W
1076:  CALL   0104
107A:  IORLW  00
107C:  BZ    1088
107E:  INCF   2C,F
1080:  MOVWF  2E
1082:  CALL   06F8
1086:  BRA    1074
....................    //printf(lcd_putc,"\f    POR FAVOR   \n INGRESE CLAVE");// /n pase a sigueinet linea 
....................    delay_ms(3000); 
1088:  MOVLW  0C
108A:  MOVWF  2C
108C:  MOVLW  FA
108E:  MOVWF  2F
1090:  CALL   0590
1094:  DECFSZ 2C,F
1096:  BRA    108C
....................     
....................     
....................     
....................    leer();                                    //datoi[0]= clave que le demos datoi[1]=clave que le demos 
1098:  GOTO   076C
....................    leer_men_ext(); 
109C:  BRA    0916
....................    teclado();                                 //clave [0]=0x34, clave[1]=0x78 
109E:  RCALL  0B1C
....................   if(clave[0]==0x12 & clave[1]==0x34) 
10A0:  MOVF   14,W
10A2:  SUBLW  12
10A4:  BZ    10AA
10A6:  MOVLW  00
10A8:  BRA    10AC
10AA:  MOVLW  01
10AC:  MOVWF  2C
10AE:  MOVF   15,W
10B0:  SUBLW  34
10B2:  BZ    10B8
10B4:  MOVLW  00
10B6:  BRA    10BA
10B8:  MOVLW  01
10BA:  ANDWF  2C,W
10BC:  BTFSC  FD8.2
10BE:  BRA    1282
....................    { 
.................... admin:  
....................       lcd_putc('\f');                          //Limpiar pantalla comando 
10C0:  MOVLW  0C
10C2:  MOVWF  2E
10C4:  CALL   06F8
....................       lcd_gotoxy(1,1);                         //escribir en a primera fila primera posicion  
10C8:  MOVLW  01
10CA:  MOVWF  2F
10CC:  MOVWF  30
10CE:  CALL   069C
....................       lcd_putc("BIENVENIDOS AL");              //lo que se escribe 
10D2:  CLRF   2C
10D4:  MOVF   2C,W
10D6:  CALL   0122
10DA:  IORLW  00
10DC:  BZ    10E8
10DE:  INCF   2C,F
10E0:  MOVWF  2E
10E2:  CALL   06F8
10E6:  BRA    10D4
....................       lcd_gotoxy(4,2);                         //escribir en a primera fila primera posicion  
10E8:  MOVLW  04
10EA:  MOVWF  2F
10EC:  MOVLW  02
10EE:  MOVWF  30
10F0:  CALL   069C
....................       lcd_putc(" MENU"); 
10F4:  CLRF   2C
10F6:  MOVF   2C,W
10F8:  CALL   0142
10FC:  IORLW  00
10FE:  BZ    110A
1100:  INCF   2C,F
1102:  MOVWF  2E
1104:  CALL   06F8
1108:  BRA    10F6
....................       //printf(lcd_putc,"\f    POR FAVOR   \n INGRESE CLAVE");// /n pase a sigueinet linea 
....................       delay_ms(3000); 
110A:  MOVLW  0C
110C:  MOVWF  2C
110E:  MOVLW  FA
1110:  MOVWF  2F
1112:  CALL   0590
1116:  DECFSZ 2C,F
1118:  BRA    110E
....................       
....................       lcd_putc('\f');                         //Limpiar pantalla comando 
111A:  MOVLW  0C
111C:  MOVWF  2E
111E:  CALL   06F8
....................       lcd_gotoxy(1,1);                        //escribir en a primera fila primera posicion  
1122:  MOVLW  01
1124:  MOVWF  2F
1126:  MOVWF  30
1128:  CALL   069C
....................       lcd_putc("MARQUE 1 PARA EL");           //lo que se escribe 
112C:  CLRF   2C
112E:  MOVF   2C,W
1130:  CALL   0158
1134:  IORLW  00
1136:  BZ    1142
1138:  INCF   2C,F
113A:  MOVWF  2E
113C:  CALL   06F8
1140:  BRA    112E
....................       lcd_gotoxy(1,2);                        //escribir en a primera fila primera posicion  
1142:  MOVLW  01
1144:  MOVWF  2F
1146:  MOVLW  02
1148:  MOVWF  30
114A:  CALL   069C
....................       lcd_putc("MENU DE DAVID"); 
114E:  CLRF   2C
1150:  MOVF   2C,W
1152:  CALL   017A
1156:  IORLW  00
1158:  BZ    1164
115A:  INCF   2C,F
115C:  MOVWF  2E
115E:  CALL   06F8
1162:  BRA    1150
....................       //printf(lcd_putc,"\f    POR FAVOR   \n INGRESE CLAVE");// /n pase a sigueinet linea 
....................       delay_ms(3000); 
1164:  MOVLW  0C
1166:  MOVWF  2C
1168:  MOVLW  FA
116A:  MOVWF  2F
116C:  CALL   0590
1170:  DECFSZ 2C,F
1172:  BRA    1168
....................     
....................       lcd_putc('\f');                         //Limpiar pantalla comando 
1174:  MOVLW  0C
1176:  MOVWF  2E
1178:  CALL   06F8
....................       lcd_gotoxy(1,1);                        //escribir en a primera fila primera posicion  
117C:  MOVLW  01
117E:  MOVWF  2F
1180:  MOVWF  30
1182:  CALL   069C
....................       lcd_putc("MARQUE 2 PARA EL");           //lo que se escribe 
1186:  CLRF   2C
1188:  MOVF   2C,W
118A:  CALL   0198
118E:  IORLW  00
1190:  BZ    119C
1192:  INCF   2C,F
1194:  MOVWF  2E
1196:  CALL   06F8
119A:  BRA    1188
....................       lcd_gotoxy(1,2);                        //escribir en a primera fila primera posicion  
119C:  MOVLW  01
119E:  MOVWF  2F
11A0:  MOVLW  02
11A2:  MOVWF  30
11A4:  CALL   069C
....................       lcd_putc("MENU DE MIGUEL"); 
11A8:  CLRF   2C
11AA:  MOVF   2C,W
11AC:  CALL   01BA
11B0:  IORLW  00
11B2:  BZ    11BE
11B4:  INCF   2C,F
11B6:  MOVWF  2E
11B8:  CALL   06F8
11BC:  BRA    11AA
....................       //printf(lcd_putc,"\f    POR FAVOR   \n INGRESE CLAVE");// /n pase a sigueinet linea 
....................       delay_ms(3000); 
11BE:  MOVLW  0C
11C0:  MOVWF  2C
11C2:  MOVLW  FA
11C4:  MOVWF  2F
11C6:  CALL   0590
11CA:  DECFSZ 2C,F
11CC:  BRA    11C2
....................      
....................       lcd_putc('\f');                         //Limpiar pantalla comando 
11CE:  MOVLW  0C
11D0:  MOVWF  2E
11D2:  CALL   06F8
....................       lcd_gotoxy(1,1);                        //escribir en a primera fila primera posicion  
11D6:  MOVLW  01
11D8:  MOVWF  2F
11DA:  MOVWF  30
11DC:  CALL   069C
....................       lcd_putc("MARQUE 3 PARA ");             //lo que se escribe 
11E0:  CLRF   2C
11E2:  MOVF   2C,W
11E4:  CALL   01DA
11E8:  IORLW  00
11EA:  BZ    11F6
11EC:  INCF   2C,F
11EE:  MOVWF  2E
11F0:  CALL   06F8
11F4:  BRA    11E2
....................       lcd_gotoxy(1,2);                        //escribir en a primera fila primera posicion  
11F6:  MOVLW  01
11F8:  MOVWF  2F
11FA:  MOVLW  02
11FC:  MOVWF  30
11FE:  CALL   069C
....................       lcd_putc("SALIR"); 
1202:  CLRF   2C
1204:  MOVF   2C,W
1206:  CALL   01FA
120A:  IORLW  00
120C:  BZ    1218
120E:  INCF   2C,F
1210:  MOVWF  2E
1212:  CALL   06F8
1216:  BRA    1204
....................       //printf(lcd_putc,"\f    POR FAVOR   \n INGRESE CLAVE");// /n pase a sigueinet linea 
....................       delay_ms(3000); 
1218:  MOVLW  0C
121A:  MOVWF  2C
121C:  MOVLW  FA
121E:  MOVWF  2F
1220:  CALL   0590
1224:  DECFSZ 2C,F
1226:  BRA    121C
....................     
....................     
....................        //bienvenidos al menu del diseador 
....................        //marque 1 para menu de MIGUEL 
....................        //marque 2 para menu de David 
....................        //marque 3 salir  */ 
....................         
....................         
....................      un_digito(); 
1228:  RCALL  0D4A
....................     if(datom==0x01) 
122A:  DECFSZ 23,W
122C:  BRA    1232
....................      { 
....................         goto David; 
122E:  GOTO   1972
....................      } 
....................      if(datom==0x02) 
1232:  MOVF   23,W
1234:  SUBLW  02
1236:  BNZ   123A
....................      { 
....................         goto Miguel; 
1238:  BRA    12A2
....................      } 
....................      if(datom==0x03) 
123A:  MOVF   23,W
123C:  SUBLW  03
123E:  BNZ   1242
....................      { 
....................         reset_cpu();  //salir 
1240:  RESET
....................      } 
....................      lcd_putc('\f');                        //Limpiar pantalla comando 
1242:  MOVLW  0C
1244:  MOVWF  2E
1246:  CALL   06F8
....................      lcd_gotoxy(1,2);                       //escribir en a primera fila primera posicion  
124A:  MOVLW  01
124C:  MOVWF  2F
124E:  MOVLW  02
1250:  MOVWF  30
1252:  CALL   069C
....................      lcd_putc("ERROR DE NUMERO");           //lo que se escribe 
1256:  CLRF   2C
1258:  MOVF   2C,W
125A:  CALL   0210
125E:  IORLW  00
1260:  BZ    126C
1262:  INCF   2C,F
1264:  MOVWF  2E
1266:  CALL   06F8
126A:  BRA    1258
....................      delay_ms(3000); 
126C:  MOVLW  0C
126E:  MOVWF  2C
1270:  MOVLW  FA
1272:  MOVWF  2F
1274:  CALL   0590
1278:  DECFSZ 2C,F
127A:  BRA    1270
....................      goto admin; 
127C:  BRA    10C0
....................      }  
....................      else if(clave[0]==datoe[1] & clave[1]==datoe[0]) 
127E:  GOTO   2060
1282:  MOVF   1D,W
1284:  SUBWF  14,W
1286:  BZ    128C
1288:  MOVLW  00
128A:  BRA    128E
128C:  MOVLW  01
128E:  MOVWF  2C
1290:  MOVF   1C,W
1292:  SUBWF  15,W
1294:  BZ    129A
1296:  MOVLW  00
1298:  BRA    129C
129A:  MOVLW  01
129C:  ANDWF  2C,W
129E:  BTFSC  FD8.2
12A0:  BRA    1952
....................       { 
.................... Miguel:adres=0x00; 
12A2:  CLRF   20
....................        /*escribirle al lcd 
....................        bienvenidos al menu del diseador 
....................        marque 1 para cambiar clave 
....................        marque 2 para fecha y hora 
....................        marque 3 para reportes 
....................        marque 4 para motor paso a paso 
....................        marque 5 para servomotor 
....................        marque 6 para cad 
....................        marque 7 para DTMF 
....................        marque 8 para sensores 
....................        marque 9 para salir*/ 
....................       
....................     lcd_putc('\f');                       //Limpiar pantalla comando 
12A4:  MOVLW  0C
12A6:  MOVWF  2E
12A8:  CALL   06F8
....................     lcd_gotoxy(1,1);                      //escribir en a primera fila primera posicion  
12AC:  MOVLW  01
12AE:  MOVWF  2F
12B0:  MOVWF  30
12B2:  CALL   069C
....................     lcd_putc("MENU USUAR.");              //lo que se escribe 
12B6:  CLRF   2C
12B8:  MOVF   2C,W
12BA:  CALL   0230
12BE:  IORLW  00
12C0:  BZ    12CC
12C2:  INCF   2C,F
12C4:  MOVWF  2E
12C6:  CALL   06F8
12CA:  BRA    12B8
....................     lcd_gotoxy(1,2);                      //escribir en a primera fila primera posicion  
12CC:  MOVLW  01
12CE:  MOVWF  2F
12D0:  MOVLW  02
12D2:  MOVWF  30
12D4:  CALL   069C
....................     lcd_putc("MIGUEL"); 
12D8:  CLRF   2C
12DA:  MOVF   2C,W
12DC:  CALL   024C
12E0:  IORLW  00
12E2:  BZ    12EE
12E4:  INCF   2C,F
12E6:  MOVWF  2E
12E8:  CALL   06F8
12EC:  BRA    12DA
....................     delay_ms(3000);  
12EE:  MOVLW  0C
12F0:  MOVWF  2C
12F2:  MOVLW  FA
12F4:  MOVWF  2F
12F6:  CALL   0590
12FA:  DECFSZ 2C,F
12FC:  BRA    12F2
....................         
....................     lcd_putc('\f');                       //Limpiar pantalla comando 
12FE:  MOVLW  0C
1300:  MOVWF  2E
1302:  CALL   06F8
....................     lcd_gotoxy(1,1);                      //escribir en a primera fila primera posicion  
1306:  MOVLW  01
1308:  MOVWF  2F
130A:  MOVWF  30
130C:  CALL   069C
....................     lcd_putc("MARQUE NUM PARA");          //lo que se escribe 
1310:  CLRF   2C
1312:  MOVF   2C,W
1314:  CALL   0264
1318:  IORLW  00
131A:  BZ    1326
131C:  INCF   2C,F
131E:  MOVWF  2E
1320:  CALL   06F8
1324:  BRA    1312
....................     lcd_gotoxy(1,2);                      //escribir en a primera fila primera posicion  
1326:  MOVLW  01
1328:  MOVWF  2F
132A:  MOVLW  02
132C:  MOVWF  30
132E:  CALL   069C
....................     lcd_putc("1 CAMBIAR CLAVE"); 
1332:  CLRF   2C
1334:  MOVF   2C,W
1336:  CALL   0284
133A:  IORLW  00
133C:  BZ    1348
133E:  INCF   2C,F
1340:  MOVWF  2E
1342:  CALL   06F8
1346:  BRA    1334
....................     delay_ms(3000);   
1348:  MOVLW  0C
134A:  MOVWF  2C
134C:  MOVLW  FA
134E:  MOVWF  2F
1350:  CALL   0590
1354:  DECFSZ 2C,F
1356:  BRA    134C
....................      
....................     lcd_putc('\f');                      //Limpiar pantalla comando 
1358:  MOVLW  0C
135A:  MOVWF  2E
135C:  CALL   06F8
....................     lcd_gotoxy(1,1);                     //escribir en a primera fila primera posicion  
1360:  MOVLW  01
1362:  MOVWF  2F
1364:  MOVWF  30
1366:  CALL   069C
....................     lcd_putc("2 FECHA Y HORA");          //lo que se escribe 
136A:  CLRF   2C
136C:  MOVF   2C,W
136E:  CALL   02A4
1372:  IORLW  00
1374:  BZ    1380
1376:  INCF   2C,F
1378:  MOVWF  2E
137A:  CALL   06F8
137E:  BRA    136C
....................     lcd_gotoxy(1,2);                     //escribir en a primera fila primera posicion  
1380:  MOVLW  01
1382:  MOVWF  2F
1384:  MOVLW  02
1386:  MOVWF  30
1388:  CALL   069C
....................     lcd_putc("3 REPORTES"); 
138C:  CLRF   2C
138E:  MOVF   2C,W
1390:  CALL   02C4
1394:  IORLW  00
1396:  BZ    13A2
1398:  INCF   2C,F
139A:  MOVWF  2E
139C:  CALL   06F8
13A0:  BRA    138E
....................     delay_ms(3000); 
13A2:  MOVLW  0C
13A4:  MOVWF  2C
13A6:  MOVLW  FA
13A8:  MOVWF  2F
13AA:  CALL   0590
13AE:  DECFSZ 2C,F
13B0:  BRA    13A6
....................      
....................     lcd_putc('\f');                      //Limpiar pantalla comando 
13B2:  MOVLW  0C
13B4:  MOVWF  2E
13B6:  CALL   06F8
....................     lcd_gotoxy(1,1);                     //escribir en a primera fila primera posicion  
13BA:  MOVLW  01
13BC:  MOVWF  2F
13BE:  MOVWF  30
13C0:  CALL   069C
....................     lcd_putc("4 MOTOR PAS A PA");        //lo que se escribe 
13C4:  CLRF   2C
13C6:  MOVF   2C,W
13C8:  CALL   02E0
13CC:  IORLW  00
13CE:  BZ    13DA
13D0:  INCF   2C,F
13D2:  MOVWF  2E
13D4:  CALL   06F8
13D8:  BRA    13C6
....................     lcd_gotoxy(1,2);                     //escribir en a primera fila primera posicion  
13DA:  MOVLW  01
13DC:  MOVWF  2F
13DE:  MOVLW  02
13E0:  MOVWF  30
13E2:  CALL   069C
....................     lcd_putc("5 SERVOMOTOR"); 
13E6:  CLRF   2C
13E8:  MOVF   2C,W
13EA:  CALL   0302
13EE:  IORLW  00
13F0:  BZ    13FC
13F2:  INCF   2C,F
13F4:  MOVWF  2E
13F6:  CALL   06F8
13FA:  BRA    13E8
....................     delay_ms(3000); 
13FC:  MOVLW  0C
13FE:  MOVWF  2C
1400:  MOVLW  FA
1402:  MOVWF  2F
1404:  CALL   0590
1408:  DECFSZ 2C,F
140A:  BRA    1400
....................      
....................     lcd_putc('\f');                      //Limpiar pantalla comando 
140C:  MOVLW  0C
140E:  MOVWF  2E
1410:  CALL   06F8
....................     lcd_gotoxy(1,1);                     //escribir en a primera fila primera posicion  
1414:  MOVLW  01
1416:  MOVWF  2F
1418:  MOVWF  30
141A:  CALL   069C
....................     lcd_putc("6 CAD");                   //lo que se escribe 
141E:  CLRF   2C
1420:  MOVF   2C,W
1422:  CALL   0320
1426:  IORLW  00
1428:  BZ    1434
142A:  INCF   2C,F
142C:  MOVWF  2E
142E:  CALL   06F8
1432:  BRA    1420
....................     lcd_gotoxy(1,2);                     //escribir en a primera fila primera posicion  
1434:  MOVLW  01
1436:  MOVWF  2F
1438:  MOVLW  02
143A:  MOVWF  30
143C:  CALL   069C
....................     lcd_putc("7 DTMF"); 
1440:  CLRF   2C
1442:  MOVF   2C,W
1444:  CALL   0336
1448:  IORLW  00
144A:  BZ    1456
144C:  INCF   2C,F
144E:  MOVWF  2E
1450:  CALL   06F8
1454:  BRA    1442
....................     delay_ms(3000); 
1456:  MOVLW  0C
1458:  MOVWF  2C
145A:  MOVLW  FA
145C:  MOVWF  2F
145E:  CALL   0590
1462:  DECFSZ 2C,F
1464:  BRA    145A
....................      
....................     lcd_putc('\f');                      //Limpiar pantalla comando 
1466:  MOVLW  0C
1468:  MOVWF  2E
146A:  CALL   06F8
....................     lcd_gotoxy(1,1);                     //escribir en a primera fila primera posicion  
146E:  MOVLW  01
1470:  MOVWF  2F
1472:  MOVWF  30
1474:  CALL   069C
....................     lcd_putc("8 SENSORES");              //lo que se escribe 
1478:  CLRF   2C
147A:  MOVF   2C,W
147C:  CALL   034E
1480:  IORLW  00
1482:  BZ    148E
1484:  INCF   2C,F
1486:  MOVWF  2E
1488:  CALL   06F8
148C:  BRA    147A
....................     lcd_gotoxy(3,2);                     //escribir en a primera fila primera posicion  
148E:  MOVLW  03
1490:  MOVWF  2F
1492:  MOVLW  02
1494:  MOVWF  30
1496:  CALL   069C
....................     lcd_putc("9 SALIR"); 
149A:  CLRF   2C
149C:  MOVF   2C,W
149E:  CALL   036A
14A2:  IORLW  00
14A4:  BZ    14B0
14A6:  INCF   2C,F
14A8:  MOVWF  2E
14AA:  CALL   06F8
14AE:  BRA    149C
....................     delay_ms(3000); 
14B0:  MOVLW  0C
14B2:  MOVWF  2C
14B4:  MOVLW  FA
14B6:  MOVWF  2F
14B8:  CALL   0590
14BC:  DECFSZ 2C,F
14BE:  BRA    14B4
....................      
....................     un_digito(); 
14C0:  RCALL  0D4A
....................     if(datom==0x01) 
14C2:  DECFSZ 23,W
14C4:  BRA    1644
....................      { 
....................         lcd_putc('\f');                   //Limpiar pantalla comando 
14C6:  MOVLW  0C
14C8:  MOVWF  2E
14CA:  CALL   06F8
....................         lcd_gotoxy(1,1);                  //escribir en a primera fila primera posicion  
14CE:  MOVLW  01
14D0:  MOVWF  2F
14D2:  MOVWF  30
14D4:  CALL   069C
....................         lcd_putc("MEN CAMBIAR CLAV");     //lo que se escribe 
14D8:  CLRF   2C
14DA:  MOVF   2C,W
14DC:  CALL   0382
14E0:  IORLW  00
14E2:  BZ    14EE
14E4:  INCF   2C,F
14E6:  MOVWF  2E
14E8:  CALL   06F8
14EC:  BRA    14DA
....................         lcd_gotoxy(3,2);                  //escribir en a primera fila primera posicion  
14EE:  MOVLW  03
14F0:  MOVWF  2F
14F2:  MOVLW  02
14F4:  MOVWF  30
14F6:  CALL   069C
....................         lcd_putc("DIGITE NU. CLAVE");     //clave[0]= y clave[1]= 
14FA:  CLRF   2C
14FC:  MOVF   2C,W
14FE:  CALL   03A4
1502:  IORLW  00
1504:  BZ    1510
1506:  INCF   2C,F
1508:  MOVWF  2E
150A:  CALL   06F8
150E:  BRA    14FC
....................         delay_ms(3000); 
1510:  MOVLW  0C
1512:  MOVWF  2C
1514:  MOVLW  FA
1516:  MOVWF  2F
1518:  CALL   0590
151C:  DECFSZ 2C,F
151E:  BRA    1514
....................         teclado(); 
1520:  CALL   0B1C
....................         
....................         dato1=clave[0]; 
1524:  MOVFF  14,21
....................         dato2=clave[1]; 
1528:  MOVFF  15,22
....................         
....................         lcd_putc('\f');                   //Limpiar pantalla comando 
152C:  MOVLW  0C
152E:  MOVWF  2E
1530:  CALL   06F8
....................         lcd_gotoxy(1,1);                  //escribir en a primera fila primera posicion  
1534:  MOVLW  01
1536:  MOVWF  2F
1538:  MOVWF  30
153A:  CALL   069C
....................         lcd_putc("POR FAVOR DIGITE");     //lo que se escribe 
153E:  CLRF   2C
1540:  MOVF   2C,W
1542:  CALL   03C6
1546:  IORLW  00
1548:  BZ    1554
154A:  INCF   2C,F
154C:  MOVWF  2E
154E:  CALL   06F8
1552:  BRA    1540
....................         lcd_gotoxy(1,2);                  //escribir en a primera fila primera posicion  
1554:  MOVLW  01
1556:  MOVWF  2F
1558:  MOVLW  02
155A:  MOVWF  30
155C:  CALL   069C
....................         lcd_putc("DIGITE NUE.CLAVE");    
1560:  CLRF   2C
1562:  MOVF   2C,W
1564:  CALL   03E8
1568:  IORLW  00
156A:  BZ    1576
156C:  INCF   2C,F
156E:  MOVWF  2E
1570:  CALL   06F8
1574:  BRA    1562
....................         delay_ms(3000); 
1576:  MOVLW  0C
1578:  MOVWF  2C
157A:  MOVLW  FA
157C:  MOVWF  2F
157E:  CALL   0590
1582:  DECFSZ 2C,F
1584:  BRA    157A
....................         
....................         teclado(); 
1586:  CALL   0B1C
....................         
....................        if(clave[0]==dato1 & clave[1]==dato2) 
158A:  MOVF   21,W
158C:  SUBWF  14,W
158E:  BZ    1594
1590:  MOVLW  00
1592:  BRA    1596
1594:  MOVLW  01
1596:  MOVWF  2C
1598:  MOVF   22,W
159A:  SUBWF  15,W
159C:  BZ    15A2
159E:  MOVLW  00
15A0:  BRA    15A4
15A2:  MOVLW  01
15A4:  ANDWF  2C,W
15A6:  BZ    1608
....................        { 
....................         escribir_memoria_ext(); 
15A8:  RCALL  0EA0
....................          lcd_putc('\f');                   //Limpiar pantalla comando 
15AA:  MOVLW  0C
15AC:  MOVWF  2E
15AE:  CALL   06F8
....................          lcd_gotoxy(1,1);                  //escribir en a primera fila primera posicion  
15B2:  MOVLW  01
15B4:  MOVWF  2F
15B6:  MOVWF  30
15B8:  CALL   069C
....................          lcd_putc("CLAVE MODIFICADA");     //lo que se escribe 
15BC:  CLRF   2C
15BE:  MOVF   2C,W
15C0:  CALL   040A
15C4:  IORLW  00
15C6:  BZ    15D2
15C8:  INCF   2C,F
15CA:  MOVWF  2E
15CC:  CALL   06F8
15D0:  BRA    15BE
....................          lcd_gotoxy(3,2);                  //escribir en a primera fila primera posicion  
15D2:  MOVLW  03
15D4:  MOVWF  2F
15D6:  MOVLW  02
15D8:  MOVWF  30
15DA:  CALL   069C
....................          lcd_putc("CON EXITO");    
15DE:  CLRF   2C
15E0:  MOVF   2C,W
15E2:  CALL   042C
15E6:  IORLW  00
15E8:  BZ    15F4
15EA:  INCF   2C,F
15EC:  MOVWF  2E
15EE:  CALL   06F8
15F2:  BRA    15E0
....................          delay_ms(3000); 
15F4:  MOVLW  0C
15F6:  MOVWF  2C
15F8:  MOVLW  FA
15FA:  MOVWF  2F
15FC:  CALL   0590
1600:  DECFSZ 2C,F
1602:  BRA    15F8
....................          goto Miguel; 
1604:  BRA    12A2
....................        } 
....................        else{ 
1606:  BRA    1642
....................             lcd_putc('\f');                   //Limpiar pantalla comando 
1608:  MOVLW  0C
160A:  MOVWF  2E
160C:  CALL   06F8
....................             lcd_gotoxy(1,1);                  //escribir en a primera fila primera posicion  
1610:  MOVLW  01
1612:  MOVWF  2F
1614:  MOVWF  30
1616:  CALL   069C
....................             lcd_putc("ERROR DE CLAVE");     //lo que se escribe 
161A:  CLRF   2C
161C:  MOVF   2C,W
161E:  CALL   0446
1622:  IORLW  00
1624:  BZ    1630
1626:  INCF   2C,F
1628:  MOVWF  2E
162A:  CALL   06F8
162E:  BRA    161C
....................             delay_ms(3000); 
1630:  MOVLW  0C
1632:  MOVWF  2C
1634:  MOVLW  FA
1636:  MOVWF  2F
1638:  CALL   0590
163C:  DECFSZ 2C,F
163E:  BRA    1634
....................             goto Miguel; 
1640:  BRA    12A2
....................             } 
....................        
....................        
....................      } 
....................      else if(datom==0x02) 
1642:  BRA    194E
1644:  MOVF   23,W
1646:  SUBLW  02
1648:  BNZ   16A8
....................      { 
....................        lcd_putc('\f');                  //Limpiar pantalla comando 
164A:  MOVLW  0C
164C:  MOVWF  2E
164E:  CALL   06F8
....................        lcd_gotoxy(1,1);                 //escribir en a primera fila primera posicion  
1652:  MOVLW  01
1654:  MOVWF  2F
1656:  MOVWF  30
1658:  CALL   069C
....................        lcd_putc("MEN FECHA Y HORA");    //lo que se escribe 
165C:  CLRF   2C
165E:  MOVF   2C,W
1660:  CALL   0466
1664:  IORLW  00
1666:  BZ    1672
1668:  INCF   2C,F
166A:  MOVWF  2E
166C:  CALL   06F8
1670:  BRA    165E
....................        lcd_gotoxy(3,2);                 //escribir en a primera fila primera posicion  
1672:  MOVLW  03
1674:  MOVWF  2F
1676:  MOVLW  02
1678:  MOVWF  30
167A:  CALL   069C
....................        lcd_putc("EN CONSTRUCCION"); 
167E:  CLRF   2C
1680:  MOVF   2C,W
1682:  CALL   0488
1686:  IORLW  00
1688:  BZ    1694
168A:  INCF   2C,F
168C:  MOVWF  2E
168E:  CALL   06F8
1692:  BRA    1680
....................        delay_ms(3000); 
1694:  MOVLW  0C
1696:  MOVWF  2C
1698:  MOVLW  FA
169A:  MOVWF  2F
169C:  CALL   0590
16A0:  DECFSZ 2C,F
16A2:  BRA    1698
....................        goto Miguel; 
16A4:  BRA    12A2
....................      } 
....................      else if(datom==0x03) 
16A6:  BRA    194E
16A8:  MOVF   23,W
16AA:  SUBLW  03
16AC:  BNZ   170C
....................      { 
....................        lcd_putc('\f');                //Limpiar pantalla comando 
16AE:  MOVLW  0C
16B0:  MOVWF  2E
16B2:  CALL   06F8
....................        lcd_gotoxy(1,1);               //escribir en a primera fila primera posicion  
16B6:  MOVLW  01
16B8:  MOVWF  2F
16BA:  MOVWF  30
16BC:  CALL   069C
....................        lcd_putc("MENU REPORTES");     //lo que se escribe 
16C0:  CLRF   2C
16C2:  MOVF   2C,W
16C4:  CALL   04A8
16C8:  IORLW  00
16CA:  BZ    16D6
16CC:  INCF   2C,F
16CE:  MOVWF  2E
16D0:  CALL   06F8
16D4:  BRA    16C2
....................        lcd_gotoxy(3,2);               //escribir en a primera fila primera posicion  
16D6:  MOVLW  03
16D8:  MOVWF  2F
16DA:  MOVLW  02
16DC:  MOVWF  30
16DE:  CALL   069C
....................        lcd_putc("EN CONSTRUCCION"); 
16E2:  CLRF   2C
16E4:  MOVF   2C,W
16E6:  CALL   0488
16EA:  IORLW  00
16EC:  BZ    16F8
16EE:  INCF   2C,F
16F0:  MOVWF  2E
16F2:  CALL   06F8
16F6:  BRA    16E4
....................        delay_ms(3000); 
16F8:  MOVLW  0C
16FA:  MOVWF  2C
16FC:  MOVLW  FA
16FE:  MOVWF  2F
1700:  CALL   0590
1704:  DECFSZ 2C,F
1706:  BRA    16FC
....................        goto Miguel; 
1708:  BRA    12A2
....................      } 
....................      else if(datom==0x04) 
170A:  BRA    194E
170C:  MOVF   23,W
170E:  SUBLW  04
1710:  BNZ   1770
....................      { 
....................        lcd_putc('\f');               //Limpiar pantalla comando 
1712:  MOVLW  0C
1714:  MOVWF  2E
1716:  CALL   06F8
....................        lcd_gotoxy(1,1);              //escribir en a primera fila primera posicion  
171A:  MOVLW  01
171C:  MOVWF  2F
171E:  MOVWF  30
1720:  CALL   069C
....................        lcd_putc("MEN MOTOR PAS A."); //lo que se escribe 
1724:  CLRF   2C
1726:  MOVF   2C,W
1728:  CALL   04C6
172C:  IORLW  00
172E:  BZ    173A
1730:  INCF   2C,F
1732:  MOVWF  2E
1734:  CALL   06F8
1738:  BRA    1726
....................        lcd_gotoxy(3,2);              //escribir en a primera fila primera posicion  
173A:  MOVLW  03
173C:  MOVWF  2F
173E:  MOVLW  02
1740:  MOVWF  30
1742:  CALL   069C
....................        lcd_putc("EN CONSTRUCCION"); 
1746:  CLRF   2C
1748:  MOVF   2C,W
174A:  CALL   0488
174E:  IORLW  00
1750:  BZ    175C
1752:  INCF   2C,F
1754:  MOVWF  2E
1756:  CALL   06F8
175A:  BRA    1748
....................        delay_ms(3000); 
175C:  MOVLW  0C
175E:  MOVWF  2C
1760:  MOVLW  FA
1762:  MOVWF  2F
1764:  CALL   0590
1768:  DECFSZ 2C,F
176A:  BRA    1760
....................        goto Miguel; 
176C:  BRA    12A2
....................      } 
....................      else if(datom==0x05) 
176E:  BRA    194E
1770:  MOVF   23,W
1772:  SUBLW  05
1774:  BNZ   17D4
....................      { 
....................        lcd_putc('\f');              //Limpiar pantalla comando 
1776:  MOVLW  0C
1778:  MOVWF  2E
177A:  CALL   06F8
....................        lcd_gotoxy(1,1);             //escribir en a primera fila primera posicion  
177E:  MOVLW  01
1780:  MOVWF  2F
1782:  MOVWF  30
1784:  CALL   069C
....................        lcd_putc("MEN SERVOMOTOR");  //lo que se escribe 
1788:  CLRF   2C
178A:  MOVF   2C,W
178C:  CALL   04E8
1790:  IORLW  00
1792:  BZ    179E
1794:  INCF   2C,F
1796:  MOVWF  2E
1798:  CALL   06F8
179C:  BRA    178A
....................        lcd_gotoxy(3,2);             //escribir en a primera fila primera posicion  
179E:  MOVLW  03
17A0:  MOVWF  2F
17A2:  MOVLW  02
17A4:  MOVWF  30
17A6:  CALL   069C
....................        lcd_putc("EN CONSTRUCCION"); 
17AA:  CLRF   2C
17AC:  MOVF   2C,W
17AE:  CALL   0488
17B2:  IORLW  00
17B4:  BZ    17C0
17B6:  INCF   2C,F
17B8:  MOVWF  2E
17BA:  CALL   06F8
17BE:  BRA    17AC
....................        delay_ms(3000); 
17C0:  MOVLW  0C
17C2:  MOVWF  2C
17C4:  MOVLW  FA
17C6:  MOVWF  2F
17C8:  CALL   0590
17CC:  DECFSZ 2C,F
17CE:  BRA    17C4
....................        goto Miguel; 
17D0:  BRA    12A2
....................      } 
....................      else if(datom==0x06) 
17D2:  BRA    194E
17D4:  MOVF   23,W
17D6:  SUBLW  06
17D8:  BNZ   1838
....................      { 
....................        lcd_putc('\f');               //Limpiar pantalla comando 
17DA:  MOVLW  0C
17DC:  MOVWF  2E
17DE:  CALL   06F8
....................        lcd_gotoxy(1,1);              //escribir en a primera fila primera posicion  
17E2:  MOVLW  01
17E4:  MOVWF  2F
17E6:  MOVWF  30
17E8:  CALL   069C
....................        lcd_putc("MENU CAD");         //lo que se escribe 
17EC:  CLRF   2C
17EE:  MOVF   2C,W
17F0:  CALL   0508
17F4:  IORLW  00
17F6:  BZ    1802
17F8:  INCF   2C,F
17FA:  MOVWF  2E
17FC:  CALL   06F8
1800:  BRA    17EE
....................        lcd_gotoxy(3,2);              //escribir en a primera fila primera posicion  
1802:  MOVLW  03
1804:  MOVWF  2F
1806:  MOVLW  02
1808:  MOVWF  30
180A:  CALL   069C
....................        lcd_putc("EN CONSTRUCCION"); 
180E:  CLRF   2C
1810:  MOVF   2C,W
1812:  CALL   0488
1816:  IORLW  00
1818:  BZ    1824
181A:  INCF   2C,F
181C:  MOVWF  2E
181E:  CALL   06F8
1822:  BRA    1810
....................        delay_ms(3000); 
1824:  MOVLW  0C
1826:  MOVWF  2C
1828:  MOVLW  FA
182A:  MOVWF  2F
182C:  CALL   0590
1830:  DECFSZ 2C,F
1832:  BRA    1828
....................        goto Miguel; 
1834:  BRA    12A2
....................      } 
....................      else if(datom==0x07) 
1836:  BRA    194E
1838:  MOVF   23,W
183A:  SUBLW  07
183C:  BNZ   189C
....................      { 
....................        lcd_putc('\f');               //Limpiar pantalla comando 
183E:  MOVLW  0C
1840:  MOVWF  2E
1842:  CALL   06F8
....................        lcd_gotoxy(1,1);              //escribir en a primera fila primera posicion  
1846:  MOVLW  01
1848:  MOVWF  2F
184A:  MOVWF  30
184C:  CALL   069C
....................        lcd_putc("MEN DTMF");         //lo que se escribe 
1850:  CLRF   2C
1852:  MOVF   2C,W
1854:  CALL   0522
1858:  IORLW  00
185A:  BZ    1866
185C:  INCF   2C,F
185E:  MOVWF  2E
1860:  CALL   06F8
1864:  BRA    1852
....................        lcd_gotoxy(3,2);              //escribir en a primera fila primera posicion  
1866:  MOVLW  03
1868:  MOVWF  2F
186A:  MOVLW  02
186C:  MOVWF  30
186E:  CALL   069C
....................        lcd_putc("EN CONSTRUCCION"); 
1872:  CLRF   2C
1874:  MOVF   2C,W
1876:  CALL   0488
187A:  IORLW  00
187C:  BZ    1888
187E:  INCF   2C,F
1880:  MOVWF  2E
1882:  CALL   06F8
1886:  BRA    1874
....................        delay_ms(3000); 
1888:  MOVLW  0C
188A:  MOVWF  2C
188C:  MOVLW  FA
188E:  MOVWF  2F
1890:  CALL   0590
1894:  DECFSZ 2C,F
1896:  BRA    188C
....................       goto Miguel; 
1898:  BRA    12A2
....................      } 
....................      else if(datom==0x08) 
189A:  BRA    194E
189C:  MOVF   23,W
189E:  SUBLW  08
18A0:  BNZ   1900
....................      { 
....................        lcd_putc('\f');              //Limpiar pantalla comando 
18A2:  MOVLW  0C
18A4:  MOVWF  2E
18A6:  CALL   06F8
....................        lcd_gotoxy(1,1);             //escribir en a primera fila primera posicion  
18AA:  MOVLW  01
18AC:  MOVWF  2F
18AE:  MOVWF  30
18B0:  CALL   069C
....................        lcd_putc("MEN SENSORES");    //lo que se escribe 
18B4:  CLRF   2C
18B6:  MOVF   2C,W
18B8:  CALL   053C
18BC:  IORLW  00
18BE:  BZ    18CA
18C0:  INCF   2C,F
18C2:  MOVWF  2E
18C4:  CALL   06F8
18C8:  BRA    18B6
....................        lcd_gotoxy(3,2);             //escribir en a primera fila primera posicion  
18CA:  MOVLW  03
18CC:  MOVWF  2F
18CE:  MOVLW  02
18D0:  MOVWF  30
18D2:  CALL   069C
....................        lcd_putc("EN CONSTRUCCION"); 
18D6:  CLRF   2C
18D8:  MOVF   2C,W
18DA:  CALL   0488
18DE:  IORLW  00
18E0:  BZ    18EC
18E2:  INCF   2C,F
18E4:  MOVWF  2E
18E6:  CALL   06F8
18EA:  BRA    18D8
....................        delay_ms(3000); 
18EC:  MOVLW  0C
18EE:  MOVWF  2C
18F0:  MOVLW  FA
18F2:  MOVWF  2F
18F4:  CALL   0590
18F8:  DECFSZ 2C,F
18FA:  BRA    18F0
....................        goto Miguel; 
18FC:  BRA    12A2
....................      } 
....................      else if(datom==0x09) 
18FE:  BRA    194E
1900:  MOVF   23,W
1902:  SUBLW  09
1904:  BNZ   190C
....................      { 
....................       goto admin; 
1906:  GOTO   10C0
....................      } 
....................      else{ 
190A:  BRA    194E
....................           lcd_putc('\f');                 //Limpiar pantalla comando 
190C:  MOVLW  0C
190E:  MOVWF  2E
1910:  CALL   06F8
....................           lcd_gotoxy(1,2);                //escribir en a primera fila primera posicion  
1914:  MOVLW  01
1916:  MOVWF  2F
1918:  MOVLW  02
191A:  MOVWF  30
191C:  CALL   069C
....................           lcd_putc("ERROR DE NUMERO");   //lo que se escribe 
1920:  CLRF   2C
1922:  MOVF   2C,W
1924:  CALL   0210
1928:  IORLW  00
192A:  BZ    1936
192C:  INCF   2C,F
192E:  MOVWF  2E
1930:  CALL   06F8
1934:  BRA    1922
....................           delay_ms(3000); 
1936:  MOVLW  0C
1938:  MOVWF  2C
193A:  MOVLW  FA
193C:  MOVWF  2F
193E:  CALL   0590
1942:  DECFSZ 2C,F
1944:  BRA    193A
....................           goto menu; 
1946:  GOTO   0F2E
....................      goto admin; 
194A:  GOTO   10C0
....................      } 
....................      } 
....................    
....................     else if(clave[0]==datoe[2] & clave[1]==datoe[3]) 
194E:  GOTO   2060
1952:  MOVF   1E,W
1954:  SUBWF  14,W
1956:  BZ    195C
1958:  MOVLW  00
195A:  BRA    195E
195C:  MOVLW  01
195E:  MOVWF  2C
1960:  MOVF   1F,W
1962:  SUBWF  15,W
1964:  BZ    196A
1966:  MOVLW  00
1968:  BRA    196C
196A:  MOVLW  01
196C:  ANDWF  2C,W
196E:  BTFSC  FD8.2
1970:  BRA    2022
....................     { 
.................... David:adres=0x02; 
1972:  MOVLW  02
1974:  MOVWF  20
....................        /*escribirle al lcd 
....................        bienvenidos al menu del diseador 
....................        marque 1 para cambiar clave 
....................        marque 2 para fecha y hora 
....................        marque 3 para reportes 
....................        marque 4 para motor paso a paso 
....................        marque 5 para servomotor 
....................        marque 6 para cad 
....................        marque 7 para DTMF 
....................        marque 8 para sensores 
....................        marque 9 para salir*/ 
....................       
....................     lcd_putc('\f');                       //Limpiar pantalla comando 
1976:  MOVLW  0C
1978:  MOVWF  2E
197A:  CALL   06F8
....................     lcd_gotoxy(1,1);                      //escribir en a primera fila primera posicion  
197E:  MOVLW  01
1980:  MOVWF  2F
1982:  MOVWF  30
1984:  CALL   069C
....................     lcd_putc("MENU USUAR.");              //lo que se escribe 
1988:  CLRF   2C
198A:  MOVF   2C,W
198C:  CALL   0230
1990:  IORLW  00
1992:  BZ    199E
1994:  INCF   2C,F
1996:  MOVWF  2E
1998:  CALL   06F8
199C:  BRA    198A
....................     lcd_gotoxy(4,2);                      //escribir en a primera fila primera posicion  
199E:  MOVLW  04
19A0:  MOVWF  2F
19A2:  MOVLW  02
19A4:  MOVWF  30
19A6:  CALL   069C
....................     lcd_putc("DAVID"); 
19AA:  CLRF   2C
19AC:  MOVF   2C,W
19AE:  CALL   055A
19B2:  IORLW  00
19B4:  BZ    19C0
19B6:  INCF   2C,F
19B8:  MOVWF  2E
19BA:  CALL   06F8
19BE:  BRA    19AC
....................     delay_ms(3000);  
19C0:  MOVLW  0C
19C2:  MOVWF  2C
19C4:  MOVLW  FA
19C6:  MOVWF  2F
19C8:  CALL   0590
19CC:  DECFSZ 2C,F
19CE:  BRA    19C4
....................         
....................     lcd_putc('\f');                       //Limpiar pantalla comando 
19D0:  MOVLW  0C
19D2:  MOVWF  2E
19D4:  CALL   06F8
....................     lcd_gotoxy(1,1);                      //escribir en a primera fila primera posicion  
19D8:  MOVLW  01
19DA:  MOVWF  2F
19DC:  MOVWF  30
19DE:  CALL   069C
....................     lcd_putc("MARQUE NUM PARA");          //lo que se escribe 
19E2:  CLRF   2C
19E4:  MOVF   2C,W
19E6:  CALL   0264
19EA:  IORLW  00
19EC:  BZ    19F8
19EE:  INCF   2C,F
19F0:  MOVWF  2E
19F2:  CALL   06F8
19F6:  BRA    19E4
....................     lcd_gotoxy(1,2);                      //escribir en a primera fila primera posicion  
19F8:  MOVLW  01
19FA:  MOVWF  2F
19FC:  MOVLW  02
19FE:  MOVWF  30
1A00:  CALL   069C
....................     lcd_putc("1 CAMBIAR CLAVE"); 
1A04:  CLRF   2C
1A06:  MOVF   2C,W
1A08:  CALL   0284
1A0C:  IORLW  00
1A0E:  BZ    1A1A
1A10:  INCF   2C,F
1A12:  MOVWF  2E
1A14:  CALL   06F8
1A18:  BRA    1A06
....................     delay_ms(3000);   
1A1A:  MOVLW  0C
1A1C:  MOVWF  2C
1A1E:  MOVLW  FA
1A20:  MOVWF  2F
1A22:  CALL   0590
1A26:  DECFSZ 2C,F
1A28:  BRA    1A1E
....................      
....................     lcd_putc('\f');                      //Limpiar pantalla comando 
1A2A:  MOVLW  0C
1A2C:  MOVWF  2E
1A2E:  CALL   06F8
....................     lcd_gotoxy(1,1);                     //escribir en a primera fila primera posicion  
1A32:  MOVLW  01
1A34:  MOVWF  2F
1A36:  MOVWF  30
1A38:  CALL   069C
....................     lcd_putc("2 FECHA Y HORA");          //lo que se escribe 
1A3C:  CLRF   2C
1A3E:  MOVF   2C,W
1A40:  CALL   02A4
1A44:  IORLW  00
1A46:  BZ    1A52
1A48:  INCF   2C,F
1A4A:  MOVWF  2E
1A4C:  CALL   06F8
1A50:  BRA    1A3E
....................     lcd_gotoxy(1,2);                     //escribir en a primera fila primera posicion  
1A52:  MOVLW  01
1A54:  MOVWF  2F
1A56:  MOVLW  02
1A58:  MOVWF  30
1A5A:  CALL   069C
....................     lcd_putc("3 REPORTES"); 
1A5E:  CLRF   2C
1A60:  MOVF   2C,W
1A62:  CALL   02C4
1A66:  IORLW  00
1A68:  BZ    1A74
1A6A:  INCF   2C,F
1A6C:  MOVWF  2E
1A6E:  CALL   06F8
1A72:  BRA    1A60
....................     delay_ms(3000); 
1A74:  MOVLW  0C
1A76:  MOVWF  2C
1A78:  MOVLW  FA
1A7A:  MOVWF  2F
1A7C:  CALL   0590
1A80:  DECFSZ 2C,F
1A82:  BRA    1A78
....................      
....................     lcd_putc('\f');                     //Limpiar pantalla comando 
1A84:  MOVLW  0C
1A86:  MOVWF  2E
1A88:  CALL   06F8
....................     lcd_gotoxy(1,1);                    //escribir en a primera fila primera posicion  
1A8C:  MOVLW  01
1A8E:  MOVWF  2F
1A90:  MOVWF  30
1A92:  CALL   069C
....................     lcd_putc("4 MOTOR PAS A PA");       //lo que se escribe 
1A96:  CLRF   2C
1A98:  MOVF   2C,W
1A9A:  CALL   02E0
1A9E:  IORLW  00
1AA0:  BZ    1AAC
1AA2:  INCF   2C,F
1AA4:  MOVWF  2E
1AA6:  CALL   06F8
1AAA:  BRA    1A98
....................     lcd_gotoxy(1,2);                     //escribir en a primera fila primera posicion  
1AAC:  MOVLW  01
1AAE:  MOVWF  2F
1AB0:  MOVLW  02
1AB2:  MOVWF  30
1AB4:  CALL   069C
....................     lcd_putc("5 SERVOMOTOR"); 
1AB8:  CLRF   2C
1ABA:  MOVF   2C,W
1ABC:  CALL   0302
1AC0:  IORLW  00
1AC2:  BZ    1ACE
1AC4:  INCF   2C,F
1AC6:  MOVWF  2E
1AC8:  CALL   06F8
1ACC:  BRA    1ABA
....................     delay_ms(3000); 
1ACE:  MOVLW  0C
1AD0:  MOVWF  2C
1AD2:  MOVLW  FA
1AD4:  MOVWF  2F
1AD6:  CALL   0590
1ADA:  DECFSZ 2C,F
1ADC:  BRA    1AD2
....................      
....................     lcd_putc('\f');                      //Limpiar pantalla comando 
1ADE:  MOVLW  0C
1AE0:  MOVWF  2E
1AE2:  CALL   06F8
....................     lcd_gotoxy(1,1);                     //escribir en a primera fila primera posicion  
1AE6:  MOVLW  01
1AE8:  MOVWF  2F
1AEA:  MOVWF  30
1AEC:  CALL   069C
....................     lcd_putc("6 CAD");                   //lo que se escribe 
1AF0:  CLRF   2C
1AF2:  MOVF   2C,W
1AF4:  CALL   0320
1AF8:  IORLW  00
1AFA:  BZ    1B06
1AFC:  INCF   2C,F
1AFE:  MOVWF  2E
1B00:  CALL   06F8
1B04:  BRA    1AF2
....................     lcd_gotoxy(1,2);                     //escribir en a primera fila primera posicion  
1B06:  MOVLW  01
1B08:  MOVWF  2F
1B0A:  MOVLW  02
1B0C:  MOVWF  30
1B0E:  CALL   069C
....................     lcd_putc("7 DTMF"); 
1B12:  CLRF   2C
1B14:  MOVF   2C,W
1B16:  CALL   0336
1B1A:  IORLW  00
1B1C:  BZ    1B28
1B1E:  INCF   2C,F
1B20:  MOVWF  2E
1B22:  CALL   06F8
1B26:  BRA    1B14
....................     delay_ms(3000); 
1B28:  MOVLW  0C
1B2A:  MOVWF  2C
1B2C:  MOVLW  FA
1B2E:  MOVWF  2F
1B30:  CALL   0590
1B34:  DECFSZ 2C,F
1B36:  BRA    1B2C
....................      
....................     lcd_putc('\f');                      //Limpiar pantalla comando 
1B38:  MOVLW  0C
1B3A:  MOVWF  2E
1B3C:  CALL   06F8
....................     lcd_gotoxy(1,1);                     //escribir en a primera fila primera posicion  
1B40:  MOVLW  01
1B42:  MOVWF  2F
1B44:  MOVWF  30
1B46:  CALL   069C
....................     lcd_putc("8 SENSORES");              //lo que se escribe 
1B4A:  CLRF   2C
1B4C:  MOVF   2C,W
1B4E:  CALL   034E
1B52:  IORLW  00
1B54:  BZ    1B60
1B56:  INCF   2C,F
1B58:  MOVWF  2E
1B5A:  CALL   06F8
1B5E:  BRA    1B4C
....................     lcd_gotoxy(3,2);                     //escribir en a primera fila primera posicion  
1B60:  MOVLW  03
1B62:  MOVWF  2F
1B64:  MOVLW  02
1B66:  MOVWF  30
1B68:  CALL   069C
....................     lcd_putc("9 SALIR"); 
1B6C:  CLRF   2C
1B6E:  MOVF   2C,W
1B70:  CALL   036A
1B74:  IORLW  00
1B76:  BZ    1B82
1B78:  INCF   2C,F
1B7A:  MOVWF  2E
1B7C:  CALL   06F8
1B80:  BRA    1B6E
....................     delay_ms(3000); 
1B82:  MOVLW  0C
1B84:  MOVWF  2C
1B86:  MOVLW  FA
1B88:  MOVWF  2F
1B8A:  CALL   0590
1B8E:  DECFSZ 2C,F
1B90:  BRA    1B86
....................      
....................     un_digito(); 
1B92:  CALL   0D4A
....................     if(datom==0x01) 
1B96:  DECFSZ 23,W
1B98:  BRA    1D1A
....................      { 
....................        lcd_putc('\f');                   //Limpiar pantalla comando 
1B9A:  MOVLW  0C
1B9C:  MOVWF  2E
1B9E:  CALL   06F8
....................        lcd_gotoxy(1,1);                  //escribir en a primera fila primera posicion  
1BA2:  MOVLW  01
1BA4:  MOVWF  2F
1BA6:  MOVWF  30
1BA8:  CALL   069C
....................        lcd_putc("MEN CAMBIAR CLAV");     //lo que se escribe 
1BAC:  CLRF   2C
1BAE:  MOVF   2C,W
1BB0:  CALL   0382
1BB4:  IORLW  00
1BB6:  BZ    1BC2
1BB8:  INCF   2C,F
1BBA:  MOVWF  2E
1BBC:  CALL   06F8
1BC0:  BRA    1BAE
....................        lcd_gotoxy(3,2);                  //escribir en a primera fila primera posicion  
1BC2:  MOVLW  03
1BC4:  MOVWF  2F
1BC6:  MOVLW  02
1BC8:  MOVWF  30
1BCA:  CALL   069C
....................        lcd_putc("DIGITE NU. CLAVE");     //clave[0]= y clave[1]= 
1BCE:  CLRF   2C
1BD0:  MOVF   2C,W
1BD2:  CALL   03A4
1BD6:  IORLW  00
1BD8:  BZ    1BE4
1BDA:  INCF   2C,F
1BDC:  MOVWF  2E
1BDE:  CALL   06F8
1BE2:  BRA    1BD0
....................        delay_ms(3000); 
1BE4:  MOVLW  0C
1BE6:  MOVWF  2C
1BE8:  MOVLW  FA
1BEA:  MOVWF  2F
1BEC:  CALL   0590
1BF0:  DECFSZ 2C,F
1BF2:  BRA    1BE8
....................        teclado(); 
1BF4:  CALL   0B1C
....................         
....................        dato1=clave[0]; 
1BF8:  MOVFF  14,21
....................        dato2=clave[1]; 
1BFC:  MOVFF  15,22
....................         
....................        lcd_putc('\f');                   //Limpiar pantalla comando 
1C00:  MOVLW  0C
1C02:  MOVWF  2E
1C04:  CALL   06F8
....................        lcd_gotoxy(1,1);                  //escribir en a primera fila primera posicion  
1C08:  MOVLW  01
1C0A:  MOVWF  2F
1C0C:  MOVWF  30
1C0E:  CALL   069C
....................        lcd_putc("POR FAVOR DIGITE");     //lo que se escribe 
1C12:  CLRF   2C
1C14:  MOVF   2C,W
1C16:  CALL   03C6
1C1A:  IORLW  00
1C1C:  BZ    1C28
1C1E:  INCF   2C,F
1C20:  MOVWF  2E
1C22:  CALL   06F8
1C26:  BRA    1C14
....................        lcd_gotoxy(1,2);                  //escribir en a primera fila primera posicion  
1C28:  MOVLW  01
1C2A:  MOVWF  2F
1C2C:  MOVLW  02
1C2E:  MOVWF  30
1C30:  CALL   069C
....................        lcd_putc("DIGITE NUE.CLAVE");    
1C34:  CLRF   2C
1C36:  MOVF   2C,W
1C38:  CALL   03E8
1C3C:  IORLW  00
1C3E:  BZ    1C4A
1C40:  INCF   2C,F
1C42:  MOVWF  2E
1C44:  CALL   06F8
1C48:  BRA    1C36
....................        delay_ms(3000); 
1C4A:  MOVLW  0C
1C4C:  MOVWF  2C
1C4E:  MOVLW  FA
1C50:  MOVWF  2F
1C52:  CALL   0590
1C56:  DECFSZ 2C,F
1C58:  BRA    1C4E
....................         
....................        teclado(); 
1C5A:  CALL   0B1C
....................         
....................        if(clave[0]==dato1 & clave[1]==dato2) 
1C5E:  MOVF   21,W
1C60:  SUBWF  14,W
1C62:  BZ    1C68
1C64:  MOVLW  00
1C66:  BRA    1C6A
1C68:  MOVLW  01
1C6A:  MOVWF  2C
1C6C:  MOVF   22,W
1C6E:  SUBWF  15,W
1C70:  BZ    1C76
1C72:  MOVLW  00
1C74:  BRA    1C78
1C76:  MOVLW  01
1C78:  ANDWF  2C,W
1C7A:  BZ    1CDE
....................        { 
....................         escribir_memoria_ext(); 
1C7C:  CALL   0EA0
....................         lcd_putc('\f');                   //Limpiar pantalla comando 
1C80:  MOVLW  0C
1C82:  MOVWF  2E
1C84:  CALL   06F8
....................         lcd_gotoxy(1,1);                  //escribir en a primera fila primera posicion  
1C88:  MOVLW  01
1C8A:  MOVWF  2F
1C8C:  MOVWF  30
1C8E:  CALL   069C
....................         lcd_putc("CLAVE MODIFICADA");     //lo que se escribe 
1C92:  CLRF   2C
1C94:  MOVF   2C,W
1C96:  CALL   040A
1C9A:  IORLW  00
1C9C:  BZ    1CA8
1C9E:  INCF   2C,F
1CA0:  MOVWF  2E
1CA2:  CALL   06F8
1CA6:  BRA    1C94
....................         lcd_gotoxy(3,2);                  //escribir en a primera fila primera posicion  
1CA8:  MOVLW  03
1CAA:  MOVWF  2F
1CAC:  MOVLW  02
1CAE:  MOVWF  30
1CB0:  CALL   069C
....................         lcd_putc("CON EXITO");    
1CB4:  CLRF   2C
1CB6:  MOVF   2C,W
1CB8:  CALL   042C
1CBC:  IORLW  00
1CBE:  BZ    1CCA
1CC0:  INCF   2C,F
1CC2:  MOVWF  2E
1CC4:  CALL   06F8
1CC8:  BRA    1CB6
....................         delay_ms(3000); 
1CCA:  MOVLW  0C
1CCC:  MOVWF  2C
1CCE:  MOVLW  FA
1CD0:  MOVWF  2F
1CD2:  CALL   0590
1CD6:  DECFSZ 2C,F
1CD8:  BRA    1CCE
....................         goto David; 
1CDA:  BRA    1972
....................        } 
....................        else{ 
1CDC:  BRA    1D18
....................        lcd_putc('\f');                   //Limpiar pantalla comando 
1CDE:  MOVLW  0C
1CE0:  MOVWF  2E
1CE2:  CALL   06F8
....................        lcd_gotoxy(1,1);                  //escribir en a primera fila primera posicion  
1CE6:  MOVLW  01
1CE8:  MOVWF  2F
1CEA:  MOVWF  30
1CEC:  CALL   069C
....................        lcd_putc("ERROR DE CLAVE");     //lo que se escribe 
1CF0:  CLRF   2C
1CF2:  MOVF   2C,W
1CF4:  CALL   0446
1CF8:  IORLW  00
1CFA:  BZ    1D06
1CFC:  INCF   2C,F
1CFE:  MOVWF  2E
1D00:  CALL   06F8
1D04:  BRA    1CF2
....................        delay_ms(3000); 
1D06:  MOVLW  0C
1D08:  MOVWF  2C
1D0A:  MOVLW  FA
1D0C:  MOVWF  2F
1D0E:  CALL   0590
1D12:  DECFSZ 2C,F
1D14:  BRA    1D0A
....................        goto David; 
1D16:  BRA    1972
....................        } 
....................         
....................      } 
....................      else if(datom==0x02) 
1D18:  BRA    2020
1D1A:  MOVF   23,W
1D1C:  SUBLW  02
1D1E:  BNZ   1D7E
....................      { 
....................        lcd_putc('\f');                  //Limpiar pantalla comando 
1D20:  MOVLW  0C
1D22:  MOVWF  2E
1D24:  CALL   06F8
....................        lcd_gotoxy(1,1);                 //escribir en a primera fila primera posicion  
1D28:  MOVLW  01
1D2A:  MOVWF  2F
1D2C:  MOVWF  30
1D2E:  CALL   069C
....................        lcd_putc("MEN FECHA Y HORA");    //lo que se escribe 
1D32:  CLRF   2C
1D34:  MOVF   2C,W
1D36:  CALL   0466
1D3A:  IORLW  00
1D3C:  BZ    1D48
1D3E:  INCF   2C,F
1D40:  MOVWF  2E
1D42:  CALL   06F8
1D46:  BRA    1D34
....................        lcd_gotoxy(3,2);                 //escribir en a primera fila primera posicion  
1D48:  MOVLW  03
1D4A:  MOVWF  2F
1D4C:  MOVLW  02
1D4E:  MOVWF  30
1D50:  CALL   069C
....................        lcd_putc("EN CONSTRUCCION"); 
1D54:  CLRF   2C
1D56:  MOVF   2C,W
1D58:  CALL   0488
1D5C:  IORLW  00
1D5E:  BZ    1D6A
1D60:  INCF   2C,F
1D62:  MOVWF  2E
1D64:  CALL   06F8
1D68:  BRA    1D56
....................        delay_ms(3000); 
1D6A:  MOVLW  0C
1D6C:  MOVWF  2C
1D6E:  MOVLW  FA
1D70:  MOVWF  2F
1D72:  CALL   0590
1D76:  DECFSZ 2C,F
1D78:  BRA    1D6E
....................        goto David; 
1D7A:  BRA    1972
....................      } 
....................      else  if(datom==0x03) 
1D7C:  BRA    2020
1D7E:  MOVF   23,W
1D80:  SUBLW  03
1D82:  BNZ   1DE2
....................      { 
....................        lcd_putc('\f');                //Limpiar pantalla comando 
1D84:  MOVLW  0C
1D86:  MOVWF  2E
1D88:  CALL   06F8
....................        lcd_gotoxy(1,1);               //escribir en a primera fila primera posicion  
1D8C:  MOVLW  01
1D8E:  MOVWF  2F
1D90:  MOVWF  30
1D92:  CALL   069C
....................        lcd_putc("MENU REPORTES");     //lo que se escribe 
1D96:  CLRF   2C
1D98:  MOVF   2C,W
1D9A:  CALL   04A8
1D9E:  IORLW  00
1DA0:  BZ    1DAC
1DA2:  INCF   2C,F
1DA4:  MOVWF  2E
1DA6:  CALL   06F8
1DAA:  BRA    1D98
....................        lcd_gotoxy(3,2);               //escribir en a primera fila primera posicion  
1DAC:  MOVLW  03
1DAE:  MOVWF  2F
1DB0:  MOVLW  02
1DB2:  MOVWF  30
1DB4:  CALL   069C
....................        lcd_putc("EN CONSTRUCCION"); 
1DB8:  CLRF   2C
1DBA:  MOVF   2C,W
1DBC:  CALL   0488
1DC0:  IORLW  00
1DC2:  BZ    1DCE
1DC4:  INCF   2C,F
1DC6:  MOVWF  2E
1DC8:  CALL   06F8
1DCC:  BRA    1DBA
....................        delay_ms(3000); 
1DCE:  MOVLW  0C
1DD0:  MOVWF  2C
1DD2:  MOVLW  FA
1DD4:  MOVWF  2F
1DD6:  CALL   0590
1DDA:  DECFSZ 2C,F
1DDC:  BRA    1DD2
....................        goto David;; 
1DDE:  BRA    1972
....................      } 
....................      else if(datom==0x04) 
1DE0:  BRA    2020
1DE2:  MOVF   23,W
1DE4:  SUBLW  04
1DE6:  BNZ   1E46
....................      { 
....................        lcd_putc('\f');               //Limpiar pantalla comando 
1DE8:  MOVLW  0C
1DEA:  MOVWF  2E
1DEC:  CALL   06F8
....................        lcd_gotoxy(1,1);              //escribir en a primera fila primera posicion  
1DF0:  MOVLW  01
1DF2:  MOVWF  2F
1DF4:  MOVWF  30
1DF6:  CALL   069C
....................        lcd_putc("MEN MOTOR PAS A."); //lo que se escribe 
1DFA:  CLRF   2C
1DFC:  MOVF   2C,W
1DFE:  CALL   04C6
1E02:  IORLW  00
1E04:  BZ    1E10
1E06:  INCF   2C,F
1E08:  MOVWF  2E
1E0A:  CALL   06F8
1E0E:  BRA    1DFC
....................        lcd_gotoxy(3,2);              //escribir en a primera fila primera posicion  
1E10:  MOVLW  03
1E12:  MOVWF  2F
1E14:  MOVLW  02
1E16:  MOVWF  30
1E18:  CALL   069C
....................        lcd_putc("EN CONSTRUCCION"); 
1E1C:  CLRF   2C
1E1E:  MOVF   2C,W
1E20:  CALL   0488
1E24:  IORLW  00
1E26:  BZ    1E32
1E28:  INCF   2C,F
1E2A:  MOVWF  2E
1E2C:  CALL   06F8
1E30:  BRA    1E1E
....................        delay_ms(3000); 
1E32:  MOVLW  0C
1E34:  MOVWF  2C
1E36:  MOVLW  FA
1E38:  MOVWF  2F
1E3A:  CALL   0590
1E3E:  DECFSZ 2C,F
1E40:  BRA    1E36
....................        goto David; 
1E42:  BRA    1972
....................      } 
....................      else if(datom==0x05) 
1E44:  BRA    2020
1E46:  MOVF   23,W
1E48:  SUBLW  05
1E4A:  BNZ   1EAA
....................      { 
....................        lcd_putc('\f');              //Limpiar pantalla comando 
1E4C:  MOVLW  0C
1E4E:  MOVWF  2E
1E50:  CALL   06F8
....................        lcd_gotoxy(1,1);             //escribir en a primera fila primera posicion  
1E54:  MOVLW  01
1E56:  MOVWF  2F
1E58:  MOVWF  30
1E5A:  CALL   069C
....................        lcd_putc("MEN SERVOMOTOR");  //lo que se escribe 
1E5E:  CLRF   2C
1E60:  MOVF   2C,W
1E62:  CALL   04E8
1E66:  IORLW  00
1E68:  BZ    1E74
1E6A:  INCF   2C,F
1E6C:  MOVWF  2E
1E6E:  CALL   06F8
1E72:  BRA    1E60
....................        lcd_gotoxy(3,2);             //escribir en a primera fila primera posicion  
1E74:  MOVLW  03
1E76:  MOVWF  2F
1E78:  MOVLW  02
1E7A:  MOVWF  30
1E7C:  CALL   069C
....................        lcd_putc("EN CONSTRUCCION"); 
1E80:  CLRF   2C
1E82:  MOVF   2C,W
1E84:  CALL   0488
1E88:  IORLW  00
1E8A:  BZ    1E96
1E8C:  INCF   2C,F
1E8E:  MOVWF  2E
1E90:  CALL   06F8
1E94:  BRA    1E82
....................        delay_ms(3000); 
1E96:  MOVLW  0C
1E98:  MOVWF  2C
1E9A:  MOVLW  FA
1E9C:  MOVWF  2F
1E9E:  CALL   0590
1EA2:  DECFSZ 2C,F
1EA4:  BRA    1E9A
....................        goto David; 
1EA6:  BRA    1972
....................      } 
....................      else if(datom==0x06) 
1EA8:  BRA    2020
1EAA:  MOVF   23,W
1EAC:  SUBLW  06
1EAE:  BNZ   1F0E
....................      { 
....................        lcd_putc('\f');               //Limpiar pantalla comando 
1EB0:  MOVLW  0C
1EB2:  MOVWF  2E
1EB4:  CALL   06F8
....................        lcd_gotoxy(1,1);              //escribir en a primera fila primera posicion  
1EB8:  MOVLW  01
1EBA:  MOVWF  2F
1EBC:  MOVWF  30
1EBE:  CALL   069C
....................        lcd_putc("MENU CAD");         //lo que se escribe 
1EC2:  CLRF   2C
1EC4:  MOVF   2C,W
1EC6:  CALL   0508
1ECA:  IORLW  00
1ECC:  BZ    1ED8
1ECE:  INCF   2C,F
1ED0:  MOVWF  2E
1ED2:  CALL   06F8
1ED6:  BRA    1EC4
....................        lcd_gotoxy(3,2);              //escribir en a primera fila primera posicion  
1ED8:  MOVLW  03
1EDA:  MOVWF  2F
1EDC:  MOVLW  02
1EDE:  MOVWF  30
1EE0:  CALL   069C
....................        lcd_putc("EN CONSTRUCCION"); 
1EE4:  CLRF   2C
1EE6:  MOVF   2C,W
1EE8:  CALL   0488
1EEC:  IORLW  00
1EEE:  BZ    1EFA
1EF0:  INCF   2C,F
1EF2:  MOVWF  2E
1EF4:  CALL   06F8
1EF8:  BRA    1EE6
....................        delay_ms(3000); 
1EFA:  MOVLW  0C
1EFC:  MOVWF  2C
1EFE:  MOVLW  FA
1F00:  MOVWF  2F
1F02:  CALL   0590
1F06:  DECFSZ 2C,F
1F08:  BRA    1EFE
....................        goto David; 
1F0A:  BRA    1972
....................      } 
....................      else if(datom==0x07) 
1F0C:  BRA    2020
1F0E:  MOVF   23,W
1F10:  SUBLW  07
1F12:  BNZ   1F72
....................      { 
....................        lcd_putc('\f');               //Limpiar pantalla comando 
1F14:  MOVLW  0C
1F16:  MOVWF  2E
1F18:  CALL   06F8
....................        lcd_gotoxy(1,1);              //escribir en a primera fila primera posicion  
1F1C:  MOVLW  01
1F1E:  MOVWF  2F
1F20:  MOVWF  30
1F22:  CALL   069C
....................        lcd_putc("MEN DTMF");         //lo que se escribe 
1F26:  CLRF   2C
1F28:  MOVF   2C,W
1F2A:  CALL   0522
1F2E:  IORLW  00
1F30:  BZ    1F3C
1F32:  INCF   2C,F
1F34:  MOVWF  2E
1F36:  CALL   06F8
1F3A:  BRA    1F28
....................        lcd_gotoxy(3,2);              //escribir en a primera fila primera posicion  
1F3C:  MOVLW  03
1F3E:  MOVWF  2F
1F40:  MOVLW  02
1F42:  MOVWF  30
1F44:  CALL   069C
....................        lcd_putc("EN CONSTRUCCION"); 
1F48:  CLRF   2C
1F4A:  MOVF   2C,W
1F4C:  CALL   0488
1F50:  IORLW  00
1F52:  BZ    1F5E
1F54:  INCF   2C,F
1F56:  MOVWF  2E
1F58:  CALL   06F8
1F5C:  BRA    1F4A
....................        delay_ms(3000); 
1F5E:  MOVLW  0C
1F60:  MOVWF  2C
1F62:  MOVLW  FA
1F64:  MOVWF  2F
1F66:  CALL   0590
1F6A:  DECFSZ 2C,F
1F6C:  BRA    1F62
....................        goto David; 
1F6E:  BRA    1972
....................      } 
....................      else if(datom==0x08) 
1F70:  BRA    2020
1F72:  MOVF   23,W
1F74:  SUBLW  08
1F76:  BNZ   1FD6
....................      { 
....................        lcd_putc('\f');              //Limpiar pantalla comando 
1F78:  MOVLW  0C
1F7A:  MOVWF  2E
1F7C:  CALL   06F8
....................        lcd_gotoxy(1,1);             //escribir en a primera fila primera posicion  
1F80:  MOVLW  01
1F82:  MOVWF  2F
1F84:  MOVWF  30
1F86:  CALL   069C
....................        lcd_putc("MEN SENSORES");    //lo que se escribe 
1F8A:  CLRF   2C
1F8C:  MOVF   2C,W
1F8E:  CALL   053C
1F92:  IORLW  00
1F94:  BZ    1FA0
1F96:  INCF   2C,F
1F98:  MOVWF  2E
1F9A:  CALL   06F8
1F9E:  BRA    1F8C
....................        lcd_gotoxy(3,2);             //escribir en a primera fila primera posicion  
1FA0:  MOVLW  03
1FA2:  MOVWF  2F
1FA4:  MOVLW  02
1FA6:  MOVWF  30
1FA8:  CALL   069C
....................        lcd_putc("EN CONSTRUCCION"); 
1FAC:  CLRF   2C
1FAE:  MOVF   2C,W
1FB0:  CALL   0488
1FB4:  IORLW  00
1FB6:  BZ    1FC2
1FB8:  INCF   2C,F
1FBA:  MOVWF  2E
1FBC:  CALL   06F8
1FC0:  BRA    1FAE
....................        delay_ms(3000); 
1FC2:  MOVLW  0C
1FC4:  MOVWF  2C
1FC6:  MOVLW  FA
1FC8:  MOVWF  2F
1FCA:  CALL   0590
1FCE:  DECFSZ 2C,F
1FD0:  BRA    1FC6
....................        goto David; 
1FD2:  BRA    1972
....................      } 
....................      else if(datom==0x09) 
1FD4:  BRA    2020
1FD6:  MOVF   23,W
1FD8:  SUBLW  09
1FDA:  BNZ   1FE2
....................      { 
....................       goto admin; 
1FDC:  GOTO   10C0
....................      } 
....................      else{ 
1FE0:  BRA    2020
....................           lcd_putc('\f');                 //Limpiar pantalla comando 
1FE2:  MOVLW  0C
1FE4:  MOVWF  2E
1FE6:  CALL   06F8
....................           lcd_gotoxy(1,2);                //escribir en a primera fila primera posicion  
1FEA:  MOVLW  01
1FEC:  MOVWF  2F
1FEE:  MOVLW  02
1FF0:  MOVWF  30
1FF2:  CALL   069C
....................           lcd_putc("ERROR DE NUMERO");   //lo que se escribe 
1FF6:  CLRF   2C
1FF8:  MOVF   2C,W
1FFA:  CALL   0210
1FFE:  IORLW  00
2000:  BZ    200C
2002:  INCF   2C,F
2004:  MOVWF  2E
2006:  CALL   06F8
200A:  BRA    1FF8
....................           delay_ms(3000); 
200C:  MOVLW  0C
200E:  MOVWF  2C
2010:  MOVLW  FA
2012:  MOVWF  2F
2014:  CALL   0590
2018:  DECFSZ 2C,F
201A:  BRA    2010
....................           goto menu; 
201C:  GOTO   0F2E
....................       } 
....................      }else{ 
2020:  BRA    2060
....................      lcd_putc('\f');                 //Limpiar pantalla comando 
2022:  MOVLW  0C
2024:  MOVWF  2E
2026:  CALL   06F8
....................      lcd_gotoxy(1,2);                //escribir en a primera fila primera posicion  
202A:  MOVLW  01
202C:  MOVWF  2F
202E:  MOVLW  02
2030:  MOVWF  30
2032:  CALL   069C
....................      lcd_putc("CONTRA. ERRONEA");   //lo que se escribe 
2036:  CLRF   2C
2038:  MOVF   2C,W
203A:  CALL   0570
203E:  IORLW  00
2040:  BZ    204C
2042:  INCF   2C,F
2044:  MOVWF  2E
2046:  CALL   06F8
204A:  BRA    2038
....................      delay_ms(3000); 
204C:  MOVLW  0C
204E:  MOVWF  2C
2050:  MOVLW  FA
2052:  MOVWF  2F
2054:  CALL   0590
2058:  DECFSZ 2C,F
205A:  BRA    2050
....................      goto menu; 
205C:  GOTO   0F2E
....................      } 
....................    } 
....................  
2060:  SLEEP 

Configuration Fuses:
   Word  1: 0C00   NOIESO NOFCMEN HS PLL1 CPUDIV1 NOUSBDIV
   Word  2: 1E18   NOBROWNOUT NOWDT BORV20 PUT WDT32768 NOVREGEN
   Word  3: 0300   PBADEN CCP2C1 NOMCLR NOLPT1OSC
   Word  4: 0081   STVREN NODEBUG NOLVP NOXINST NOICPRT
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: E00F   NOWRT NOWRTD NOWRTC NOWRTB
   Word  7: 400F   NOEBTR NOEBTRB

ROM data:
F00000: 23 45 34 56 
