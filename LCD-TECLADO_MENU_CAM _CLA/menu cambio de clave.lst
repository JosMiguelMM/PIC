CCS PCH C Compiler, Version 4.093, 51109               27-sept.-21 20:35

               Filename: C:\Proyecto arquitectura c\LCD-TECLADO_MENU_CAM _CLA\menu cambio de clave.lst

               ROM used: 7568 bytes (23%)
                         Largest free fragment is 25200
               RAM used: 41 (2%) at main() level
                         53 (3%) worst case
               Stack:    5 locations

*
0000:  GOTO   0C54
.................... #include <18F4550.h> 
.................... //////// Standard Header file for the PIC18F4550 device //////////////// 
.................... #device PIC18F4550 
.................... #list 
....................  
.................... #fuses     HS,NOPROTECT,NOBROWNOUT,NOWDT,PUT,NOCPD,NODEBUG,NOLVP,NOMCLR  
.................... #use       delay(clock=20000000) 
*
0590:  CLRF   FEA
0592:  MOVLW  2B
0594:  MOVWF  FE9
0596:  MOVF   FEF,W
0598:  BZ    05B4
059A:  MOVLW  06
059C:  MOVWF  01
059E:  CLRF   00
05A0:  DECFSZ 00,F
05A2:  BRA    05A0
05A4:  DECFSZ 01,F
05A6:  BRA    059E
05A8:  MOVLW  7B
05AA:  MOVWF  00
05AC:  DECFSZ 00,F
05AE:  BRA    05AC
05B0:  DECFSZ FEF,F
05B2:  BRA    059A
05B4:  RETLW  00
.................... #include   <stdlib.h>           //LIBRERIAS MATEMATICAS IGUAL LA DE ABAJO 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = TRUE, sign = FALSE, point = FALSE; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = FALSE; 
....................          if (c == '+') 
....................          { 
....................             sign = FALSE; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = TRUE; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = TRUE; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = TRUE, sign = FALSE, point = FALSE; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = FALSE; 
....................          if (c == '+') 
....................          { 
....................             sign = FALSE; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = TRUE; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = TRUE; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = TRUE, sign = FALSE, point = FALSE; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = FALSE; 
....................          if (c == '+') 
....................          { 
....................             sign = FALSE; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = TRUE; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = TRUE; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    BYTE t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=TRUE; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = FALSE; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include   <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float32)l); 
....................   res = 32768.0*(float32)l; 
....................   res += (float32)(unsigned int16)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float48)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float48)l); 
....................   res = 32768.0*(float32)l; 
....................   res += (float48)(unsigned int16)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float48)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float64)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float64)l); 
....................   res = 32768.0*(float64)l; 
....................   res += (float64)(unsigned int16)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float64)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y/LN2 - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y/LN2 - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y/LN2 - (float64)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {0.45145214, -9.0558803, 26.940971, -19.860189}; 
.................... float32 const ql[4] = {1.0000000,  -8.1354259, 16.780517, -9.9300943}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................    bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................       res = res*y2 + pl[2]; 
....................       res = res*y2 + pl[3]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + ql[2]; 
....................       r = r*y2 + ql[3]; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................     
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................    
....................       if(bit_test(data2,7)) 
....................          bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................       res = res*y2 + pl[2]; 
....................       res = res*y2 + pl[3]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + ql[2]; 
....................       r = r*y2 + ql[3]; 
....................  
....................       res = y*res/r; 
....................  
....................     data1 = *(((unsigned int8 *)(&x)+5)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+4)); 
....................     if(bit_test (data2,7)) 
....................        bit_set(data1,0); 
....................       
....................     n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................          r = -(float48)-n; 
....................       else 
....................          r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float32 const pl_64[4] = {0.45145214, -9.0558803, 26.940971, -19.860189}; 
.................... float32 const ql_64[4] = {1.0000000,  -8.1354259, 16.780517, -9.9300943}; 
.................... #endif 
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................       bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................     bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................    bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................      bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #define TWOBYPI          0.6366197723675813 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[4] = { 
....................       -0.499999993585, 
....................        0.041666636258, 
....................       -0.0013888361399, 
....................        0.00002476016134 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 3; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[4] = { 
....................       -0.499999993585, 
....................        0.041666636258, 
....................       -0.0013888361399, 
....................        0.00002476016134 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 3; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float48 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p[4] = { 
....................       -0.499999993585, 
....................        0.041666636258, 
....................       -0.0013888361399, 
....................        0.00002476016134 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 3; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #define   LCD_E         PIN_E2 
.................... #define   LCD_CK        PIN_E1  
.................... #define   LCD_DAT       PIN_E0 
.................... #include <LCD4x20_3PIN.c> 
.................... // flex_lcd_3_pins.c 
....................  
.................... //Modificacin de Flex_lcd por Duende_Azul y Akenafab 
.................... //Trabaja con 3 pines y 74VHC164 
.................... //8-Bit Serial-In, Parallel-Out Shift Register 
....................  
.................... //La LCD se usa en modo 4bits 
.................... //Revisar diagrama de conexion Adjunto 
....................  
.................... //No esta habilitada la lectura del LCD 
.................... //RW debe ir a gnd 
....................  
.................... //Definir pines antes de llamar libreria// 
.................... //#define LCD_E     PIN_A0 
.................... //#define LCD_CK    PIN_A1    
.................... //#define LCD_DAT   PIN_A2 
....................  
.................... //======================================== 
.................... int RS_bit; 
.................... #define lcd_type 2        // 0=5x7, 1=5x10, 2=2 lines 
.................... #define lcd_line_two 0x40 // LCD RAM address for the 2nd line 
....................  
....................  
.................... int8 const LCD_INIT_STRING[4] = 
.................... { 
....................  0x20 | (lcd_type << 2), // Func set: 4-bit, 2 lines, 5x8 dots 
....................  0xc,                    // Display on 
....................  1,                      // Clear display 
....................  6                       // Increment cursor 
....................  }; 
.................... BYTE lcdline; 
....................  
.................... //------------------------------------- 
.................... void lcd_send_nibble(int8 nibble, int rs_bit) 
.................... { 
....................  
.................... int x; 
.................... if(RS_bit==1) 
05B6:  DECFSZ 33,W
05B8:  BRA    05BC
....................    nibble=nibble|0x10; 
05BA:  BSF    32.4
....................  
.................... for(x=0;x<5;x++){ 
05BC:  CLRF   34
05BE:  MOVF   34,W
05C0:  SUBLW  04
05C2:  BNC   05E6
....................          output_bit(LCD_DAT,shift_right(&nibble,1,0)); 
05C4:  BCF    FD8.0
05C6:  RRCF   32,F
05C8:  BC    05CE
05CA:  BCF    F8D.0
05CC:  BRA    05D0
05CE:  BSF    F8D.0
05D0:  BCF    F96.0
....................          delay_cycles(1); 
05D2:  NOP   
....................          output_low(LCD_CK); 
05D4:  BCF    F96.1
05D6:  BCF    F8D.1
....................          delay_us(1); 
05D8:  BRA    05DA
05DA:  BRA    05DC
05DC:  NOP   
....................          output_high(LCD_CK);} 
05DE:  BCF    F96.1
05E0:  BSF    F8D.1
05E2:  INCF   34,F
05E4:  BRA    05BE
....................  
....................  
....................  
....................  output_high(LCD_E); 
05E6:  BCF    F96.2
05E8:  BSF    F8D.2
....................  delay_us(2); 
05EA:  MOVLW  03
05EC:  MOVWF  00
05EE:  DECFSZ 00,F
05F0:  BRA    05EE
....................  output_low(LCD_E); 
05F2:  BCF    F96.2
05F4:  BCF    F8D.2
.................... } 
05F6:  RETLW  00
....................  
.................... //----------------------------------- 
.................... //---------------------------------------- 
.................... // Send a byte to the LCD. 
.................... void lcd_send_byte(int8 address, int8 n) 
.................... { 
.................... //output_low(LCD_RS); 
.................... RS_bit=0; 
05F8:  CLRF   0B
.................... delay_us(100); 
05FA:  MOVLW  A6
05FC:  MOVWF  00
05FE:  DECFSZ 00,F
0600:  BRA    05FE
0602:  NOP   
....................  
....................  
.................... if(address) 
0604:  MOVF   2F,F
0606:  BZ    060E
....................    //output_high(LCD_RS); 
....................    RS_bit=1; 
0608:  MOVLW  01
060A:  MOVWF  0B
.................... else 
060C:  BRA    0610
....................    //output_low(LCD_RS); 
....................    RS_bit=0; 
060E:  CLRF   0B
....................  
....................  delay_cycles(1); 
0610:  NOP   
....................  
....................  
.................... output_low(LCD_E); 
0612:  BCF    F96.2
0614:  BCF    F8D.2
....................  
.................... lcd_send_nibble(n >> 4,RS_bit); 
0616:  SWAPF  30,W
0618:  MOVWF  31
061A:  MOVLW  0F
061C:  ANDWF  31,F
061E:  MOVFF  31,32
0622:  MOVFF  0B,33
0626:  RCALL  05B6
.................... lcd_send_nibble(n & 0xf,RS_bit); 
0628:  MOVF   30,W
062A:  ANDLW  0F
062C:  MOVWF  31
062E:  MOVWF  32
0630:  MOVFF  0B,33
0634:  RCALL  05B6
.................... } 
0636:  RETLW  00
....................  
.................... //---------------------------- 
.................... void lcd_init(void) 
.................... { 
.................... int8 i; 
....................  
.................... //output_low(LCD_RS); 
.................... RS_bit=0; 
0638:  CLRF   0B
....................  
.................... output_low(LCD_E); 
063A:  BCF    F96.2
063C:  BCF    F8D.2
....................  
.................... delay_ms(20); 
063E:  MOVLW  14
0640:  MOVWF  2B
0642:  RCALL  0590
....................  
.................... for(i=0 ;i < 3; i++) 
0644:  CLRF   28
0646:  MOVF   28,W
0648:  SUBLW  02
064A:  BNC   0660
....................    { 
....................     lcd_send_nibble(0x03,RS_bit); 
064C:  MOVLW  03
064E:  MOVWF  32
0650:  MOVFF  0B,33
0654:  RCALL  05B6
....................     delay_ms(5); 
0656:  MOVLW  05
0658:  MOVWF  2B
065A:  RCALL  0590
....................    } 
065C:  INCF   28,F
065E:  BRA    0646
....................  
.................... lcd_send_nibble(0x02,RS_bit); 
0660:  MOVLW  02
0662:  MOVWF  32
0664:  MOVFF  0B,33
0668:  RCALL  05B6
....................  
.................... for(i=0; i < sizeof(LCD_INIT_STRING); i++) 
066A:  CLRF   28
066C:  MOVF   28,W
066E:  SUBLW  03
0670:  BNC   0694
....................    { 
....................     lcd_send_byte(0, LCD_INIT_STRING[i]); 
0672:  CLRF   03
0674:  MOVF   28,W
0676:  MOVFF  FF2,29
067A:  BCF    FF2.7
067C:  RCALL  0004
067E:  BTFSC  29.7
0680:  BSF    FF2.7
0682:  MOVWF  29
0684:  CLRF   2F
0686:  MOVWF  30
0688:  RCALL  05F8
....................  
....................     delay_ms(5); 
068A:  MOVLW  05
068C:  MOVWF  2B
068E:  RCALL  0590
....................      
....................    } 
0690:  INCF   28,F
0692:  BRA    066C
....................  
.................... } 
0694:  GOTO   0C9A (RETURN)
....................  
.................... //---------------------------- 
....................  
.................... void lcd_gotoxy(int8 x, int8 y) 
.................... { 
.................... int8 address; 
....................  
....................    switch(y) { 
*
069C:  MOVLW  01
069E:  SUBWF  2C,W
06A0:  ADDLW  FC
06A2:  BC    06C2
06A4:  ADDLW  04
06A6:  GOTO   06D6
....................      case 1 : address=0x80;break; 
06AA:  MOVLW  80
06AC:  MOVWF  2D
06AE:  BRA    06C2
....................      case 2 : address=0xc0;break; 
06B0:  MOVLW  C0
06B2:  MOVWF  2D
06B4:  BRA    06C2
....................      case 3 : address=0x94;break; 
06B6:  MOVLW  94
06B8:  MOVWF  2D
06BA:  BRA    06C2
....................      case 4 : address=0xd4;break; 
06BC:  MOVLW  D4
06BE:  MOVWF  2D
06C0:  BRA    06C2
....................    } 
.................... address += x-1; 
06C2:  MOVLW  01
06C4:  SUBWF  2B,W
06C6:  ADDWF  2D,F
.................... lcd_send_byte(0, 0x80 | address); 
06C8:  MOVF   2D,W
06CA:  IORLW  80
06CC:  MOVWF  2E
06CE:  CLRF   2F
06D0:  MOVWF  30
06D2:  RCALL  05F8
.................... } 
06D4:  RETLW  00
....................  
.................... //----------------------------- 
.................... void lcd_putc(char c) 
.................... { 
....................  switch(c) 
....................    { 
*
06F8:  MOVF   2A,W
06FA:  XORLW  0C
06FC:  BZ    0714
06FE:  XORLW  06
0700:  BZ    0728
0702:  XORLW  02
0704:  BZ    0736
0706:  XORLW  6B
0708:  BZ    0740
070A:  XORLW  04
070C:  BZ    074A
070E:  XORLW  0F
0710:  BZ    0754
0712:  BRA    075E
....................     case '\f':                //limpia pantalla 
....................       lcd_send_byte(0,1); 
0714:  CLRF   2F
0716:  MOVLW  01
0718:  MOVWF  30
071A:  RCALL  05F8
....................       lcdline=1; 
071C:  MOVLW  01
071E:  MOVWF  0C
....................       delay_ms(8); 
0720:  MOVLW  08
0722:  MOVWF  2B
0724:  RCALL  0590
....................       break; 
0726:  BRA    076A
....................  
....................     case '\n':                //cambio de linea 
....................        lcd_gotoxy(1,++lcdline); 
0728:  INCF   0C,F
072A:  MOVLW  01
072C:  MOVWF  2B
072E:  MOVFF  0C,2C
0732:  RCALL  069C
....................        break; 
0734:  BRA    076A
....................  
....................     case '\b':                //retrocede 1 caracter 
....................        lcd_send_byte(0,0x10); 
0736:  CLRF   2F
0738:  MOVLW  10
073A:  MOVWF  30
073C:  RCALL  05F8
....................        break; 
073E:  BRA    076A
....................         
....................     case '\c':                //on display 
....................     lcd_send_byte(0,0x0c); 
0740:  CLRF   2F
0742:  MOVLW  0C
0744:  MOVWF  30
0746:  RCALL  05F8
....................     break; 
0748:  BRA    076A
....................     
....................     case '\g':                 
....................     lcd_send_byte(0,0x0f);    // prende cursor y parpadea 
074A:  CLRF   2F
074C:  MOVLW  0F
074E:  MOVWF  30
0750:  RCALL  05F8
....................     break;   
0752:  BRA    076A
....................  
....................     case '\h':                //retrocede 1 caracter 
....................     lcd_send_byte(0,0x0f);    // prende cursor y parpadea 
0754:  CLRF   2F
0756:  MOVLW  0F
0758:  MOVWF  30
075A:  RCALL  05F8
....................     break; 
075C:  BRA    076A
....................      
....................     default: 
....................        lcd_send_byte(1,c); 
075E:  MOVLW  01
0760:  MOVWF  2F
0762:  MOVFF  2A,30
0766:  RCALL  05F8
....................        break; 
0768:  BRA    076A
....................    } 
.................... } 
076A:  RETLW  00
....................  
.................... //------------------------------ 
....................  
.................... void lcd_cursor_vb(short visible, short blink) {  
....................   lcd_send_byte(0, 0xC|(visible<<1)|blink);  
.................... }  
....................  
....................  
.................... #include <KBD18F.c> 
.................... //////////////////////////////////////////////////////////////////////////////////// 
.................... //                                   KBD.C                                        // 
.................... //               FUNCIONES PARA ESCANEO DE UN TECLADO MATRICIAL                   // 
.................... //                         4X4 HEXADECIMAL, EN EL PORTB                           // 
.................... //       kbd_init()       Debe ser invocada antes que las otras funciones.         // 
.................... //       c=lcd_getc(c)    Si h sido presionada una tecla devuelve el caracter c    // 
.................... //                  y lo salva en el char c, sino se presiona una tecla       // 
.................... //                  retorna el valor /0, esta funcin puede invocarse         // 
.................... //                  frecuentemente para no perder teclas pulsadas.            // 
.................... //        NOTA: REQUIERE COLOCAR RESISTENCIAS (2.2K) EN LOS PINES DE COLUMNAS     // 
.................... //               PINES DE COLUMNAS DE RB0(COL0) A RB3(COL3))                   // 
.................... //               PINES DE FILAS DE RB4(ROW0)) A RB7(ROW3))                    //  
.................... //                  MODIF.: ING. FRANK GIRALDO - UD                       // 
.................... //////////////////////////////////////////////////////////////////////////////////// 
.................... /*//////////////////////////////////////////////////////////////////////////////////  
.................... *    RB0 RB1 RB2 RB3    
.................... *     |   |   |   | 
.................... *     c0  c1  c2  c3   
.................... *   | 1 | 2 | 3 | F | r0 - RB4 
.................... *   | 4 | 5 | 6 | E | r1 - RB5 
.................... *   | 7 | 8 | 9 | D | r2 - RB6 
.................... *   | A | 0 | B | C | r3 - RB7 
.................... * 
.................... *   COLUMNS=OUTs 
.................... *   ROWS=INs 
.................... *   SE HABILITAN PULL-UP INTERNAS  
.................... *   SE REQUIERE COLOCAR RESISTENCIAS (2.2K) EN LOS PINES DE COLUMNAS  
.................... * 
.................... */////////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... #byte portkbd = 0XF81                  //portkbd = portB 
.................... //Keypad connection:   (Column 0 es B0) 
.................... //                Bx: 
.................... #define COL0 (0 << 0) 
.................... #define COL1 (0 << 1) 
.................... #define COL2 (0 << 2) 
.................... #define COL3 (0 << 3) 
.................... #define ROW0 (1 << 4) 
.................... #define ROW1 (1 << 5) 
.................... #define ROW2 (1 << 6) 
.................... #define ROW3 (1 << 7) 
.................... #define ALL_ROWS (ROW3|ROW2|ROW1|ROW0) 
.................... #define ALL_PINS (ALL_ROWS|COL3|COL2|COL1|COL0) 
....................  
.................... char const KEYS[4][4] = {{'1','2','3','A'}, 
....................                          {'4','5','6','B'}, 
....................                          {'7','8','9','C'}, 
....................                          {'*','0','#','D'}}; 
....................  
.................... #define KBD_DEBOUNCE_FACTOR 0.2 
.................... // Modifique el valor de temporizacin antirrebote con (KBD_DEBOUNCE_FACTOR = n/333), 
.................... // en donde n es el nmero de veces por segundo en los que ud. invoca 
.................... //la funcin kbd_getc(). 
.................... // 
....................  
.................... void kbd_init(){ 
.................... } 
*
0698:  GOTO   0C9C (RETURN)
....................  
.................... char kbd_getc( ) 
.................... { 
....................    static BYTE kbd_call_count; 
....................    static short int kbd_down; 
....................    static char last_key; 
....................    static BYTE col; 
....................    BYTE kchar; 
....................    BYTE row; 
....................    port_b_pullups(TRUE); 
*
0858:  BCF    FF1.7
....................    kchar='\0'; 
085A:  CLRF   28
....................  
....................    if(++kbd_call_count>KBD_DEBOUNCE_FACTOR) 
085C:  INCF   0D,F
085E:  CLRF   2B
0860:  MOVFF  0D,2A
0864:  BRA    07A8
0866:  MOVLW  CD
0868:  MOVWF  2D
086A:  MOVLW  CC
086C:  MOVWF  2C
086E:  MOVLW  4C
0870:  MOVWF  2B
0872:  MOVLW  7C
0874:  MOVWF  2A
0876:  MOVFF  03,31
087A:  MOVFF  02,30
087E:  MOVFF  01,2F
0882:  MOVFF  00,2E
0886:  BRA    07E0
0888:  BNC   0940
....................    { 
....................        switch (col) 
....................        { 
088A:  MOVF   10,W
088C:  ADDLW  FC
088E:  BC    08BE
0890:  ADDLW  04
0892:  GOTO   094E
....................          case 0   : set_tris_b(ALL_PINS&~COL0); 
0896:  MOVLW  F0
0898:  MOVWF  F93
....................                     portkbd=(0b1110); 
089A:  MOVLW  0E
089C:  MOVWF  F81
....................                     break; 
089E:  BRA    08BE
....................  
....................          case 1   : set_tris_b(ALL_PINS&~COL1); 
08A0:  MOVLW  F0
08A2:  MOVWF  F93
....................                     portkbd=(0b1101); 
08A4:  MOVLW  0D
08A6:  MOVWF  F81
....................                     break; 
08A8:  BRA    08BE
....................  
....................          case 2   : set_tris_b(ALL_PINS&~COL2); 
08AA:  MOVLW  F0
08AC:  MOVWF  F93
....................                     portkbd=(0b1011); 
08AE:  MOVLW  0B
08B0:  MOVWF  F81
....................                     break; 
08B2:  BRA    08BE
....................  
....................          case 3   : set_tris_b(ALL_PINS&~COL3); 
08B4:  MOVLW  F0
08B6:  MOVWF  F93
....................                     portkbd=(0b0111); 
08B8:  MOVLW  07
08BA:  MOVWF  F81
....................                     break; 
08BC:  BRA    08BE
....................        } 
....................  
....................        if(kbd_down) 
08BE:  BTFSS  0E.0
08C0:  BRA    08D4
....................        { 
....................          if((portkbd & (ALL_ROWS))==(ALL_ROWS)) 
08C2:  MOVF   F81,W
08C4:  ANDLW  F0
08C6:  SUBLW  F0
08C8:  BNZ   08D2
....................          { 
....................            kbd_down=FALSE; 
08CA:  BCF    0E.0
....................            kchar=last_key; 
08CC:  MOVFF  0F,28
....................            last_key='\0'; 
08D0:  CLRF   0F
....................          } 
....................        } 
....................        else 
08D2:  BRA    093E
....................        { 
....................           if((portkbd & (ALL_ROWS))!=(ALL_ROWS)) 
08D4:  MOVF   F81,W
08D6:  ANDLW  F0
08D8:  SUBLW  F0
08DA:  BZ    0934
....................           { 
....................              if((portkbd & ROW0) == 0) 
08DC:  MOVF   F81,W
08DE:  ANDLW  10
08E0:  BNZ   08E6
....................                row = 0; 
08E2:  CLRF   29
....................              else if((portkbd & ROW1) == 0) 
08E4:  BRA    0908
08E6:  MOVF   F81,W
08E8:  ANDLW  20
08EA:  BNZ   08F2
....................                row = 1; 
08EC:  MOVLW  01
08EE:  MOVWF  29
....................              else if((portkbd & ROW2) == 0) 
08F0:  BRA    0908
08F2:  MOVF   F81,W
08F4:  ANDLW  40
08F6:  BNZ   08FE
....................                row = 2; 
08F8:  MOVLW  02
08FA:  MOVWF  29
....................              else if((portkbd & ROW3) == 0) 
08FC:  BRA    0908
08FE:  MOVF   F81,W
0900:  ANDLW  80
0902:  BNZ   0908
....................                row = 3; 
0904:  MOVLW  03
0906:  MOVWF  29
....................              last_key = KEYS[row][col]; 
0908:  MOVF   29,W
090A:  MULLW  04
090C:  MOVF   FF3,W
090E:  CLRF   2B
0910:  MOVWF  2A
0912:  CLRF   03
0914:  MOVF   10,W
0916:  ADDWF  2A,W
0918:  MOVWF  01
091A:  MOVF   2B,W
091C:  ADDWFC 03,F
091E:  MOVF   01,W
0920:  MOVFF  FF2,2A
0924:  BCF    FF2.7
0926:  CALL   0018
092A:  BTFSC  2A.7
092C:  BSF    FF2.7
092E:  MOVWF  0F
....................              kbd_down = TRUE; 
0930:  BSF    0E.0
....................           } 
....................           else 
0932:  BRA    093E
....................           { 
....................              ++col; 
0934:  INCF   10,F
....................              if(col==4) 
0936:  MOVF   10,W
0938:  SUBLW  04
093A:  BNZ   093E
....................              col=0; 
093C:  CLRF   10
....................           } 
....................        } 
....................       kbd_call_count=0; 
093E:  CLRF   0D
....................    } 
....................   kchar = last_key; 
0940:  MOVFF  0F,28
....................   set_tris_b(ALL_PINS); 
0944:  MOVLW  F0
0946:  MOVWF  F93
....................   return(kchar); 
0948:  MOVFF  28,01
.................... } 
094C:  RETLW  00
....................  
.................... /*char dato; 
.................... char tecla() 
.................... { 
....................    dato='\0'; 
....................    while(dato=='\0') 
....................    { 
....................       dato=kbd_getc(); 
....................       delay_ms(100); 
....................    } 
.................... return dato; 
.................... } */ 
....................  
.................... //#include <DS1307.c> 
.................... #ROM     0xf00000={0x4523}     //colocar 0 para usuario 1, estan al reves primero esta los dos digitos ultimos y luego los otros 
.................... #ROM     0xf00002={0x5634}     //esto es asignacion de claves para los usuarios 
.................... #define SW PIN A5 
.................... //Vamos a nombrar los registros de proposito GRAL 
.................... int i, b, dato, clave[4], datoi[4], adres,  dato1, dato2; 
.................... char datom; 
.................... float valor; 
.................... short flag; 
.................... long segundos, auxsegundos; 
.................... //long contador; 
....................  
.................... /************************** 
.................... SECCION DE METODOS 
.................... ************************/ 
....................  
.................... void teclado() 
.................... {  
....................     lcd_putc('\f'); 
*
0970:  MOVLW  0C
0972:  MOVWF  2A
0974:  RCALL  06F8
....................     segundos=0; 
0976:  CLRF   25
0978:  CLRF   24
....................     auxsegundos=0; 
097A:  CLRF   27
097C:  CLRF   26
....................     b=6; 
097E:  MOVLW  06
0980:  MOVWF  12
....................      for(i=0;i<4; i++) 
0982:  CLRF   11
0984:  MOVF   11,W
0986:  SUBLW  03
0988:  BTFSS  FD8.0
098A:  BRA    0B7A
....................       { 
....................         do{ 
....................             datom=kbd_getc(); // escanea teclado 
098C:  RCALL  0858
098E:  MOVFF  01,1F
....................             delay_ms(60); 
0992:  MOVLW  3C
0994:  MOVWF  2B
0996:  RCALL  0590
....................              if(datom!='\0')  //si hay dato valido 
0998:  MOVF   1F,F
099A:  BTFSC  FD8.2
099C:  BRA    0B1E
....................               { 
....................                  switch (i+1) 
....................                   { 
099E:  MOVLW  01
09A0:  ADDWF  11,W
09A2:  ADDLW  FF
09A4:  ADDLW  FC
09A6:  BTFSC  FD8.0
09A8:  BRA    0B06
09AA:  ADDLW  04
09AC:  GOTO   0B7C
....................                    case 1: 
....................                    lcd_gotoxy(6,1); 
09B0:  MOVLW  06
09B2:  MOVWF  2B
09B4:  MOVLW  01
09B6:  MOVWF  2C
09B8:  RCALL  069C
....................                    printf(lcd_putc,datom); 
09BA:  CLRF   FEA
09BC:  MOVFF  1F,FE9
09C0:  MOVLW  00
09C2:  IORWF  FEF,W
09C4:  BZ    09E4
09C6:  MOVFF  FEA,29
09CA:  MOVFF  FE9,28
09CE:  MOVFF  FEF,2A
09D2:  RCALL  06F8
09D4:  MOVFF  29,FEA
09D8:  MOVFF  28,FE9
09DC:  INCF   FE9,F
09DE:  BTFSC  FD8.2
09E0:  INCF   FEA,F
09E2:  BRA    09C0
....................                    clave[0]=datom-0X30; 
09E4:  MOVLW  30
09E6:  SUBWF  1F,W
09E8:  MOVWF  14
....................                    swap(clave[0]); 
09EA:  SWAPF  14,F
....................                    lcd_gotoxy(6,2); 
09EC:  MOVLW  06
09EE:  MOVWF  2B
09F0:  MOVLW  02
09F2:  MOVWF  2C
09F4:  RCALL  069C
....................                    printf(lcd_putc,"*"); 
09F6:  MOVLW  2A
09F8:  MOVWF  2A
09FA:  RCALL  06F8
....................                    delay_ms(50); 
09FC:  MOVLW  32
09FE:  MOVWF  2B
0A00:  RCALL  0590
....................                    break; 
0A02:  BRA    0B06
....................            
....................                    case 2: 
....................                    lcd_gotoxy(7,1); 
0A04:  MOVLW  07
0A06:  MOVWF  2B
0A08:  MOVLW  01
0A0A:  MOVWF  2C
0A0C:  RCALL  069C
....................                    printf(lcd_putc,datom); 
0A0E:  CLRF   FEA
0A10:  MOVFF  1F,FE9
0A14:  MOVLW  00
0A16:  IORWF  FEF,W
0A18:  BZ    0A38
0A1A:  MOVFF  FEA,29
0A1E:  MOVFF  FE9,28
0A22:  MOVFF  FEF,2A
0A26:  RCALL  06F8
0A28:  MOVFF  29,FEA
0A2C:  MOVFF  28,FE9
0A30:  INCF   FE9,F
0A32:  BTFSC  FD8.2
0A34:  INCF   FEA,F
0A36:  BRA    0A14
....................                    clave[1]=datom-0X30; 
0A38:  MOVLW  30
0A3A:  SUBWF  1F,W
0A3C:  MOVWF  15
....................                    clave[0]=clave[0]+clave[1]; 
0A3E:  MOVF   15,W
0A40:  ADDWF  14,F
....................                    lcd_gotoxy(7,2); 
0A42:  MOVLW  07
0A44:  MOVWF  2B
0A46:  MOVLW  02
0A48:  MOVWF  2C
0A4A:  RCALL  069C
....................                    printf(lcd_putc,"*"); 
0A4C:  MOVLW  2A
0A4E:  MOVWF  2A
0A50:  RCALL  06F8
....................                    delay_ms(50); 
0A52:  MOVLW  32
0A54:  MOVWF  2B
0A56:  RCALL  0590
....................                    break; 
0A58:  BRA    0B06
....................               
....................                    case 3: 
....................                    lcd_gotoxy(8,1); 
0A5A:  MOVLW  08
0A5C:  MOVWF  2B
0A5E:  MOVLW  01
0A60:  MOVWF  2C
0A62:  RCALL  069C
....................                    printf(lcd_putc,datom); 
0A64:  CLRF   FEA
0A66:  MOVFF  1F,FE9
0A6A:  MOVLW  00
0A6C:  IORWF  FEF,W
0A6E:  BZ    0A8E
0A70:  MOVFF  FEA,29
0A74:  MOVFF  FE9,28
0A78:  MOVFF  FEF,2A
0A7C:  RCALL  06F8
0A7E:  MOVFF  29,FEA
0A82:  MOVFF  28,FE9
0A86:  INCF   FE9,F
0A88:  BTFSC  FD8.2
0A8A:  INCF   FEA,F
0A8C:  BRA    0A6A
....................                    clave[2]=datom-0X30; 
0A8E:  MOVLW  30
0A90:  SUBWF  1F,W
0A92:  MOVWF  16
....................                    swap(clave[2]); 
0A94:  SWAPF  16,F
....................                    lcd_gotoxy(8,2); 
0A96:  MOVLW  08
0A98:  MOVWF  2B
0A9A:  MOVLW  02
0A9C:  MOVWF  2C
0A9E:  RCALL  069C
....................                    printf(lcd_putc,"*"); 
0AA0:  MOVLW  2A
0AA2:  MOVWF  2A
0AA4:  RCALL  06F8
....................                    delay_ms(50); 
0AA6:  MOVLW  32
0AA8:  MOVWF  2B
0AAA:  RCALL  0590
....................                    break; 
0AAC:  BRA    0B06
....................               
....................                    case 4: 
....................                    lcd_gotoxy(9,1); 
0AAE:  MOVLW  09
0AB0:  MOVWF  2B
0AB2:  MOVLW  01
0AB4:  MOVWF  2C
0AB6:  RCALL  069C
....................                    printf(lcd_putc,datom); 
0AB8:  CLRF   FEA
0ABA:  MOVFF  1F,FE9
0ABE:  MOVLW  00
0AC0:  IORWF  FEF,W
0AC2:  BZ    0AE2
0AC4:  MOVFF  FEA,29
0AC8:  MOVFF  FE9,28
0ACC:  MOVFF  FEF,2A
0AD0:  RCALL  06F8
0AD2:  MOVFF  29,FEA
0AD6:  MOVFF  28,FE9
0ADA:  INCF   FE9,F
0ADC:  BTFSC  FD8.2
0ADE:  INCF   FEA,F
0AE0:  BRA    0ABE
....................                    clave[3]=datom-0X30; 
0AE2:  MOVLW  30
0AE4:  SUBWF  1F,W
0AE6:  MOVWF  17
....................                    clave[1]=clave[2]+clave[3]; 
0AE8:  MOVF   17,W
0AEA:  ADDWF  16,W
0AEC:  MOVWF  15
....................                    lcd_gotoxy(9,2); 
0AEE:  MOVLW  09
0AF0:  MOVWF  2B
0AF2:  MOVLW  02
0AF4:  MOVWF  2C
0AF6:  RCALL  069C
....................                    printf(lcd_putc,"*"); 
0AF8:  MOVLW  2A
0AFA:  MOVWF  2A
0AFC:  RCALL  06F8
....................                    delay_ms(50); 
0AFE:  MOVLW  32
0B00:  MOVWF  2B
0B02:  RCALL  0590
....................                    break; 
0B04:  BRA    0B06
....................                  }  
....................                   i++; 
0B06:  INCF   11,F
....................                   delay_ms(500); 
0B08:  MOVLW  02
0B0A:  MOVWF  28
0B0C:  MOVLW  FA
0B0E:  MOVWF  2B
0B10:  RCALL  0590
0B12:  DECFSZ 28,F
0B14:  BRA    0B0C
....................                   auxsegundos=0; 
0B16:  CLRF   27
0B18:  CLRF   26
....................                   segundos=0; 
0B1A:  CLRF   25
0B1C:  CLRF   24
....................            } 
....................            auxsegundos++; 
0B1E:  INCF   26,F
0B20:  BTFSC  FD8.2
0B22:  INCF   27,F
....................            if(auxsegundos > 20) 
0B24:  MOVF   27,F
0B26:  BNZ   0B2E
0B28:  MOVF   26,W
0B2A:  SUBLW  14
0B2C:  BC    0B38
....................             { 
....................               segundos++; 
0B2E:  INCF   24,F
0B30:  BTFSC  FD8.2
0B32:  INCF   25,F
....................               auxsegundos=0; 
0B34:  CLRF   27
0B36:  CLRF   26
....................             } 
....................          
....................       
....................     
....................     }while(i<4 && segundos<6); 
0B38:  MOVF   11,W
0B3A:  SUBLW  03
0B3C:  BNC   0B4A
0B3E:  MOVF   25,F
0B40:  BNZ   0B4A
0B42:  MOVF   24,W
0B44:  SUBLW  05
0B46:  BTFSC  FD8.0
0B48:  BRA    098C
....................       clave[i]='#'; 
0B4A:  CLRF   03
0B4C:  MOVF   11,W
0B4E:  ADDLW  14
0B50:  MOVWF  FE9
0B52:  MOVLW  00
0B54:  ADDWFC 03,W
0B56:  MOVWF  FEA
0B58:  MOVLW  23
0B5A:  MOVWF  FEF
....................       lcd_gotoxy(b,1); 
0B5C:  MOVFF  12,2B
0B60:  MOVLW  01
0B62:  MOVWF  2C
0B64:  RCALL  069C
....................       printf(lcd_putc,"*") ; 
0B66:  MOVLW  2A
0B68:  MOVWF  2A
0B6A:  RCALL  06F8
....................       b++; 
0B6C:  INCF   12,F
....................       auxsegundos=0; 
0B6E:  CLRF   27
0B70:  CLRF   26
....................       segundos=0; 
0B72:  CLRF   25
0B74:  CLRF   24
....................    } 
0B76:  INCF   11,F
0B78:  BRA    0984
.................... } 
0B7A:  RETLW  00
....................  
....................  
.................... void un_digito() 
.................... { lcd_putc('\f'); 
*
0B9E:  MOVLW  0C
0BA0:  MOVWF  2A
0BA2:  RCALL  06F8
....................   segundos=0; 
0BA4:  CLRF   25
0BA6:  CLRF   24
....................   auxsegundos=0; 
0BA8:  CLRF   27
0BAA:  CLRF   26
....................   flag=false; 
0BAC:  BCF    0E.1
....................   do{ 
....................       datom=kbd_getc(); 
0BAE:  RCALL  0858
0BB0:  MOVFF  01,1F
....................       delay_ms(60); 
0BB4:  MOVLW  3C
0BB6:  MOVWF  2B
0BB8:  RCALL  0590
....................       if(datom !='\0') 
0BBA:  MOVF   1F,F
0BBC:  BZ    0BD6
....................         { 
....................           lcd_gotoxy(8,1);       //coloque el numero digitado  en posicion del LCD 
0BBE:  MOVLW  08
0BC0:  MOVWF  2B
0BC2:  MOVLW  01
0BC4:  MOVWF  2C
0BC6:  RCALL  069C
....................           lcd_putc(datom);       //visualice datom 
0BC8:  MOVFF  1F,2A
0BCC:  RCALL  06F8
....................           datom=datom-0x30;      //quitele ASCII 
0BCE:  MOVLW  30
0BD0:  SUBWF  1F,F
....................           flag=true; 
0BD2:  BSF    0E.1
....................            
....................         }else { 
0BD4:  BRA    0BF0
....................                auxsegundos++; 
0BD6:  INCF   26,F
0BD8:  BTFSC  FD8.2
0BDA:  INCF   27,F
....................                if(auxsegundos>20) 
0BDC:  MOVF   27,F
0BDE:  BNZ   0BE6
0BE0:  MOVF   26,W
0BE2:  SUBLW  14
0BE4:  BC    0BF0
....................                { 
....................                  segundos++; 
0BE6:  INCF   24,F
0BE8:  BTFSC  FD8.2
0BEA:  INCF   25,F
....................                  auxsegundos=0; 
0BEC:  CLRF   27
0BEE:  CLRF   26
....................                 } 
....................        } 
....................          
....................   }while(segundos<6 && flag==false ); 
0BF0:  MOVF   25,F
0BF2:  BNZ   0BFE
0BF4:  MOVF   24,W
0BF6:  SUBLW  05
0BF8:  BNC   0BFE
0BFA:  BTFSS  0E.1
0BFC:  BRA    0BAE
.................... } 
0BFE:  RETLW  00
....................  
.................... void escribir_memoria() 
.................... { 
....................   for(i=0; i<2; i++) 
0C00:  CLRF   11
0C02:  MOVF   11,W
0C04:  SUBLW  01
0C06:  BNC   0C52
....................   {  write_eeprom(adres, clave[i]); 
0C08:  CLRF   03
0C0A:  MOVF   11,W
0C0C:  ADDLW  14
0C0E:  MOVWF  FE9
0C10:  MOVLW  00
0C12:  ADDWFC 03,W
0C14:  MOVWF  FEA
0C16:  MOVFF  FEF,28
0C1A:  MOVFF  1C,FA9
0C1E:  MOVFF  28,FA8
0C22:  BCF    FA6.6
0C24:  BCF    FA6.7
0C26:  BSF    FA6.2
0C28:  MOVFF  FF2,00
0C2C:  BCF    FF2.7
0C2E:  MOVLB  F
0C30:  MOVLW  55
0C32:  MOVWF  FA7
0C34:  MOVLW  AA
0C36:  MOVWF  FA7
0C38:  BSF    FA6.1
0C3A:  BTFSC  FA6.1
0C3C:  BRA    0C3A
0C3E:  BCF    FA6.2
0C40:  MOVF   00,W
0C42:  IORWF  FF2,F
....................      delay_ms(5); 
0C44:  MOVLW  05
0C46:  MOVWF  2B
0C48:  MOVLB  0
0C4A:  RCALL  0590
....................      adres++; 
0C4C:  INCF   1C,F
....................   } 
0C4E:  INCF   11,F
0C50:  BRA    0C02
.................... } 
0C52:  RETLW  00
....................  
.................... void leer() 
.................... { 
....................   for(i=0; i<4; i++) 
*
076C:  CLRF   11
076E:  MOVF   11,W
0770:  SUBLW  03
0772:  BNC   07A4
....................   { 
....................     datoi[i]=read_eeprom(i); 
0774:  CLRF   03
0776:  MOVF   11,W
0778:  ADDLW  18
077A:  MOVWF  FE9
077C:  MOVLW  00
077E:  ADDWFC 03,W
0780:  MOVWF  FEA
0782:  MOVFF  FF2,2A
0786:  BCF    FF2.7
0788:  MOVFF  11,FA9
078C:  BCF    FA6.6
078E:  BCF    FA6.7
0790:  BSF    FA6.0
0792:  MOVF   FA8,W
0794:  BTFSC  2A.7
0796:  BSF    FF2.7
0798:  MOVWF  FEF
....................     delay_ms(1); 
079A:  MOVLW  01
079C:  MOVWF  2B
079E:  RCALL  0590
....................   } 
07A0:  INCF   11,F
07A2:  BRA    076E
.................... } 
07A4:  GOTO   0DE6 (RETURN)
....................  
....................  
....................    
.................... /************************** 
.................... PROGRAMA PRINCIPAL 
.................... ************************/   
....................  
.................... void main() 
.................... {#zero_ram 
*
0C54:  CLRF   FF8
0C56:  BCF    FD0.7
0C58:  MOVLW  FE
0C5A:  MOVWF  00
0C5C:  MOVLW  08
0C5E:  MOVWF  01
0C60:  MOVLW  02
0C62:  MOVWF  FE9
0C64:  MOVLW  00
0C66:  MOVWF  FEA
0C68:  CLRF   FEE
0C6A:  DECFSZ 00,F
0C6C:  BRA    0C68
0C6E:  DECFSZ 01,F
0C70:  BRA    0C68
0C72:  CLRF   FEA
0C74:  CLRF   FE9
0C76:  MOVF   FC1,W
0C78:  ANDLW  C0
0C7A:  IORLW  0F
0C7C:  MOVWF  FC1
0C7E:  MOVLW  07
0C80:  MOVWF  FB4
0C82:  CLRF   05
0C84:  CLRF   06
0C86:  CLRF   0D
0C88:  BCF    0E.0
0C8A:  CLRF   0F
0C8C:  CLRF   10
.................... inicio:                       //etiquetas siempre a la izquierda 
....................     set_tris_A(0x28);         /*0010 1000 EL 28 SALE ES DIVIDIENDO LOS 8BITS EN 4 DIGITOS Y TOMAR A QUE NUMERO CORRESPONCEN 
0C8E:  MOVLW  28
0C90:  MOVWF  F92
....................     RA0 PIN 2  FREE 
....................     RA1 PIN 3  FREE 
....................     RA2 PIN 4  FREE 
....................     RA3 PIN 5  FREE 
....................     RA4 PIN 6  FREE 
....................     RA5 PIN 7  FREE 
....................     RA6 PIN 14 FREE 
....................     RA7 NO EXISTE */ 
....................      
....................     set_tris_B(0x00); /*0000 0000 EL 28 SALE ES DIVIDIENDO LOS 8BITS EN 4 DIGITOS Y TOMAR A QUE NUMERO CORRESPONCEN 
0C92:  MOVLW  00
0C94:  MOVWF  F93
....................     RB0 PIN 33  LED1 
....................     RB1 PIN 34  LED2 
....................     RB2 PIN 35  LED4 
....................     RB3 PIN 36  LED5 
....................     RB4 PIN 37  LED6 
....................     RB5 PIN 38  LED7 
....................     RB6 PIN 39  LED8 
....................     RB7 PIN 40  LED8 */ 
....................      
....................     set_tris_D(0x00); /*0000 0000 EL 28 SALE ES DIVIDIENDO LOS 8BITS EN 4 DIGITOS Y TOMAR A QUE NUMERO CORRESPONCEN 
0C96:  MOVWF  F95
....................     RB0 PIN 33  LED1 
....................     RB1 PIN 34  LED2 
....................     RB2 PIN 35  LED4 
....................     RB3 PIN 36  LED5 
....................     RB4 PIN 37  LED6 
....................     RB5 PIN 38  LED7 
....................     RB6 PIN 39  LED8 
....................     RB7 PIN 40  LED8 */ 
....................      
....................     lcd_init(); 
0C98:  BRA    0638
....................     kbd_init(); 
0C9A:  BRA    0698
....................     output_A(0x00);                            //Limpiar el puerto A 
0C9C:  CLRF   F92
0C9E:  CLRF   F89
....................     output_B(0x00);                           //Limipiar el puerto B 
0CA0:  CLRF   F93
0CA2:  CLRF   F8A
....................     output_D(0x00);                           //Limipiar el puerto D 
0CA4:  CLRF   F95
0CA6:  CLRF   F8C
....................     
.................... menu: 
....................    lcd_putc('\f');                            //Limpiar pantalla comando 
0CA8:  MOVLW  0C
0CAA:  MOVWF  2A
0CAC:  RCALL  06F8
....................    lcd_gotoxy(1,1);                           //escribir en a primera fila primera posicion  
0CAE:  MOVLW  01
0CB0:  MOVWF  2B
0CB2:  MOVWF  2C
0CB4:  RCALL  069C
....................    lcd_putc("   BIENVENIDOS  ");              //lo que se escribe 
0CB6:  CLRF   28
0CB8:  MOVF   28,W
0CBA:  CALL   0038
0CBE:  IORLW  00
0CC0:  BZ    0CCA
0CC2:  INCF   28,F
0CC4:  MOVWF  2A
0CC6:  RCALL  06F8
0CC8:  BRA    0CB8
....................    lcd_gotoxy(1,2);                           //escribir en a primera fila primera posicion  
0CCA:  MOVLW  01
0CCC:  MOVWF  2B
0CCE:  MOVLW  02
0CD0:  MOVWF  2C
0CD2:  RCALL  069C
....................    lcd_putc("ARQ. COMP. TARDE"); 
0CD4:  CLRF   28
0CD6:  MOVF   28,W
0CD8:  CALL   005A
0CDC:  IORLW  00
0CDE:  BZ    0CE8
0CE0:  INCF   28,F
0CE2:  MOVWF  2A
0CE4:  RCALL  06F8
0CE6:  BRA    0CD6
....................    delay_ms(3000); 
0CE8:  MOVLW  0C
0CEA:  MOVWF  28
0CEC:  MOVLW  FA
0CEE:  MOVWF  2B
0CF0:  RCALL  0590
0CF2:  DECFSZ 28,F
0CF4:  BRA    0CEC
....................     
....................    lcd_putc('\f');                            //Limpiar pantalla comando 
0CF6:  MOVLW  0C
0CF8:  MOVWF  2A
0CFA:  RCALL  06F8
....................    lcd_gotoxy(1,1);                           //escribir en a primera fila primera posicion  
0CFC:  MOVLW  01
0CFE:  MOVWF  2B
0D00:  MOVWF  2C
0D02:  RCALL  069C
....................    lcd_putc("MIGUEL MENDEZ");                 //lo que se escribe 
0D04:  CLRF   28
0D06:  MOVF   28,W
0D08:  CALL   007C
0D0C:  IORLW  00
0D0E:  BZ    0D18
0D10:  INCF   28,F
0D12:  MOVWF  2A
0D14:  RCALL  06F8
0D16:  BRA    0D06
....................    lcd_gotoxy(1,2);                           //escribir en a primera fila primera posicion  
0D18:  MOVLW  01
0D1A:  MOVWF  2B
0D1C:  MOVLW  02
0D1E:  MOVWF  2C
0D20:  RCALL  069C
....................    lcd_putc(" DAVID MARTINEZ "); 
0D22:  CLRF   28
0D24:  MOVF   28,W
0D26:  CALL   009A
0D2A:  IORLW  00
0D2C:  BZ    0D36
0D2E:  INCF   28,F
0D30:  MOVWF  2A
0D32:  RCALL  06F8
0D34:  BRA    0D24
....................    //printf(lcd_putc,"\f   MIGUEL MENDEZ\n DAVID MARTINEZ ");// /n pase a sigueinet linea 
....................    delay_ms(3000); 
0D36:  MOVLW  0C
0D38:  MOVWF  28
0D3A:  MOVLW  FA
0D3C:  MOVWF  2B
0D3E:  RCALL  0590
0D40:  DECFSZ 28,F
0D42:  BRA    0D3A
....................     
....................    lcd_putc('\f');                           //Limpiar pantalla comando 
0D44:  MOVLW  0C
0D46:  MOVWF  2A
0D48:  RCALL  06F8
....................    lcd_gotoxy(3,1);                          //escribir en a primera fila primera posicion  
0D4A:  MOVLW  03
0D4C:  MOVWF  2B
0D4E:  MOVLW  01
0D50:  MOVWF  2C
0D52:  RCALL  069C
....................    lcd_putc("GRUPO");                        //lo que se escribe 
0D54:  CLRF   28
0D56:  MOVF   28,W
0D58:  CALL   00BC
0D5C:  IORLW  00
0D5E:  BZ    0D68
0D60:  INCF   28,F
0D62:  MOVWF  2A
0D64:  RCALL  06F8
0D66:  BRA    0D56
....................    lcd_gotoxy(2,2);                          //escribir en a primera fila primera posicion  
0D68:  MOVLW  02
0D6A:  MOVWF  2B
0D6C:  MOVWF  2C
0D6E:  RCALL  069C
....................    lcd_putc(" NUMERO"); 
0D70:  CLRF   28
0D72:  MOVF   28,W
0D74:  CALL   00D2
0D78:  IORLW  00
0D7A:  BZ    0D84
0D7C:  INCF   28,F
0D7E:  MOVWF  2A
0D80:  RCALL  06F8
0D82:  BRA    0D72
....................    //printf(lcd_putc,"\f        GRUPO   \n       NUMERO    ");// /n pase a sigueinet linea 
....................    delay_ms(3000); 
0D84:  MOVLW  0C
0D86:  MOVWF  28
0D88:  MOVLW  FA
0D8A:  MOVWF  2B
0D8C:  RCALL  0590
0D8E:  DECFSZ 28,F
0D90:  BRA    0D88
....................     
....................    lcd_putc('\f');                          //Limpiar pantalla comando 
0D92:  MOVLW  0C
0D94:  MOVWF  2A
0D96:  RCALL  06F8
....................    lcd_gotoxy(2,1);                         //escribir en a primera fila primera posicion  
0D98:  MOVLW  02
0D9A:  MOVWF  2B
0D9C:  MOVLW  01
0D9E:  MOVWF  2C
0DA0:  RCALL  069C
....................    lcd_putc("POR FAVOR");                   //lo que se escribe 
0DA2:  CLRF   28
0DA4:  MOVF   28,W
0DA6:  CALL   00EA
0DAA:  IORLW  00
0DAC:  BZ    0DB6
0DAE:  INCF   28,F
0DB0:  MOVWF  2A
0DB2:  RCALL  06F8
0DB4:  BRA    0DA4
....................    lcd_gotoxy(1,2);                         //escribir en a primera fila primera posicion  
0DB6:  MOVLW  01
0DB8:  MOVWF  2B
0DBA:  MOVLW  02
0DBC:  MOVWF  2C
0DBE:  RCALL  069C
....................    lcd_putc("INGRESE CLAVE"); 
0DC0:  CLRF   28
0DC2:  MOVF   28,W
0DC4:  CALL   0104
0DC8:  IORLW  00
0DCA:  BZ    0DD4
0DCC:  INCF   28,F
0DCE:  MOVWF  2A
0DD0:  RCALL  06F8
0DD2:  BRA    0DC2
....................    //printf(lcd_putc,"\f    POR FAVOR   \n INGRESE CLAVE");// /n pase a sigueinet linea 
....................    delay_ms(3000); 
0DD4:  MOVLW  0C
0DD6:  MOVWF  28
0DD8:  MOVLW  FA
0DDA:  MOVWF  2B
0DDC:  CALL   0590
0DE0:  DECFSZ 28,F
0DE2:  BRA    0DD8
....................     
....................     
....................     
....................       leer();                                  //datoi[0]= clave que le demos datoi[1]=clave que le demos 
0DE4:  BRA    076C
....................       teclado();                               //clave [0]=0x34, clave[1]=0x78 
0DE6:  RCALL  0970
....................        
....................   if(clave[0]==0x12 & clave[1]==0x34) 
0DE8:  MOVF   14,W
0DEA:  SUBLW  12
0DEC:  BZ    0DF2
0DEE:  MOVLW  00
0DF0:  BRA    0DF4
0DF2:  MOVLW  01
0DF4:  MOVWF  28
0DF6:  MOVF   15,W
0DF8:  SUBLW  34
0DFA:  BZ    0E00
0DFC:  MOVLW  00
0DFE:  BRA    0E02
0E00:  MOVLW  01
0E02:  ANDWF  28,W
0E04:  BTFSC  FD8.2
0E06:  BRA    0FB0
....................    { 
.................... admin:  
....................       lcd_putc('\f');                          //Limpiar pantalla comando 
0E08:  MOVLW  0C
0E0A:  MOVWF  2A
0E0C:  RCALL  06F8
....................       lcd_gotoxy(1,1);                         //escribir en a primera fila primera posicion  
0E0E:  MOVLW  01
0E10:  MOVWF  2B
0E12:  MOVWF  2C
0E14:  RCALL  069C
....................       lcd_putc("BIENVENIDOS AL");              //lo que se escribe 
0E16:  CLRF   28
0E18:  MOVF   28,W
0E1A:  CALL   0122
0E1E:  IORLW  00
0E20:  BZ    0E2A
0E22:  INCF   28,F
0E24:  MOVWF  2A
0E26:  RCALL  06F8
0E28:  BRA    0E18
....................       lcd_gotoxy(4,2);                         //escribir en a primera fila primera posicion  
0E2A:  MOVLW  04
0E2C:  MOVWF  2B
0E2E:  MOVLW  02
0E30:  MOVWF  2C
0E32:  RCALL  069C
....................       lcd_putc(" MENU"); 
0E34:  CLRF   28
0E36:  MOVF   28,W
0E38:  CALL   0142
0E3C:  IORLW  00
0E3E:  BZ    0E48
0E40:  INCF   28,F
0E42:  MOVWF  2A
0E44:  RCALL  06F8
0E46:  BRA    0E36
....................       //printf(lcd_putc,"\f    POR FAVOR   \n INGRESE CLAVE");// /n pase a sigueinet linea 
....................       delay_ms(3000); 
0E48:  MOVLW  0C
0E4A:  MOVWF  28
0E4C:  MOVLW  FA
0E4E:  MOVWF  2B
0E50:  CALL   0590
0E54:  DECFSZ 28,F
0E56:  BRA    0E4C
....................       
....................       lcd_putc('\f');                         //Limpiar pantalla comando 
0E58:  MOVLW  0C
0E5A:  MOVWF  2A
0E5C:  RCALL  06F8
....................       lcd_gotoxy(1,1);                        //escribir en a primera fila primera posicion  
0E5E:  MOVLW  01
0E60:  MOVWF  2B
0E62:  MOVWF  2C
0E64:  RCALL  069C
....................       lcd_putc("MARQUE 1 PARA EL");           //lo que se escribe 
0E66:  CLRF   28
0E68:  MOVF   28,W
0E6A:  CALL   0158
0E6E:  IORLW  00
0E70:  BZ    0E7A
0E72:  INCF   28,F
0E74:  MOVWF  2A
0E76:  RCALL  06F8
0E78:  BRA    0E68
....................       lcd_gotoxy(1,2);                        //escribir en a primera fila primera posicion  
0E7A:  MOVLW  01
0E7C:  MOVWF  2B
0E7E:  MOVLW  02
0E80:  MOVWF  2C
0E82:  RCALL  069C
....................       lcd_putc("MENU DE DAVID"); 
0E84:  CLRF   28
0E86:  MOVF   28,W
0E88:  CALL   017A
0E8C:  IORLW  00
0E8E:  BZ    0E98
0E90:  INCF   28,F
0E92:  MOVWF  2A
0E94:  RCALL  06F8
0E96:  BRA    0E86
....................       //printf(lcd_putc,"\f    POR FAVOR   \n INGRESE CLAVE");// /n pase a sigueinet linea 
....................       delay_ms(3000); 
0E98:  MOVLW  0C
0E9A:  MOVWF  28
0E9C:  MOVLW  FA
0E9E:  MOVWF  2B
0EA0:  CALL   0590
0EA4:  DECFSZ 28,F
0EA6:  BRA    0E9C
....................     
....................       lcd_putc('\f');                         //Limpiar pantalla comando 
0EA8:  MOVLW  0C
0EAA:  MOVWF  2A
0EAC:  RCALL  06F8
....................       lcd_gotoxy(1,1);                        //escribir en a primera fila primera posicion  
0EAE:  MOVLW  01
0EB0:  MOVWF  2B
0EB2:  MOVWF  2C
0EB4:  CALL   069C
....................       lcd_putc("MARQUE 2 PARA EL");           //lo que se escribe 
0EB8:  CLRF   28
0EBA:  MOVF   28,W
0EBC:  CALL   0198
0EC0:  IORLW  00
0EC2:  BZ    0ECC
0EC4:  INCF   28,F
0EC6:  MOVWF  2A
0EC8:  RCALL  06F8
0ECA:  BRA    0EBA
....................       lcd_gotoxy(1,2);                        //escribir en a primera fila primera posicion  
0ECC:  MOVLW  01
0ECE:  MOVWF  2B
0ED0:  MOVLW  02
0ED2:  MOVWF  2C
0ED4:  CALL   069C
....................       lcd_putc("MENU DE MIGUEL"); 
0ED8:  CLRF   28
0EDA:  MOVF   28,W
0EDC:  CALL   01BA
0EE0:  IORLW  00
0EE2:  BZ    0EEC
0EE4:  INCF   28,F
0EE6:  MOVWF  2A
0EE8:  RCALL  06F8
0EEA:  BRA    0EDA
....................       //printf(lcd_putc,"\f    POR FAVOR   \n INGRESE CLAVE");// /n pase a sigueinet linea 
....................       delay_ms(3000); 
0EEC:  MOVLW  0C
0EEE:  MOVWF  28
0EF0:  MOVLW  FA
0EF2:  MOVWF  2B
0EF4:  CALL   0590
0EF8:  DECFSZ 28,F
0EFA:  BRA    0EF0
....................      
....................       lcd_putc('\f');                         //Limpiar pantalla comando 
0EFC:  MOVLW  0C
0EFE:  MOVWF  2A
0F00:  CALL   06F8
....................       lcd_gotoxy(1,1);                        //escribir en a primera fila primera posicion  
0F04:  MOVLW  01
0F06:  MOVWF  2B
0F08:  MOVWF  2C
0F0A:  CALL   069C
....................       lcd_putc("MARQUE 3 PARA ");             //lo que se escribe 
0F0E:  CLRF   28
0F10:  MOVF   28,W
0F12:  CALL   01DA
0F16:  IORLW  00
0F18:  BZ    0F24
0F1A:  INCF   28,F
0F1C:  MOVWF  2A
0F1E:  CALL   06F8
0F22:  BRA    0F10
....................       lcd_gotoxy(1,2);                        //escribir en a primera fila primera posicion  
0F24:  MOVLW  01
0F26:  MOVWF  2B
0F28:  MOVLW  02
0F2A:  MOVWF  2C
0F2C:  CALL   069C
....................       lcd_putc("SALIR"); 
0F30:  CLRF   28
0F32:  MOVF   28,W
0F34:  CALL   01FA
0F38:  IORLW  00
0F3A:  BZ    0F46
0F3C:  INCF   28,F
0F3E:  MOVWF  2A
0F40:  CALL   06F8
0F44:  BRA    0F32
....................       //printf(lcd_putc,"\f    POR FAVOR   \n INGRESE CLAVE");// /n pase a sigueinet linea 
....................       delay_ms(3000); 
0F46:  MOVLW  0C
0F48:  MOVWF  28
0F4A:  MOVLW  FA
0F4C:  MOVWF  2B
0F4E:  CALL   0590
0F52:  DECFSZ 28,F
0F54:  BRA    0F4A
....................     
....................     
....................        //bienvenidos al menu del diseador 
....................        //marque 1 para menu de MIGUEL 
....................        //marque 2 para menu de David 
....................        //marque 3 salir  */ 
....................         
....................         
....................      un_digito(); 
0F56:  RCALL  0B9E
....................     if(datom==0x01) 
0F58:  DECFSZ 1F,W
0F5A:  BRA    0F60
....................      { 
....................         goto David; 
0F5C:  GOTO   16A0
....................      } 
....................      if(datom==0x02) 
0F60:  MOVF   1F,W
0F62:  SUBLW  02
0F64:  BNZ   0F68
....................      { 
....................         goto Miguel; 
0F66:  BRA    0FD0
....................      } 
....................      if(datom==0x03) 
0F68:  MOVF   1F,W
0F6A:  SUBLW  03
0F6C:  BNZ   0F70
....................      { 
....................         reset_cpu();  //salir 
0F6E:  RESET
....................      } 
....................      lcd_putc('\f');                        //Limpiar pantalla comando 
0F70:  MOVLW  0C
0F72:  MOVWF  2A
0F74:  CALL   06F8
....................      lcd_gotoxy(1,2);                       //escribir en a primera fila primera posicion  
0F78:  MOVLW  01
0F7A:  MOVWF  2B
0F7C:  MOVLW  02
0F7E:  MOVWF  2C
0F80:  CALL   069C
....................      lcd_putc("ERROR DE NUMERO");           //lo que se escribe 
0F84:  CLRF   28
0F86:  MOVF   28,W
0F88:  CALL   0210
0F8C:  IORLW  00
0F8E:  BZ    0F9A
0F90:  INCF   28,F
0F92:  MOVWF  2A
0F94:  CALL   06F8
0F98:  BRA    0F86
....................      delay_ms(3000); 
0F9A:  MOVLW  0C
0F9C:  MOVWF  28
0F9E:  MOVLW  FA
0FA0:  MOVWF  2B
0FA2:  CALL   0590
0FA6:  DECFSZ 28,F
0FA8:  BRA    0F9E
....................      goto admin; 
0FAA:  BRA    0E08
....................      }  
....................      else if(clave[0]==datoi[1] & clave[1]==datoi[0]) 
0FAC:  GOTO   1D8E
0FB0:  MOVF   19,W
0FB2:  SUBWF  14,W
0FB4:  BZ    0FBA
0FB6:  MOVLW  00
0FB8:  BRA    0FBC
0FBA:  MOVLW  01
0FBC:  MOVWF  28
0FBE:  MOVF   18,W
0FC0:  SUBWF  15,W
0FC2:  BZ    0FC8
0FC4:  MOVLW  00
0FC6:  BRA    0FCA
0FC8:  MOVLW  01
0FCA:  ANDWF  28,W
0FCC:  BTFSC  FD8.2
0FCE:  BRA    1680
....................       { 
.................... Miguel:adres=0x00; 
0FD0:  CLRF   1C
....................        /*escribirle al lcd 
....................        bienvenidos al menu del diseador 
....................        marque 1 para cambiar clave 
....................        marque 2 para fecha y hora 
....................        marque 3 para reportes 
....................        marque 4 para motor paso a paso 
....................        marque 5 para servomotor 
....................        marque 6 para cad 
....................        marque 7 para DTMF 
....................        marque 8 para sensores 
....................        marque 9 para salir*/ 
....................       
....................     lcd_putc('\f');                       //Limpiar pantalla comando 
0FD2:  MOVLW  0C
0FD4:  MOVWF  2A
0FD6:  CALL   06F8
....................     lcd_gotoxy(1,1);                      //escribir en a primera fila primera posicion  
0FDA:  MOVLW  01
0FDC:  MOVWF  2B
0FDE:  MOVWF  2C
0FE0:  CALL   069C
....................     lcd_putc("MENU USUAR.");              //lo que se escribe 
0FE4:  CLRF   28
0FE6:  MOVF   28,W
0FE8:  CALL   0230
0FEC:  IORLW  00
0FEE:  BZ    0FFA
0FF0:  INCF   28,F
0FF2:  MOVWF  2A
0FF4:  CALL   06F8
0FF8:  BRA    0FE6
....................     lcd_gotoxy(1,2);                      //escribir en a primera fila primera posicion  
0FFA:  MOVLW  01
0FFC:  MOVWF  2B
0FFE:  MOVLW  02
1000:  MOVWF  2C
1002:  CALL   069C
....................     lcd_putc("MIGUEL"); 
1006:  CLRF   28
1008:  MOVF   28,W
100A:  CALL   024C
100E:  IORLW  00
1010:  BZ    101C
1012:  INCF   28,F
1014:  MOVWF  2A
1016:  CALL   06F8
101A:  BRA    1008
....................     delay_ms(3000);  
101C:  MOVLW  0C
101E:  MOVWF  28
1020:  MOVLW  FA
1022:  MOVWF  2B
1024:  CALL   0590
1028:  DECFSZ 28,F
102A:  BRA    1020
....................         
....................     lcd_putc('\f');                       //Limpiar pantalla comando 
102C:  MOVLW  0C
102E:  MOVWF  2A
1030:  CALL   06F8
....................     lcd_gotoxy(1,1);                      //escribir en a primera fila primera posicion  
1034:  MOVLW  01
1036:  MOVWF  2B
1038:  MOVWF  2C
103A:  CALL   069C
....................     lcd_putc("MARQUE NUM PARA");          //lo que se escribe 
103E:  CLRF   28
1040:  MOVF   28,W
1042:  CALL   0264
1046:  IORLW  00
1048:  BZ    1054
104A:  INCF   28,F
104C:  MOVWF  2A
104E:  CALL   06F8
1052:  BRA    1040
....................     lcd_gotoxy(1,2);                      //escribir en a primera fila primera posicion  
1054:  MOVLW  01
1056:  MOVWF  2B
1058:  MOVLW  02
105A:  MOVWF  2C
105C:  CALL   069C
....................     lcd_putc("1 CAMBIAR CLAVE"); 
1060:  CLRF   28
1062:  MOVF   28,W
1064:  CALL   0284
1068:  IORLW  00
106A:  BZ    1076
106C:  INCF   28,F
106E:  MOVWF  2A
1070:  CALL   06F8
1074:  BRA    1062
....................     delay_ms(3000);   
1076:  MOVLW  0C
1078:  MOVWF  28
107A:  MOVLW  FA
107C:  MOVWF  2B
107E:  CALL   0590
1082:  DECFSZ 28,F
1084:  BRA    107A
....................      
....................     lcd_putc('\f');                      //Limpiar pantalla comando 
1086:  MOVLW  0C
1088:  MOVWF  2A
108A:  CALL   06F8
....................     lcd_gotoxy(1,1);                     //escribir en a primera fila primera posicion  
108E:  MOVLW  01
1090:  MOVWF  2B
1092:  MOVWF  2C
1094:  CALL   069C
....................     lcd_putc("2 FECHA Y HORA");          //lo que se escribe 
1098:  CLRF   28
109A:  MOVF   28,W
109C:  CALL   02A4
10A0:  IORLW  00
10A2:  BZ    10AE
10A4:  INCF   28,F
10A6:  MOVWF  2A
10A8:  CALL   06F8
10AC:  BRA    109A
....................     lcd_gotoxy(1,2);                     //escribir en a primera fila primera posicion  
10AE:  MOVLW  01
10B0:  MOVWF  2B
10B2:  MOVLW  02
10B4:  MOVWF  2C
10B6:  CALL   069C
....................     lcd_putc("3 REPORTES"); 
10BA:  CLRF   28
10BC:  MOVF   28,W
10BE:  CALL   02C4
10C2:  IORLW  00
10C4:  BZ    10D0
10C6:  INCF   28,F
10C8:  MOVWF  2A
10CA:  CALL   06F8
10CE:  BRA    10BC
....................     delay_ms(3000); 
10D0:  MOVLW  0C
10D2:  MOVWF  28
10D4:  MOVLW  FA
10D6:  MOVWF  2B
10D8:  CALL   0590
10DC:  DECFSZ 28,F
10DE:  BRA    10D4
....................      
....................     lcd_putc('\f');                      //Limpiar pantalla comando 
10E0:  MOVLW  0C
10E2:  MOVWF  2A
10E4:  CALL   06F8
....................     lcd_gotoxy(1,1);                     //escribir en a primera fila primera posicion  
10E8:  MOVLW  01
10EA:  MOVWF  2B
10EC:  MOVWF  2C
10EE:  CALL   069C
....................     lcd_putc("4 MOTOR PAS A PA");        //lo que se escribe 
10F2:  CLRF   28
10F4:  MOVF   28,W
10F6:  CALL   02E0
10FA:  IORLW  00
10FC:  BZ    1108
10FE:  INCF   28,F
1100:  MOVWF  2A
1102:  CALL   06F8
1106:  BRA    10F4
....................     lcd_gotoxy(1,2);                     //escribir en a primera fila primera posicion  
1108:  MOVLW  01
110A:  MOVWF  2B
110C:  MOVLW  02
110E:  MOVWF  2C
1110:  CALL   069C
....................     lcd_putc("5 SERVOMOTOR"); 
1114:  CLRF   28
1116:  MOVF   28,W
1118:  CALL   0302
111C:  IORLW  00
111E:  BZ    112A
1120:  INCF   28,F
1122:  MOVWF  2A
1124:  CALL   06F8
1128:  BRA    1116
....................     delay_ms(3000); 
112A:  MOVLW  0C
112C:  MOVWF  28
112E:  MOVLW  FA
1130:  MOVWF  2B
1132:  CALL   0590
1136:  DECFSZ 28,F
1138:  BRA    112E
....................      
....................     lcd_putc('\f');                      //Limpiar pantalla comando 
113A:  MOVLW  0C
113C:  MOVWF  2A
113E:  CALL   06F8
....................     lcd_gotoxy(1,1);                     //escribir en a primera fila primera posicion  
1142:  MOVLW  01
1144:  MOVWF  2B
1146:  MOVWF  2C
1148:  CALL   069C
....................     lcd_putc("6 CAD");                   //lo que se escribe 
114C:  CLRF   28
114E:  MOVF   28,W
1150:  CALL   0320
1154:  IORLW  00
1156:  BZ    1162
1158:  INCF   28,F
115A:  MOVWF  2A
115C:  CALL   06F8
1160:  BRA    114E
....................     lcd_gotoxy(1,2);                     //escribir en a primera fila primera posicion  
1162:  MOVLW  01
1164:  MOVWF  2B
1166:  MOVLW  02
1168:  MOVWF  2C
116A:  CALL   069C
....................     lcd_putc("7 DTMF"); 
116E:  CLRF   28
1170:  MOVF   28,W
1172:  CALL   0336
1176:  IORLW  00
1178:  BZ    1184
117A:  INCF   28,F
117C:  MOVWF  2A
117E:  CALL   06F8
1182:  BRA    1170
....................     delay_ms(3000); 
1184:  MOVLW  0C
1186:  MOVWF  28
1188:  MOVLW  FA
118A:  MOVWF  2B
118C:  CALL   0590
1190:  DECFSZ 28,F
1192:  BRA    1188
....................      
....................     lcd_putc('\f');                      //Limpiar pantalla comando 
1194:  MOVLW  0C
1196:  MOVWF  2A
1198:  CALL   06F8
....................     lcd_gotoxy(1,1);                     //escribir en a primera fila primera posicion  
119C:  MOVLW  01
119E:  MOVWF  2B
11A0:  MOVWF  2C
11A2:  CALL   069C
....................     lcd_putc("8 SENSORES");              //lo que se escribe 
11A6:  CLRF   28
11A8:  MOVF   28,W
11AA:  CALL   034E
11AE:  IORLW  00
11B0:  BZ    11BC
11B2:  INCF   28,F
11B4:  MOVWF  2A
11B6:  CALL   06F8
11BA:  BRA    11A8
....................     lcd_gotoxy(3,2);                     //escribir en a primera fila primera posicion  
11BC:  MOVLW  03
11BE:  MOVWF  2B
11C0:  MOVLW  02
11C2:  MOVWF  2C
11C4:  CALL   069C
....................     lcd_putc("9 SALIR"); 
11C8:  CLRF   28
11CA:  MOVF   28,W
11CC:  CALL   036A
11D0:  IORLW  00
11D2:  BZ    11DE
11D4:  INCF   28,F
11D6:  MOVWF  2A
11D8:  CALL   06F8
11DC:  BRA    11CA
....................     delay_ms(3000); 
11DE:  MOVLW  0C
11E0:  MOVWF  28
11E2:  MOVLW  FA
11E4:  MOVWF  2B
11E6:  CALL   0590
11EA:  DECFSZ 28,F
11EC:  BRA    11E2
....................      
....................     un_digito(); 
11EE:  RCALL  0B9E
....................     if(datom==0x01) 
11F0:  DECFSZ 1F,W
11F2:  BRA    1372
....................      { 
....................       lcd_putc('\f');                   //Limpiar pantalla comando 
11F4:  MOVLW  0C
11F6:  MOVWF  2A
11F8:  CALL   06F8
....................        lcd_gotoxy(1,1);                  //escribir en a primera fila primera posicion  
11FC:  MOVLW  01
11FE:  MOVWF  2B
1200:  MOVWF  2C
1202:  CALL   069C
....................        lcd_putc("MEN CAMBIAR CLAV");     //lo que se escribe 
1206:  CLRF   28
1208:  MOVF   28,W
120A:  CALL   0382
120E:  IORLW  00
1210:  BZ    121C
1212:  INCF   28,F
1214:  MOVWF  2A
1216:  CALL   06F8
121A:  BRA    1208
....................        lcd_gotoxy(3,2);                  //escribir en a primera fila primera posicion  
121C:  MOVLW  03
121E:  MOVWF  2B
1220:  MOVLW  02
1222:  MOVWF  2C
1224:  CALL   069C
....................        lcd_putc("DIGITE NU. CLAVE");     //clave[0]= y clave[1]= 
1228:  CLRF   28
122A:  MOVF   28,W
122C:  CALL   03A4
1230:  IORLW  00
1232:  BZ    123E
1234:  INCF   28,F
1236:  MOVWF  2A
1238:  CALL   06F8
123C:  BRA    122A
....................        delay_ms(3000); 
123E:  MOVLW  0C
1240:  MOVWF  28
1242:  MOVLW  FA
1244:  MOVWF  2B
1246:  CALL   0590
124A:  DECFSZ 28,F
124C:  BRA    1242
....................        teclado(); 
124E:  CALL   0970
....................         
....................        dato1=clave[0]; 
1252:  MOVFF  14,1D
....................        dato2=clave[1]; 
1256:  MOVFF  15,1E
....................         
....................        lcd_putc('\f');                   //Limpiar pantalla comando 
125A:  MOVLW  0C
125C:  MOVWF  2A
125E:  CALL   06F8
....................        lcd_gotoxy(1,1);                  //escribir en a primera fila primera posicion  
1262:  MOVLW  01
1264:  MOVWF  2B
1266:  MOVWF  2C
1268:  CALL   069C
....................        lcd_putc("POR FAVOR DIGITE");     //lo que se escribe 
126C:  CLRF   28
126E:  MOVF   28,W
1270:  CALL   03C6
1274:  IORLW  00
1276:  BZ    1282
1278:  INCF   28,F
127A:  MOVWF  2A
127C:  CALL   06F8
1280:  BRA    126E
....................        lcd_gotoxy(1,2);                  //escribir en a primera fila primera posicion  
1282:  MOVLW  01
1284:  MOVWF  2B
1286:  MOVLW  02
1288:  MOVWF  2C
128A:  CALL   069C
....................        lcd_putc("DIGITE NUE.CLAVE");    
128E:  CLRF   28
1290:  MOVF   28,W
1292:  CALL   03E8
1296:  IORLW  00
1298:  BZ    12A4
129A:  INCF   28,F
129C:  MOVWF  2A
129E:  CALL   06F8
12A2:  BRA    1290
....................        delay_ms(3000); 
12A4:  MOVLW  0C
12A6:  MOVWF  28
12A8:  MOVLW  FA
12AA:  MOVWF  2B
12AC:  CALL   0590
12B0:  DECFSZ 28,F
12B2:  BRA    12A8
....................         
....................        teclado(); 
12B4:  CALL   0970
....................         
....................        if(clave[0]==dato1 & clave[1]==dato2) 
12B8:  MOVF   1D,W
12BA:  SUBWF  14,W
12BC:  BZ    12C2
12BE:  MOVLW  00
12C0:  BRA    12C4
12C2:  MOVLW  01
12C4:  MOVWF  28
12C6:  MOVF   1E,W
12C8:  SUBWF  15,W
12CA:  BZ    12D0
12CC:  MOVLW  00
12CE:  BRA    12D2
12D0:  MOVLW  01
12D2:  ANDWF  28,W
12D4:  BZ    1336
....................        { 
....................         escribir_memoria(); 
12D6:  RCALL  0C00
....................         lcd_putc('\f');                   //Limpiar pantalla comando 
12D8:  MOVLW  0C
12DA:  MOVWF  2A
12DC:  CALL   06F8
....................         lcd_gotoxy(1,1);                  //escribir en a primera fila primera posicion  
12E0:  MOVLW  01
12E2:  MOVWF  2B
12E4:  MOVWF  2C
12E6:  CALL   069C
....................         lcd_putc("CLAVE MODIFICADA");     //lo que se escribe 
12EA:  CLRF   28
12EC:  MOVF   28,W
12EE:  CALL   040A
12F2:  IORLW  00
12F4:  BZ    1300
12F6:  INCF   28,F
12F8:  MOVWF  2A
12FA:  CALL   06F8
12FE:  BRA    12EC
....................         lcd_gotoxy(3,2);                  //escribir en a primera fila primera posicion  
1300:  MOVLW  03
1302:  MOVWF  2B
1304:  MOVLW  02
1306:  MOVWF  2C
1308:  CALL   069C
....................         lcd_putc("CON EXITO");    
130C:  CLRF   28
130E:  MOVF   28,W
1310:  CALL   042C
1314:  IORLW  00
1316:  BZ    1322
1318:  INCF   28,F
131A:  MOVWF  2A
131C:  CALL   06F8
1320:  BRA    130E
....................         delay_ms(3000); 
1322:  MOVLW  0C
1324:  MOVWF  28
1326:  MOVLW  FA
1328:  MOVWF  2B
132A:  CALL   0590
132E:  DECFSZ 28,F
1330:  BRA    1326
....................         goto Miguel; 
1332:  BRA    0FD0
....................        } 
....................        else{ 
1334:  BRA    1370
....................        lcd_putc('\f');                   //Limpiar pantalla comando 
1336:  MOVLW  0C
1338:  MOVWF  2A
133A:  CALL   06F8
....................        lcd_gotoxy(1,1);                  //escribir en a primera fila primera posicion  
133E:  MOVLW  01
1340:  MOVWF  2B
1342:  MOVWF  2C
1344:  CALL   069C
....................        lcd_putc("ERROR DE CLAVE");     //lo que se escribe 
1348:  CLRF   28
134A:  MOVF   28,W
134C:  CALL   0446
1350:  IORLW  00
1352:  BZ    135E
1354:  INCF   28,F
1356:  MOVWF  2A
1358:  CALL   06F8
135C:  BRA    134A
....................        delay_ms(3000); 
135E:  MOVLW  0C
1360:  MOVWF  28
1362:  MOVLW  FA
1364:  MOVWF  2B
1366:  CALL   0590
136A:  DECFSZ 28,F
136C:  BRA    1362
....................        goto Miguel; 
136E:  BRA    0FD0
....................        } 
....................        
....................        
....................      } 
....................      else if(datom==0x02) 
1370:  BRA    167C
1372:  MOVF   1F,W
1374:  SUBLW  02
1376:  BNZ   13D6
....................      { 
....................        lcd_putc('\f');                  //Limpiar pantalla comando 
1378:  MOVLW  0C
137A:  MOVWF  2A
137C:  CALL   06F8
....................        lcd_gotoxy(1,1);                 //escribir en a primera fila primera posicion  
1380:  MOVLW  01
1382:  MOVWF  2B
1384:  MOVWF  2C
1386:  CALL   069C
....................        lcd_putc("MEN FECHA Y HORA");    //lo que se escribe 
138A:  CLRF   28
138C:  MOVF   28,W
138E:  CALL   0466
1392:  IORLW  00
1394:  BZ    13A0
1396:  INCF   28,F
1398:  MOVWF  2A
139A:  CALL   06F8
139E:  BRA    138C
....................        lcd_gotoxy(3,2);                 //escribir en a primera fila primera posicion  
13A0:  MOVLW  03
13A2:  MOVWF  2B
13A4:  MOVLW  02
13A6:  MOVWF  2C
13A8:  CALL   069C
....................        lcd_putc("EN CONSTRUCCION"); 
13AC:  CLRF   28
13AE:  MOVF   28,W
13B0:  CALL   0488
13B4:  IORLW  00
13B6:  BZ    13C2
13B8:  INCF   28,F
13BA:  MOVWF  2A
13BC:  CALL   06F8
13C0:  BRA    13AE
....................        delay_ms(3000); 
13C2:  MOVLW  0C
13C4:  MOVWF  28
13C6:  MOVLW  FA
13C8:  MOVWF  2B
13CA:  CALL   0590
13CE:  DECFSZ 28,F
13D0:  BRA    13C6
....................        goto Miguel; 
13D2:  BRA    0FD0
....................      } 
....................     else if(datom==0x03) 
13D4:  BRA    167C
13D6:  MOVF   1F,W
13D8:  SUBLW  03
13DA:  BNZ   143A
....................      { 
....................        lcd_putc('\f');                //Limpiar pantalla comando 
13DC:  MOVLW  0C
13DE:  MOVWF  2A
13E0:  CALL   06F8
....................        lcd_gotoxy(1,1);               //escribir en a primera fila primera posicion  
13E4:  MOVLW  01
13E6:  MOVWF  2B
13E8:  MOVWF  2C
13EA:  CALL   069C
....................        lcd_putc("MENU REPORTES");     //lo que se escribe 
13EE:  CLRF   28
13F0:  MOVF   28,W
13F2:  CALL   04A8
13F6:  IORLW  00
13F8:  BZ    1404
13FA:  INCF   28,F
13FC:  MOVWF  2A
13FE:  CALL   06F8
1402:  BRA    13F0
....................        lcd_gotoxy(3,2);               //escribir en a primera fila primera posicion  
1404:  MOVLW  03
1406:  MOVWF  2B
1408:  MOVLW  02
140A:  MOVWF  2C
140C:  CALL   069C
....................        lcd_putc("EN CONSTRUCCION"); 
1410:  CLRF   28
1412:  MOVF   28,W
1414:  CALL   0488
1418:  IORLW  00
141A:  BZ    1426
141C:  INCF   28,F
141E:  MOVWF  2A
1420:  CALL   06F8
1424:  BRA    1412
....................        delay_ms(3000); 
1426:  MOVLW  0C
1428:  MOVWF  28
142A:  MOVLW  FA
142C:  MOVWF  2B
142E:  CALL   0590
1432:  DECFSZ 28,F
1434:  BRA    142A
....................        goto Miguel; 
1436:  BRA    0FD0
....................      } 
....................     else if(datom==0x04) 
1438:  BRA    167C
143A:  MOVF   1F,W
143C:  SUBLW  04
143E:  BNZ   149E
....................      { 
....................        lcd_putc('\f');               //Limpiar pantalla comando 
1440:  MOVLW  0C
1442:  MOVWF  2A
1444:  CALL   06F8
....................        lcd_gotoxy(1,1);              //escribir en a primera fila primera posicion  
1448:  MOVLW  01
144A:  MOVWF  2B
144C:  MOVWF  2C
144E:  CALL   069C
....................        lcd_putc("MEN MOTOR PAS A."); //lo que se escribe 
1452:  CLRF   28
1454:  MOVF   28,W
1456:  CALL   04C6
145A:  IORLW  00
145C:  BZ    1468
145E:  INCF   28,F
1460:  MOVWF  2A
1462:  CALL   06F8
1466:  BRA    1454
....................        lcd_gotoxy(3,2);              //escribir en a primera fila primera posicion  
1468:  MOVLW  03
146A:  MOVWF  2B
146C:  MOVLW  02
146E:  MOVWF  2C
1470:  CALL   069C
....................        lcd_putc("EN CONSTRUCCION"); 
1474:  CLRF   28
1476:  MOVF   28,W
1478:  CALL   0488
147C:  IORLW  00
147E:  BZ    148A
1480:  INCF   28,F
1482:  MOVWF  2A
1484:  CALL   06F8
1488:  BRA    1476
....................        delay_ms(3000); 
148A:  MOVLW  0C
148C:  MOVWF  28
148E:  MOVLW  FA
1490:  MOVWF  2B
1492:  CALL   0590
1496:  DECFSZ 28,F
1498:  BRA    148E
....................        goto Miguel; 
149A:  BRA    0FD0
....................      } 
....................      else if(datom==0x05) 
149C:  BRA    167C
149E:  MOVF   1F,W
14A0:  SUBLW  05
14A2:  BNZ   1502
....................      { 
....................        lcd_putc('\f');              //Limpiar pantalla comando 
14A4:  MOVLW  0C
14A6:  MOVWF  2A
14A8:  CALL   06F8
....................        lcd_gotoxy(1,1);             //escribir en a primera fila primera posicion  
14AC:  MOVLW  01
14AE:  MOVWF  2B
14B0:  MOVWF  2C
14B2:  CALL   069C
....................        lcd_putc("MEN SERVOMOTOR");  //lo que se escribe 
14B6:  CLRF   28
14B8:  MOVF   28,W
14BA:  CALL   04E8
14BE:  IORLW  00
14C0:  BZ    14CC
14C2:  INCF   28,F
14C4:  MOVWF  2A
14C6:  CALL   06F8
14CA:  BRA    14B8
....................        lcd_gotoxy(3,2);             //escribir en a primera fila primera posicion  
14CC:  MOVLW  03
14CE:  MOVWF  2B
14D0:  MOVLW  02
14D2:  MOVWF  2C
14D4:  CALL   069C
....................        lcd_putc("EN CONSTRUCCION"); 
14D8:  CLRF   28
14DA:  MOVF   28,W
14DC:  CALL   0488
14E0:  IORLW  00
14E2:  BZ    14EE
14E4:  INCF   28,F
14E6:  MOVWF  2A
14E8:  CALL   06F8
14EC:  BRA    14DA
....................        delay_ms(3000); 
14EE:  MOVLW  0C
14F0:  MOVWF  28
14F2:  MOVLW  FA
14F4:  MOVWF  2B
14F6:  CALL   0590
14FA:  DECFSZ 28,F
14FC:  BRA    14F2
....................        goto Miguel; 
14FE:  BRA    0FD0
....................      } 
....................    else  if(datom==0x06) 
1500:  BRA    167C
1502:  MOVF   1F,W
1504:  SUBLW  06
1506:  BNZ   1566
....................      { 
....................        lcd_putc('\f');               //Limpiar pantalla comando 
1508:  MOVLW  0C
150A:  MOVWF  2A
150C:  CALL   06F8
....................        lcd_gotoxy(1,1);              //escribir en a primera fila primera posicion  
1510:  MOVLW  01
1512:  MOVWF  2B
1514:  MOVWF  2C
1516:  CALL   069C
....................        lcd_putc("MENU CAD");         //lo que se escribe 
151A:  CLRF   28
151C:  MOVF   28,W
151E:  CALL   0508
1522:  IORLW  00
1524:  BZ    1530
1526:  INCF   28,F
1528:  MOVWF  2A
152A:  CALL   06F8
152E:  BRA    151C
....................        lcd_gotoxy(3,2);              //escribir en a primera fila primera posicion  
1530:  MOVLW  03
1532:  MOVWF  2B
1534:  MOVLW  02
1536:  MOVWF  2C
1538:  CALL   069C
....................        lcd_putc("EN CONSTRUCCION"); 
153C:  CLRF   28
153E:  MOVF   28,W
1540:  CALL   0488
1544:  IORLW  00
1546:  BZ    1552
1548:  INCF   28,F
154A:  MOVWF  2A
154C:  CALL   06F8
1550:  BRA    153E
....................        delay_ms(3000); 
1552:  MOVLW  0C
1554:  MOVWF  28
1556:  MOVLW  FA
1558:  MOVWF  2B
155A:  CALL   0590
155E:  DECFSZ 28,F
1560:  BRA    1556
....................        goto Miguel; 
1562:  BRA    0FD0
....................      } 
....................     else if(datom==0x07) 
1564:  BRA    167C
1566:  MOVF   1F,W
1568:  SUBLW  07
156A:  BNZ   15CA
....................      { 
....................        lcd_putc('\f');               //Limpiar pantalla comando 
156C:  MOVLW  0C
156E:  MOVWF  2A
1570:  CALL   06F8
....................        lcd_gotoxy(1,1);              //escribir en a primera fila primera posicion  
1574:  MOVLW  01
1576:  MOVWF  2B
1578:  MOVWF  2C
157A:  CALL   069C
....................        lcd_putc("MEN DTMF");         //lo que se escribe 
157E:  CLRF   28
1580:  MOVF   28,W
1582:  CALL   0522
1586:  IORLW  00
1588:  BZ    1594
158A:  INCF   28,F
158C:  MOVWF  2A
158E:  CALL   06F8
1592:  BRA    1580
....................        lcd_gotoxy(3,2);              //escribir en a primera fila primera posicion  
1594:  MOVLW  03
1596:  MOVWF  2B
1598:  MOVLW  02
159A:  MOVWF  2C
159C:  CALL   069C
....................        lcd_putc("EN CONSTRUCCION"); 
15A0:  CLRF   28
15A2:  MOVF   28,W
15A4:  CALL   0488
15A8:  IORLW  00
15AA:  BZ    15B6
15AC:  INCF   28,F
15AE:  MOVWF  2A
15B0:  CALL   06F8
15B4:  BRA    15A2
....................        delay_ms(3000); 
15B6:  MOVLW  0C
15B8:  MOVWF  28
15BA:  MOVLW  FA
15BC:  MOVWF  2B
15BE:  CALL   0590
15C2:  DECFSZ 28,F
15C4:  BRA    15BA
....................       goto Miguel; 
15C6:  BRA    0FD0
....................      } 
....................     else if(datom==0x08) 
15C8:  BRA    167C
15CA:  MOVF   1F,W
15CC:  SUBLW  08
15CE:  BNZ   162E
....................      { 
....................        lcd_putc('\f');              //Limpiar pantalla comando 
15D0:  MOVLW  0C
15D2:  MOVWF  2A
15D4:  CALL   06F8
....................        lcd_gotoxy(1,1);             //escribir en a primera fila primera posicion  
15D8:  MOVLW  01
15DA:  MOVWF  2B
15DC:  MOVWF  2C
15DE:  CALL   069C
....................        lcd_putc("MEN SENSORES");    //lo que se escribe 
15E2:  CLRF   28
15E4:  MOVF   28,W
15E6:  CALL   053C
15EA:  IORLW  00
15EC:  BZ    15F8
15EE:  INCF   28,F
15F0:  MOVWF  2A
15F2:  CALL   06F8
15F6:  BRA    15E4
....................        lcd_gotoxy(3,2);             //escribir en a primera fila primera posicion  
15F8:  MOVLW  03
15FA:  MOVWF  2B
15FC:  MOVLW  02
15FE:  MOVWF  2C
1600:  CALL   069C
....................        lcd_putc("EN CONSTRUCCION"); 
1604:  CLRF   28
1606:  MOVF   28,W
1608:  CALL   0488
160C:  IORLW  00
160E:  BZ    161A
1610:  INCF   28,F
1612:  MOVWF  2A
1614:  CALL   06F8
1618:  BRA    1606
....................        delay_ms(3000); 
161A:  MOVLW  0C
161C:  MOVWF  28
161E:  MOVLW  FA
1620:  MOVWF  2B
1622:  CALL   0590
1626:  DECFSZ 28,F
1628:  BRA    161E
....................        goto Miguel; 
162A:  BRA    0FD0
....................      } 
....................     else if(datom==0x09) 
162C:  BRA    167C
162E:  MOVF   1F,W
1630:  SUBLW  09
1632:  BNZ   163A
....................      { 
....................       goto admin; 
1634:  GOTO   0E08
....................      } 
....................      else{ 
1638:  BRA    167C
....................           lcd_putc('\f');                 //Limpiar pantalla comando 
163A:  MOVLW  0C
163C:  MOVWF  2A
163E:  CALL   06F8
....................           lcd_gotoxy(1,2);                //escribir en a primera fila primera posicion  
1642:  MOVLW  01
1644:  MOVWF  2B
1646:  MOVLW  02
1648:  MOVWF  2C
164A:  CALL   069C
....................           lcd_putc("ERROR DE NUMERO");   //lo que se escribe 
164E:  CLRF   28
1650:  MOVF   28,W
1652:  CALL   0210
1656:  IORLW  00
1658:  BZ    1664
165A:  INCF   28,F
165C:  MOVWF  2A
165E:  CALL   06F8
1662:  BRA    1650
....................           delay_ms(3000); 
1664:  MOVLW  0C
1666:  MOVWF  28
1668:  MOVLW  FA
166A:  MOVWF  2B
166C:  CALL   0590
1670:  DECFSZ 28,F
1672:  BRA    1668
....................           goto menu; 
1674:  GOTO   0CA8
....................      goto admin; 
1678:  GOTO   0E08
....................      } 
....................      } 
....................    
....................     else if(clave[0]==datoi[3] & clave[1]==datoi[2]) 
167C:  GOTO   1D8E
1680:  MOVF   1B,W
1682:  SUBWF  14,W
1684:  BZ    168A
1686:  MOVLW  00
1688:  BRA    168C
168A:  MOVLW  01
168C:  MOVWF  28
168E:  MOVF   1A,W
1690:  SUBWF  15,W
1692:  BZ    1698
1694:  MOVLW  00
1696:  BRA    169A
1698:  MOVLW  01
169A:  ANDWF  28,W
169C:  BTFSC  FD8.2
169E:  BRA    1D50
....................     { 
.................... David:adres=0x02; 
16A0:  MOVLW  02
16A2:  MOVWF  1C
....................        /*escribirle al lcd 
....................        bienvenidos al menu del diseador 
....................        marque 1 para cambiar clave 
....................        marque 2 para fecha y hora 
....................        marque 3 para reportes 
....................        marque 4 para motor paso a paso 
....................        marque 5 para servomotor 
....................        marque 6 para cad 
....................        marque 7 para DTMF 
....................        marque 8 para sensores 
....................        marque 9 para salir*/ 
....................       
....................     lcd_putc('\f');                       //Limpiar pantalla comando 
16A4:  MOVLW  0C
16A6:  MOVWF  2A
16A8:  CALL   06F8
....................     lcd_gotoxy(1,1);                      //escribir en a primera fila primera posicion  
16AC:  MOVLW  01
16AE:  MOVWF  2B
16B0:  MOVWF  2C
16B2:  CALL   069C
....................     lcd_putc("MENU USUAR.");              //lo que se escribe 
16B6:  CLRF   28
16B8:  MOVF   28,W
16BA:  CALL   0230
16BE:  IORLW  00
16C0:  BZ    16CC
16C2:  INCF   28,F
16C4:  MOVWF  2A
16C6:  CALL   06F8
16CA:  BRA    16B8
....................     lcd_gotoxy(4,2);                      //escribir en a primera fila primera posicion  
16CC:  MOVLW  04
16CE:  MOVWF  2B
16D0:  MOVLW  02
16D2:  MOVWF  2C
16D4:  CALL   069C
....................     lcd_putc("DAVID"); 
16D8:  CLRF   28
16DA:  MOVF   28,W
16DC:  CALL   055A
16E0:  IORLW  00
16E2:  BZ    16EE
16E4:  INCF   28,F
16E6:  MOVWF  2A
16E8:  CALL   06F8
16EC:  BRA    16DA
....................     delay_ms(3000);  
16EE:  MOVLW  0C
16F0:  MOVWF  28
16F2:  MOVLW  FA
16F4:  MOVWF  2B
16F6:  CALL   0590
16FA:  DECFSZ 28,F
16FC:  BRA    16F2
....................         
....................     lcd_putc('\f');                       //Limpiar pantalla comando 
16FE:  MOVLW  0C
1700:  MOVWF  2A
1702:  CALL   06F8
....................     lcd_gotoxy(1,1);                      //escribir en a primera fila primera posicion  
1706:  MOVLW  01
1708:  MOVWF  2B
170A:  MOVWF  2C
170C:  CALL   069C
....................     lcd_putc("MARQUE NUM PARA");          //lo que se escribe 
1710:  CLRF   28
1712:  MOVF   28,W
1714:  CALL   0264
1718:  IORLW  00
171A:  BZ    1726
171C:  INCF   28,F
171E:  MOVWF  2A
1720:  CALL   06F8
1724:  BRA    1712
....................     lcd_gotoxy(1,2);                      //escribir en a primera fila primera posicion  
1726:  MOVLW  01
1728:  MOVWF  2B
172A:  MOVLW  02
172C:  MOVWF  2C
172E:  CALL   069C
....................     lcd_putc("1 CAMBIAR CLAVE"); 
1732:  CLRF   28
1734:  MOVF   28,W
1736:  CALL   0284
173A:  IORLW  00
173C:  BZ    1748
173E:  INCF   28,F
1740:  MOVWF  2A
1742:  CALL   06F8
1746:  BRA    1734
....................     delay_ms(3000);   
1748:  MOVLW  0C
174A:  MOVWF  28
174C:  MOVLW  FA
174E:  MOVWF  2B
1750:  CALL   0590
1754:  DECFSZ 28,F
1756:  BRA    174C
....................      
....................     lcd_putc('\f');                      //Limpiar pantalla comando 
1758:  MOVLW  0C
175A:  MOVWF  2A
175C:  CALL   06F8
....................     lcd_gotoxy(1,1);                     //escribir en a primera fila primera posicion  
1760:  MOVLW  01
1762:  MOVWF  2B
1764:  MOVWF  2C
1766:  CALL   069C
....................     lcd_putc("2 FECHA Y HORA");          //lo que se escribe 
176A:  CLRF   28
176C:  MOVF   28,W
176E:  CALL   02A4
1772:  IORLW  00
1774:  BZ    1780
1776:  INCF   28,F
1778:  MOVWF  2A
177A:  CALL   06F8
177E:  BRA    176C
....................     lcd_gotoxy(1,2);                     //escribir en a primera fila primera posicion  
1780:  MOVLW  01
1782:  MOVWF  2B
1784:  MOVLW  02
1786:  MOVWF  2C
1788:  CALL   069C
....................     lcd_putc("3 REPORTES"); 
178C:  CLRF   28
178E:  MOVF   28,W
1790:  CALL   02C4
1794:  IORLW  00
1796:  BZ    17A2
1798:  INCF   28,F
179A:  MOVWF  2A
179C:  CALL   06F8
17A0:  BRA    178E
....................     delay_ms(3000); 
17A2:  MOVLW  0C
17A4:  MOVWF  28
17A6:  MOVLW  FA
17A8:  MOVWF  2B
17AA:  CALL   0590
17AE:  DECFSZ 28,F
17B0:  BRA    17A6
....................      
....................     lcd_putc('\f');                     //Limpiar pantalla comando 
17B2:  MOVLW  0C
17B4:  MOVWF  2A
17B6:  CALL   06F8
....................     lcd_gotoxy(1,1);                    //escribir en a primera fila primera posicion  
17BA:  MOVLW  01
17BC:  MOVWF  2B
17BE:  MOVWF  2C
17C0:  CALL   069C
....................     lcd_putc("4 MOTOR PAS A PA");       //lo que se escribe 
17C4:  CLRF   28
17C6:  MOVF   28,W
17C8:  CALL   02E0
17CC:  IORLW  00
17CE:  BZ    17DA
17D0:  INCF   28,F
17D2:  MOVWF  2A
17D4:  CALL   06F8
17D8:  BRA    17C6
....................     lcd_gotoxy(1,2);                     //escribir en a primera fila primera posicion  
17DA:  MOVLW  01
17DC:  MOVWF  2B
17DE:  MOVLW  02
17E0:  MOVWF  2C
17E2:  CALL   069C
....................     lcd_putc("5 SERVOMOTOR"); 
17E6:  CLRF   28
17E8:  MOVF   28,W
17EA:  CALL   0302
17EE:  IORLW  00
17F0:  BZ    17FC
17F2:  INCF   28,F
17F4:  MOVWF  2A
17F6:  CALL   06F8
17FA:  BRA    17E8
....................     delay_ms(3000); 
17FC:  MOVLW  0C
17FE:  MOVWF  28
1800:  MOVLW  FA
1802:  MOVWF  2B
1804:  CALL   0590
1808:  DECFSZ 28,F
180A:  BRA    1800
....................      
....................     lcd_putc('\f');                      //Limpiar pantalla comando 
180C:  MOVLW  0C
180E:  MOVWF  2A
1810:  CALL   06F8
....................     lcd_gotoxy(1,1);                     //escribir en a primera fila primera posicion  
1814:  MOVLW  01
1816:  MOVWF  2B
1818:  MOVWF  2C
181A:  CALL   069C
....................     lcd_putc("6 CAD");                   //lo que se escribe 
181E:  CLRF   28
1820:  MOVF   28,W
1822:  CALL   0320
1826:  IORLW  00
1828:  BZ    1834
182A:  INCF   28,F
182C:  MOVWF  2A
182E:  CALL   06F8
1832:  BRA    1820
....................     lcd_gotoxy(1,2);                     //escribir en a primera fila primera posicion  
1834:  MOVLW  01
1836:  MOVWF  2B
1838:  MOVLW  02
183A:  MOVWF  2C
183C:  CALL   069C
....................     lcd_putc("7 DTMF"); 
1840:  CLRF   28
1842:  MOVF   28,W
1844:  CALL   0336
1848:  IORLW  00
184A:  BZ    1856
184C:  INCF   28,F
184E:  MOVWF  2A
1850:  CALL   06F8
1854:  BRA    1842
....................     delay_ms(3000); 
1856:  MOVLW  0C
1858:  MOVWF  28
185A:  MOVLW  FA
185C:  MOVWF  2B
185E:  CALL   0590
1862:  DECFSZ 28,F
1864:  BRA    185A
....................      
....................     lcd_putc('\f');                      //Limpiar pantalla comando 
1866:  MOVLW  0C
1868:  MOVWF  2A
186A:  CALL   06F8
....................     lcd_gotoxy(1,1);                     //escribir en a primera fila primera posicion  
186E:  MOVLW  01
1870:  MOVWF  2B
1872:  MOVWF  2C
1874:  CALL   069C
....................     lcd_putc("8 SENSORES");              //lo que se escribe 
1878:  CLRF   28
187A:  MOVF   28,W
187C:  CALL   034E
1880:  IORLW  00
1882:  BZ    188E
1884:  INCF   28,F
1886:  MOVWF  2A
1888:  CALL   06F8
188C:  BRA    187A
....................     lcd_gotoxy(3,2);                     //escribir en a primera fila primera posicion  
188E:  MOVLW  03
1890:  MOVWF  2B
1892:  MOVLW  02
1894:  MOVWF  2C
1896:  CALL   069C
....................     lcd_putc("9 SALIR"); 
189A:  CLRF   28
189C:  MOVF   28,W
189E:  CALL   036A
18A2:  IORLW  00
18A4:  BZ    18B0
18A6:  INCF   28,F
18A8:  MOVWF  2A
18AA:  CALL   06F8
18AE:  BRA    189C
....................     delay_ms(3000); 
18B0:  MOVLW  0C
18B2:  MOVWF  28
18B4:  MOVLW  FA
18B6:  MOVWF  2B
18B8:  CALL   0590
18BC:  DECFSZ 28,F
18BE:  BRA    18B4
....................      
....................     un_digito(); 
18C0:  CALL   0B9E
....................     if(datom==0x01) 
18C4:  DECFSZ 1F,W
18C6:  BRA    1A48
....................      { 
....................        lcd_putc('\f');                   //Limpiar pantalla comando 
18C8:  MOVLW  0C
18CA:  MOVWF  2A
18CC:  CALL   06F8
....................        lcd_gotoxy(1,1);                  //escribir en a primera fila primera posicion  
18D0:  MOVLW  01
18D2:  MOVWF  2B
18D4:  MOVWF  2C
18D6:  CALL   069C
....................        lcd_putc("MEN CAMBIAR CLAV");     //lo que se escribe 
18DA:  CLRF   28
18DC:  MOVF   28,W
18DE:  CALL   0382
18E2:  IORLW  00
18E4:  BZ    18F0
18E6:  INCF   28,F
18E8:  MOVWF  2A
18EA:  CALL   06F8
18EE:  BRA    18DC
....................        lcd_gotoxy(3,2);                  //escribir en a primera fila primera posicion  
18F0:  MOVLW  03
18F2:  MOVWF  2B
18F4:  MOVLW  02
18F6:  MOVWF  2C
18F8:  CALL   069C
....................        lcd_putc("DIGITE NU. CLAVE");     //clave[0]= y clave[1]= 
18FC:  CLRF   28
18FE:  MOVF   28,W
1900:  CALL   03A4
1904:  IORLW  00
1906:  BZ    1912
1908:  INCF   28,F
190A:  MOVWF  2A
190C:  CALL   06F8
1910:  BRA    18FE
....................        delay_ms(3000); 
1912:  MOVLW  0C
1914:  MOVWF  28
1916:  MOVLW  FA
1918:  MOVWF  2B
191A:  CALL   0590
191E:  DECFSZ 28,F
1920:  BRA    1916
....................        teclado(); 
1922:  CALL   0970
....................         
....................        dato1=clave[0]; 
1926:  MOVFF  14,1D
....................        dato2=clave[1]; 
192A:  MOVFF  15,1E
....................         
....................        lcd_putc('\f');                   //Limpiar pantalla comando 
192E:  MOVLW  0C
1930:  MOVWF  2A
1932:  CALL   06F8
....................        lcd_gotoxy(1,1);                  //escribir en a primera fila primera posicion  
1936:  MOVLW  01
1938:  MOVWF  2B
193A:  MOVWF  2C
193C:  CALL   069C
....................        lcd_putc("POR FAVOR DIGITE");     //lo que se escribe 
1940:  CLRF   28
1942:  MOVF   28,W
1944:  CALL   03C6
1948:  IORLW  00
194A:  BZ    1956
194C:  INCF   28,F
194E:  MOVWF  2A
1950:  CALL   06F8
1954:  BRA    1942
....................        lcd_gotoxy(1,2);                  //escribir en a primera fila primera posicion  
1956:  MOVLW  01
1958:  MOVWF  2B
195A:  MOVLW  02
195C:  MOVWF  2C
195E:  CALL   069C
....................        lcd_putc("DIGITE NUE.CLAVE");    
1962:  CLRF   28
1964:  MOVF   28,W
1966:  CALL   03E8
196A:  IORLW  00
196C:  BZ    1978
196E:  INCF   28,F
1970:  MOVWF  2A
1972:  CALL   06F8
1976:  BRA    1964
....................        delay_ms(3000); 
1978:  MOVLW  0C
197A:  MOVWF  28
197C:  MOVLW  FA
197E:  MOVWF  2B
1980:  CALL   0590
1984:  DECFSZ 28,F
1986:  BRA    197C
....................         
....................        teclado(); 
1988:  CALL   0970
....................         
....................        if(clave[0]==dato1 & clave[1]==dato2) 
198C:  MOVF   1D,W
198E:  SUBWF  14,W
1990:  BZ    1996
1992:  MOVLW  00
1994:  BRA    1998
1996:  MOVLW  01
1998:  MOVWF  28
199A:  MOVF   1E,W
199C:  SUBWF  15,W
199E:  BZ    19A4
19A0:  MOVLW  00
19A2:  BRA    19A6
19A4:  MOVLW  01
19A6:  ANDWF  28,W
19A8:  BZ    1A0C
....................        { 
....................         escribir_memoria(); 
19AA:  CALL   0C00
....................         lcd_putc('\f');                   //Limpiar pantalla comando 
19AE:  MOVLW  0C
19B0:  MOVWF  2A
19B2:  CALL   06F8
....................         lcd_gotoxy(1,1);                  //escribir en a primera fila primera posicion  
19B6:  MOVLW  01
19B8:  MOVWF  2B
19BA:  MOVWF  2C
19BC:  CALL   069C
....................         lcd_putc("CLAVE MODIFICADA");     //lo que se escribe 
19C0:  CLRF   28
19C2:  MOVF   28,W
19C4:  CALL   040A
19C8:  IORLW  00
19CA:  BZ    19D6
19CC:  INCF   28,F
19CE:  MOVWF  2A
19D0:  CALL   06F8
19D4:  BRA    19C2
....................         lcd_gotoxy(3,2);                  //escribir en a primera fila primera posicion  
19D6:  MOVLW  03
19D8:  MOVWF  2B
19DA:  MOVLW  02
19DC:  MOVWF  2C
19DE:  CALL   069C
....................         lcd_putc("CON EXITO");    
19E2:  CLRF   28
19E4:  MOVF   28,W
19E6:  CALL   042C
19EA:  IORLW  00
19EC:  BZ    19F8
19EE:  INCF   28,F
19F0:  MOVWF  2A
19F2:  CALL   06F8
19F6:  BRA    19E4
....................         delay_ms(3000); 
19F8:  MOVLW  0C
19FA:  MOVWF  28
19FC:  MOVLW  FA
19FE:  MOVWF  2B
1A00:  CALL   0590
1A04:  DECFSZ 28,F
1A06:  BRA    19FC
....................           goto David; 
1A08:  BRA    16A0
....................        } 
....................        else{ 
1A0A:  BRA    1A46
....................        lcd_putc('\f');                   //Limpiar pantalla comando 
1A0C:  MOVLW  0C
1A0E:  MOVWF  2A
1A10:  CALL   06F8
....................        lcd_gotoxy(1,1);                  //escribir en a primera fila primera posicion  
1A14:  MOVLW  01
1A16:  MOVWF  2B
1A18:  MOVWF  2C
1A1A:  CALL   069C
....................        lcd_putc("ERROR DE CLAVE");     //lo que se escribe 
1A1E:  CLRF   28
1A20:  MOVF   28,W
1A22:  CALL   0446
1A26:  IORLW  00
1A28:  BZ    1A34
1A2A:  INCF   28,F
1A2C:  MOVWF  2A
1A2E:  CALL   06F8
1A32:  BRA    1A20
....................        delay_ms(3000); 
1A34:  MOVLW  0C
1A36:  MOVWF  28
1A38:  MOVLW  FA
1A3A:  MOVWF  2B
1A3C:  CALL   0590
1A40:  DECFSZ 28,F
1A42:  BRA    1A38
....................        goto David; 
1A44:  BRA    16A0
....................        } 
....................         
....................      } 
....................      else if(datom==0x02) 
1A46:  BRA    1D4E
1A48:  MOVF   1F,W
1A4A:  SUBLW  02
1A4C:  BNZ   1AAC
....................      { 
....................        lcd_putc('\f');                  //Limpiar pantalla comando 
1A4E:  MOVLW  0C
1A50:  MOVWF  2A
1A52:  CALL   06F8
....................        lcd_gotoxy(1,1);                 //escribir en a primera fila primera posicion  
1A56:  MOVLW  01
1A58:  MOVWF  2B
1A5A:  MOVWF  2C
1A5C:  CALL   069C
....................        lcd_putc("MEN FECHA Y HORA");    //lo que se escribe 
1A60:  CLRF   28
1A62:  MOVF   28,W
1A64:  CALL   0466
1A68:  IORLW  00
1A6A:  BZ    1A76
1A6C:  INCF   28,F
1A6E:  MOVWF  2A
1A70:  CALL   06F8
1A74:  BRA    1A62
....................        lcd_gotoxy(3,2);                 //escribir en a primera fila primera posicion  
1A76:  MOVLW  03
1A78:  MOVWF  2B
1A7A:  MOVLW  02
1A7C:  MOVWF  2C
1A7E:  CALL   069C
....................        lcd_putc("EN CONSTRUCCION"); 
1A82:  CLRF   28
1A84:  MOVF   28,W
1A86:  CALL   0488
1A8A:  IORLW  00
1A8C:  BZ    1A98
1A8E:  INCF   28,F
1A90:  MOVWF  2A
1A92:  CALL   06F8
1A96:  BRA    1A84
....................        delay_ms(3000); 
1A98:  MOVLW  0C
1A9A:  MOVWF  28
1A9C:  MOVLW  FA
1A9E:  MOVWF  2B
1AA0:  CALL   0590
1AA4:  DECFSZ 28,F
1AA6:  BRA    1A9C
....................        goto David; 
1AA8:  BRA    16A0
....................      } 
....................     else  if(datom==0x03) 
1AAA:  BRA    1D4E
1AAC:  MOVF   1F,W
1AAE:  SUBLW  03
1AB0:  BNZ   1B10
....................      { 
....................        lcd_putc('\f');                //Limpiar pantalla comando 
1AB2:  MOVLW  0C
1AB4:  MOVWF  2A
1AB6:  CALL   06F8
....................        lcd_gotoxy(1,1);               //escribir en a primera fila primera posicion  
1ABA:  MOVLW  01
1ABC:  MOVWF  2B
1ABE:  MOVWF  2C
1AC0:  CALL   069C
....................        lcd_putc("MENU REPORTES");     //lo que se escribe 
1AC4:  CLRF   28
1AC6:  MOVF   28,W
1AC8:  CALL   04A8
1ACC:  IORLW  00
1ACE:  BZ    1ADA
1AD0:  INCF   28,F
1AD2:  MOVWF  2A
1AD4:  CALL   06F8
1AD8:  BRA    1AC6
....................        lcd_gotoxy(3,2);               //escribir en a primera fila primera posicion  
1ADA:  MOVLW  03
1ADC:  MOVWF  2B
1ADE:  MOVLW  02
1AE0:  MOVWF  2C
1AE2:  CALL   069C
....................        lcd_putc("EN CONSTRUCCION"); 
1AE6:  CLRF   28
1AE8:  MOVF   28,W
1AEA:  CALL   0488
1AEE:  IORLW  00
1AF0:  BZ    1AFC
1AF2:  INCF   28,F
1AF4:  MOVWF  2A
1AF6:  CALL   06F8
1AFA:  BRA    1AE8
....................        delay_ms(3000); 
1AFC:  MOVLW  0C
1AFE:  MOVWF  28
1B00:  MOVLW  FA
1B02:  MOVWF  2B
1B04:  CALL   0590
1B08:  DECFSZ 28,F
1B0A:  BRA    1B00
....................        goto David;; 
1B0C:  BRA    16A0
....................      } 
....................     else if(datom==0x04) 
1B0E:  BRA    1D4E
1B10:  MOVF   1F,W
1B12:  SUBLW  04
1B14:  BNZ   1B74
....................      { 
....................        lcd_putc('\f');               //Limpiar pantalla comando 
1B16:  MOVLW  0C
1B18:  MOVWF  2A
1B1A:  CALL   06F8
....................        lcd_gotoxy(1,1);              //escribir en a primera fila primera posicion  
1B1E:  MOVLW  01
1B20:  MOVWF  2B
1B22:  MOVWF  2C
1B24:  CALL   069C
....................        lcd_putc("MEN MOTOR PAS A."); //lo que se escribe 
1B28:  CLRF   28
1B2A:  MOVF   28,W
1B2C:  CALL   04C6
1B30:  IORLW  00
1B32:  BZ    1B3E
1B34:  INCF   28,F
1B36:  MOVWF  2A
1B38:  CALL   06F8
1B3C:  BRA    1B2A
....................        lcd_gotoxy(3,2);              //escribir en a primera fila primera posicion  
1B3E:  MOVLW  03
1B40:  MOVWF  2B
1B42:  MOVLW  02
1B44:  MOVWF  2C
1B46:  CALL   069C
....................        lcd_putc("EN CONSTRUCCION"); 
1B4A:  CLRF   28
1B4C:  MOVF   28,W
1B4E:  CALL   0488
1B52:  IORLW  00
1B54:  BZ    1B60
1B56:  INCF   28,F
1B58:  MOVWF  2A
1B5A:  CALL   06F8
1B5E:  BRA    1B4C
....................        delay_ms(3000); 
1B60:  MOVLW  0C
1B62:  MOVWF  28
1B64:  MOVLW  FA
1B66:  MOVWF  2B
1B68:  CALL   0590
1B6C:  DECFSZ 28,F
1B6E:  BRA    1B64
....................        goto David; 
1B70:  BRA    16A0
....................      } 
....................     else if(datom==0x05) 
1B72:  BRA    1D4E
1B74:  MOVF   1F,W
1B76:  SUBLW  05
1B78:  BNZ   1BD8
....................      { 
....................        lcd_putc('\f');              //Limpiar pantalla comando 
1B7A:  MOVLW  0C
1B7C:  MOVWF  2A
1B7E:  CALL   06F8
....................        lcd_gotoxy(1,1);             //escribir en a primera fila primera posicion  
1B82:  MOVLW  01
1B84:  MOVWF  2B
1B86:  MOVWF  2C
1B88:  CALL   069C
....................        lcd_putc("MEN SERVOMOTOR");  //lo que se escribe 
1B8C:  CLRF   28
1B8E:  MOVF   28,W
1B90:  CALL   04E8
1B94:  IORLW  00
1B96:  BZ    1BA2
1B98:  INCF   28,F
1B9A:  MOVWF  2A
1B9C:  CALL   06F8
1BA0:  BRA    1B8E
....................        lcd_gotoxy(3,2);             //escribir en a primera fila primera posicion  
1BA2:  MOVLW  03
1BA4:  MOVWF  2B
1BA6:  MOVLW  02
1BA8:  MOVWF  2C
1BAA:  CALL   069C
....................        lcd_putc("EN CONSTRUCCION"); 
1BAE:  CLRF   28
1BB0:  MOVF   28,W
1BB2:  CALL   0488
1BB6:  IORLW  00
1BB8:  BZ    1BC4
1BBA:  INCF   28,F
1BBC:  MOVWF  2A
1BBE:  CALL   06F8
1BC2:  BRA    1BB0
....................        delay_ms(3000); 
1BC4:  MOVLW  0C
1BC6:  MOVWF  28
1BC8:  MOVLW  FA
1BCA:  MOVWF  2B
1BCC:  CALL   0590
1BD0:  DECFSZ 28,F
1BD2:  BRA    1BC8
....................        goto David; 
1BD4:  BRA    16A0
....................      } 
....................     else if(datom==0x06) 
1BD6:  BRA    1D4E
1BD8:  MOVF   1F,W
1BDA:  SUBLW  06
1BDC:  BNZ   1C3C
....................      { 
....................        lcd_putc('\f');               //Limpiar pantalla comando 
1BDE:  MOVLW  0C
1BE0:  MOVWF  2A
1BE2:  CALL   06F8
....................        lcd_gotoxy(1,1);              //escribir en a primera fila primera posicion  
1BE6:  MOVLW  01
1BE8:  MOVWF  2B
1BEA:  MOVWF  2C
1BEC:  CALL   069C
....................        lcd_putc("MENU CAD");         //lo que se escribe 
1BF0:  CLRF   28
1BF2:  MOVF   28,W
1BF4:  CALL   0508
1BF8:  IORLW  00
1BFA:  BZ    1C06
1BFC:  INCF   28,F
1BFE:  MOVWF  2A
1C00:  CALL   06F8
1C04:  BRA    1BF2
....................        lcd_gotoxy(3,2);              //escribir en a primera fila primera posicion  
1C06:  MOVLW  03
1C08:  MOVWF  2B
1C0A:  MOVLW  02
1C0C:  MOVWF  2C
1C0E:  CALL   069C
....................        lcd_putc("EN CONSTRUCCION"); 
1C12:  CLRF   28
1C14:  MOVF   28,W
1C16:  CALL   0488
1C1A:  IORLW  00
1C1C:  BZ    1C28
1C1E:  INCF   28,F
1C20:  MOVWF  2A
1C22:  CALL   06F8
1C26:  BRA    1C14
....................        delay_ms(3000); 
1C28:  MOVLW  0C
1C2A:  MOVWF  28
1C2C:  MOVLW  FA
1C2E:  MOVWF  2B
1C30:  CALL   0590
1C34:  DECFSZ 28,F
1C36:  BRA    1C2C
....................        goto David; 
1C38:  BRA    16A0
....................      } 
....................     else if(datom==0x07) 
1C3A:  BRA    1D4E
1C3C:  MOVF   1F,W
1C3E:  SUBLW  07
1C40:  BNZ   1CA0
....................      { 
....................        lcd_putc('\f');               //Limpiar pantalla comando 
1C42:  MOVLW  0C
1C44:  MOVWF  2A
1C46:  CALL   06F8
....................        lcd_gotoxy(1,1);              //escribir en a primera fila primera posicion  
1C4A:  MOVLW  01
1C4C:  MOVWF  2B
1C4E:  MOVWF  2C
1C50:  CALL   069C
....................        lcd_putc("MEN DTMF");         //lo que se escribe 
1C54:  CLRF   28
1C56:  MOVF   28,W
1C58:  CALL   0522
1C5C:  IORLW  00
1C5E:  BZ    1C6A
1C60:  INCF   28,F
1C62:  MOVWF  2A
1C64:  CALL   06F8
1C68:  BRA    1C56
....................        lcd_gotoxy(3,2);              //escribir en a primera fila primera posicion  
1C6A:  MOVLW  03
1C6C:  MOVWF  2B
1C6E:  MOVLW  02
1C70:  MOVWF  2C
1C72:  CALL   069C
....................        lcd_putc("EN CONSTRUCCION"); 
1C76:  CLRF   28
1C78:  MOVF   28,W
1C7A:  CALL   0488
1C7E:  IORLW  00
1C80:  BZ    1C8C
1C82:  INCF   28,F
1C84:  MOVWF  2A
1C86:  CALL   06F8
1C8A:  BRA    1C78
....................        delay_ms(3000); 
1C8C:  MOVLW  0C
1C8E:  MOVWF  28
1C90:  MOVLW  FA
1C92:  MOVWF  2B
1C94:  CALL   0590
1C98:  DECFSZ 28,F
1C9A:  BRA    1C90
....................        goto David; 
1C9C:  BRA    16A0
....................      } 
....................     else if(datom==0x08) 
1C9E:  BRA    1D4E
1CA0:  MOVF   1F,W
1CA2:  SUBLW  08
1CA4:  BNZ   1D04
....................      { 
....................        lcd_putc('\f');              //Limpiar pantalla comando 
1CA6:  MOVLW  0C
1CA8:  MOVWF  2A
1CAA:  CALL   06F8
....................        lcd_gotoxy(1,1);             //escribir en a primera fila primera posicion  
1CAE:  MOVLW  01
1CB0:  MOVWF  2B
1CB2:  MOVWF  2C
1CB4:  CALL   069C
....................        lcd_putc("MEN SENSORES");    //lo que se escribe 
1CB8:  CLRF   28
1CBA:  MOVF   28,W
1CBC:  CALL   053C
1CC0:  IORLW  00
1CC2:  BZ    1CCE
1CC4:  INCF   28,F
1CC6:  MOVWF  2A
1CC8:  CALL   06F8
1CCC:  BRA    1CBA
....................        lcd_gotoxy(3,2);             //escribir en a primera fila primera posicion  
1CCE:  MOVLW  03
1CD0:  MOVWF  2B
1CD2:  MOVLW  02
1CD4:  MOVWF  2C
1CD6:  CALL   069C
....................        lcd_putc("EN CONSTRUCCION"); 
1CDA:  CLRF   28
1CDC:  MOVF   28,W
1CDE:  CALL   0488
1CE2:  IORLW  00
1CE4:  BZ    1CF0
1CE6:  INCF   28,F
1CE8:  MOVWF  2A
1CEA:  CALL   06F8
1CEE:  BRA    1CDC
....................        delay_ms(3000); 
1CF0:  MOVLW  0C
1CF2:  MOVWF  28
1CF4:  MOVLW  FA
1CF6:  MOVWF  2B
1CF8:  CALL   0590
1CFC:  DECFSZ 28,F
1CFE:  BRA    1CF4
....................        goto David; 
1D00:  BRA    16A0
....................      } 
....................     else if(datom==0x09) 
1D02:  BRA    1D4E
1D04:  MOVF   1F,W
1D06:  SUBLW  09
1D08:  BNZ   1D10
....................      { 
....................       goto admin; 
1D0A:  GOTO   0E08
....................      } 
....................      else{ 
1D0E:  BRA    1D4E
....................           lcd_putc('\f');                 //Limpiar pantalla comando 
1D10:  MOVLW  0C
1D12:  MOVWF  2A
1D14:  CALL   06F8
....................           lcd_gotoxy(1,2);                //escribir en a primera fila primera posicion  
1D18:  MOVLW  01
1D1A:  MOVWF  2B
1D1C:  MOVLW  02
1D1E:  MOVWF  2C
1D20:  CALL   069C
....................           lcd_putc("ERROR DE NUMERO");   //lo que se escribe 
1D24:  CLRF   28
1D26:  MOVF   28,W
1D28:  CALL   0210
1D2C:  IORLW  00
1D2E:  BZ    1D3A
1D30:  INCF   28,F
1D32:  MOVWF  2A
1D34:  CALL   06F8
1D38:  BRA    1D26
....................           delay_ms(3000); 
1D3A:  MOVLW  0C
1D3C:  MOVWF  28
1D3E:  MOVLW  FA
1D40:  MOVWF  2B
1D42:  CALL   0590
1D46:  DECFSZ 28,F
1D48:  BRA    1D3E
....................           goto menu; 
1D4A:  GOTO   0CA8
....................       } 
....................      }else{ 
1D4E:  BRA    1D8E
....................      lcd_putc('\f');                 //Limpiar pantalla comando 
1D50:  MOVLW  0C
1D52:  MOVWF  2A
1D54:  CALL   06F8
....................      lcd_gotoxy(1,2);                //escribir en a primera fila primera posicion  
1D58:  MOVLW  01
1D5A:  MOVWF  2B
1D5C:  MOVLW  02
1D5E:  MOVWF  2C
1D60:  CALL   069C
....................      lcd_putc("CONTRA. ERRONEA");   //lo que se escribe 
1D64:  CLRF   28
1D66:  MOVF   28,W
1D68:  CALL   0570
1D6C:  IORLW  00
1D6E:  BZ    1D7A
1D70:  INCF   28,F
1D72:  MOVWF  2A
1D74:  CALL   06F8
1D78:  BRA    1D66
....................      delay_ms(3000); 
1D7A:  MOVLW  0C
1D7C:  MOVWF  28
1D7E:  MOVLW  FA
1D80:  MOVWF  2B
1D82:  CALL   0590
1D86:  DECFSZ 28,F
1D88:  BRA    1D7E
....................      goto menu; 
1D8A:  GOTO   0CA8
....................      } 
....................    } 
....................  
1D8E:  SLEEP 

Configuration Fuses:
   Word  1: 0C00   NOIESO NOFCMEN HS PLL1 CPUDIV1 NOUSBDIV
   Word  2: 1E18   NOBROWNOUT NOWDT BORV20 PUT WDT32768 NOVREGEN
   Word  3: 0300   PBADEN CCP2C1 NOMCLR NOLPT1OSC
   Word  4: 0081   STVREN NODEBUG NOLVP NOXINST NOICPRT
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: E00F   NOWRT NOWRTD NOWRTC NOWRTB
   Word  7: 400F   NOEBTR NOEBTRB

ROM data:
F00000: 23 45 34 56 
