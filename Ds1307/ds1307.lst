CCS PCH C Compiler, Version 4.093, 51109               30-sept.-21 12:34

               Filename: C:\Proyecto arquitectura c\Ds1307\ds1307.lst

               ROM used: 9630 bytes (29%)
                         Largest free fragment is 23138
               RAM used: 139 (7%) at main() level
                         156 (8%) worst case
               Stack:    6 locations

*
0000:  GOTO   1330
.................... #include <18F4550.h> 
.................... //////// Standard Header file for the PIC18F4550 device //////////////// 
.................... #device PIC18F4550 
.................... #list 
....................  
.................... #fuses     HS,NOPROTECT,NOBROWNOUT,NOWDT,PUT,NOCPD,NODEBUG,NOLVP,NOMCLR  
.................... #use       delay(clock=20000000) 
*
05D0:  CLRF   FEA
05D2:  MOVLW  92
05D4:  MOVWF  FE9
05D6:  MOVF   FEF,W
05D8:  BZ    05F4
05DA:  MOVLW  06
05DC:  MOVWF  01
05DE:  CLRF   00
05E0:  DECFSZ 00,F
05E2:  BRA    05E0
05E4:  DECFSZ 01,F
05E6:  BRA    05DE
05E8:  MOVLW  7B
05EA:  MOVWF  00
05EC:  DECFSZ 00,F
05EE:  BRA    05EC
05F0:  DECFSZ FEF,F
05F2:  BRA    05DA
05F4:  RETLW  00
.................... #include   <stdlib.h>           //LIBRERIAS MATEMATICAS IGUAL LA DE ABAJO 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = TRUE, sign = FALSE, point = FALSE; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = FALSE; 
....................          if (c == '+') 
....................          { 
....................             sign = FALSE; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = TRUE; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = TRUE; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = TRUE, sign = FALSE, point = FALSE; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = FALSE; 
....................          if (c == '+') 
....................          { 
....................             sign = FALSE; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = TRUE; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = TRUE; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = TRUE, sign = FALSE, point = FALSE; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = FALSE; 
....................          if (c == '+') 
....................          { 
....................             sign = FALSE; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = TRUE; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = TRUE; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    BYTE t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=TRUE; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = FALSE; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include   <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float32)l); 
....................   res = 32768.0*(float32)l; 
....................   res += (float32)(unsigned int16)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float48)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float48)l); 
....................   res = 32768.0*(float32)l; 
....................   res += (float48)(unsigned int16)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float48)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float64)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float64)l); 
....................   res = 32768.0*(float64)l; 
....................   res += (float64)(unsigned int16)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float64)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y/LN2 - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y/LN2 - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y/LN2 - (float64)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {0.45145214, -9.0558803, 26.940971, -19.860189}; 
.................... float32 const ql[4] = {1.0000000,  -8.1354259, 16.780517, -9.9300943}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................    bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................       res = res*y2 + pl[2]; 
....................       res = res*y2 + pl[3]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + ql[2]; 
....................       r = r*y2 + ql[3]; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................     
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................    
....................       if(bit_test(data2,7)) 
....................          bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................       res = res*y2 + pl[2]; 
....................       res = res*y2 + pl[3]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + ql[2]; 
....................       r = r*y2 + ql[3]; 
....................  
....................       res = y*res/r; 
....................  
....................     data1 = *(((unsigned int8 *)(&x)+5)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+4)); 
....................     if(bit_test (data2,7)) 
....................        bit_set(data1,0); 
....................       
....................     n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................          r = -(float48)-n; 
....................       else 
....................          r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float32 const pl_64[4] = {0.45145214, -9.0558803, 26.940971, -19.860189}; 
.................... float32 const ql_64[4] = {1.0000000,  -8.1354259, 16.780517, -9.9300943}; 
.................... #endif 
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................       bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................     bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................    bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................      bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #define TWOBYPI          0.6366197723675813 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[4] = { 
....................       -0.499999993585, 
....................        0.041666636258, 
....................       -0.0013888361399, 
....................        0.00002476016134 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 3; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[4] = { 
....................       -0.499999993585, 
....................        0.041666636258, 
....................       -0.0013888361399, 
....................        0.00002476016134 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 3; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float48 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p[4] = { 
....................       -0.499999993585, 
....................        0.041666636258, 
....................       -0.0013888361399, 
....................        0.00002476016134 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 3; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #define   LCD_E    PIN_E2 
.................... #define   LCD_CK   PIN_E1 
.................... #define   LCD_DAT  PIN_E0 
.................... #include <LCD4x20_3PIN.c> //libreria LCD 
.................... // flex_lcd_3_pins.c 
....................  
.................... //Modificacin de Flex_lcd por Duende_Azul y Akenafab 
.................... //Trabaja con 3 pines y 74VHC164 
.................... //8-Bit Serial-In, Parallel-Out Shift Register 
....................  
.................... //La LCD se usa en modo 4bits 
.................... //Revisar diagrama de conexion Adjunto 
....................  
.................... //No esta habilitada la lectura del LCD 
.................... //RW debe ir a gnd 
....................  
.................... //Definir pines antes de llamar libreria// 
.................... //#define LCD_E     PIN_A0 
.................... //#define LCD_CK    PIN_A1    
.................... //#define LCD_DAT   PIN_A2 
....................  
.................... //======================================== 
.................... int RS_bit; 
.................... #define lcd_type 2        // 0=5x7, 1=5x10, 2=2 lines 
.................... #define lcd_line_two 0x40 // LCD RAM address for the 2nd line 
....................  
....................  
.................... int8 const LCD_INIT_STRING[4] = 
.................... { 
....................  0x20 | (lcd_type << 2), // Func set: 4-bit, 2 lines, 5x8 dots 
....................  0xc,                    // Display on 
....................  1,                      // Clear display 
....................  6                       // Increment cursor 
....................  }; 
.................... BYTE lcdline; 
....................  
.................... //------------------------------------- 
.................... void lcd_send_nibble(int8 nibble, int rs_bit) 
.................... { 
....................  
.................... int x; 
.................... if(RS_bit==1) 
05F6:  DECFSZ x9A,W
05F8:  BRA    05FC
....................    nibble=nibble|0x10; 
05FA:  BSF    x99.4
....................  
.................... for(x=0;x<5;x++){ 
05FC:  CLRF   x9B
05FE:  MOVF   x9B,W
0600:  SUBLW  04
0602:  BNC   0626
....................          output_bit(LCD_DAT,shift_right(&nibble,1,0)); 
0604:  BCF    FD8.0
0606:  RRCF   x99,F
0608:  BC    060E
060A:  BCF    F8D.0
060C:  BRA    0610
060E:  BSF    F8D.0
0610:  BCF    F96.0
....................          delay_cycles(1); 
0612:  NOP   
....................          output_low(LCD_CK); 
0614:  BCF    F96.1
0616:  BCF    F8D.1
....................          delay_us(1); 
0618:  BRA    061A
061A:  BRA    061C
061C:  NOP   
....................          output_high(LCD_CK);} 
061E:  BCF    F96.1
0620:  BSF    F8D.1
0622:  INCF   x9B,F
0624:  BRA    05FE
....................  
....................  
....................  
....................  output_high(LCD_E); 
0626:  BCF    F96.2
0628:  BSF    F8D.2
....................  delay_us(2); 
062A:  MOVLW  03
062C:  MOVWF  00
062E:  DECFSZ 00,F
0630:  BRA    062E
....................  output_low(LCD_E); 
0632:  BCF    F96.2
0634:  BCF    F8D.2
.................... } 
0636:  RETLW  00
....................  
.................... //----------------------------------- 
.................... //---------------------------------------- 
.................... // Send a byte to the LCD. 
.................... void lcd_send_byte(int8 address, int8 n) 
.................... { 
.................... //output_low(LCD_RS); 
.................... RS_bit=0; 
0638:  CLRF   0B
.................... delay_us(100); 
063A:  MOVLW  A6
063C:  MOVWF  00
063E:  DECFSZ 00,F
0640:  BRA    063E
0642:  NOP   
....................  
....................  
.................... if(address) 
0644:  MOVF   x96,F
0646:  BZ    064E
....................    //output_high(LCD_RS); 
....................    RS_bit=1; 
0648:  MOVLW  01
064A:  MOVWF  0B
.................... else 
064C:  BRA    0650
....................    //output_low(LCD_RS); 
....................    RS_bit=0; 
064E:  CLRF   0B
....................  
....................  delay_cycles(1); 
0650:  NOP   
....................  
....................  
.................... output_low(LCD_E); 
0652:  BCF    F96.2
0654:  BCF    F8D.2
....................  
.................... lcd_send_nibble(n >> 4,RS_bit); 
0656:  SWAPF  x97,W
0658:  MOVWF  x98
065A:  MOVLW  0F
065C:  ANDWF  x98,F
065E:  MOVFF  98,99
0662:  MOVFF  0B,9A
0666:  RCALL  05F6
.................... lcd_send_nibble(n & 0xf,RS_bit); 
0668:  MOVF   x97,W
066A:  ANDLW  0F
066C:  MOVWF  x98
066E:  MOVWF  x99
0670:  MOVFF  0B,9A
0674:  RCALL  05F6
.................... } 
0676:  RETLW  00
....................  
.................... //---------------------------- 
.................... void lcd_init(void) 
.................... { 
.................... int8 i; 
....................  
.................... //output_low(LCD_RS); 
.................... RS_bit=0; 
0678:  CLRF   0B
....................  
.................... output_low(LCD_E); 
067A:  BCF    F96.2
067C:  BCF    F8D.2
....................  
.................... delay_ms(20); 
067E:  MOVLW  14
0680:  MOVWF  x92
0682:  RCALL  05D0
....................  
.................... for(i=0 ;i < 3; i++) 
0684:  CLRF   x8A
0686:  MOVF   x8A,W
0688:  SUBLW  02
068A:  BNC   06A0
....................    { 
....................     lcd_send_nibble(0x03,RS_bit); 
068C:  MOVLW  03
068E:  MOVWF  x99
0690:  MOVFF  0B,9A
0694:  RCALL  05F6
....................     delay_ms(5); 
0696:  MOVLW  05
0698:  MOVWF  x92
069A:  RCALL  05D0
....................    } 
069C:  INCF   x8A,F
069E:  BRA    0686
....................  
.................... lcd_send_nibble(0x02,RS_bit); 
06A0:  MOVLW  02
06A2:  MOVWF  x99
06A4:  MOVFF  0B,9A
06A8:  RCALL  05F6
....................  
.................... for(i=0; i < sizeof(LCD_INIT_STRING); i++) 
06AA:  CLRF   x8A
06AC:  MOVF   x8A,W
06AE:  SUBLW  03
06B0:  BNC   06D4
....................    { 
....................     lcd_send_byte(0, LCD_INIT_STRING[i]); 
06B2:  CLRF   03
06B4:  MOVF   x8A,W
06B6:  MOVFF  FF2,8B
06BA:  BCF    FF2.7
06BC:  RCALL  0004
06BE:  BTFSC  x8B.7
06C0:  BSF    FF2.7
06C2:  MOVWF  x8B
06C4:  CLRF   x96
06C6:  MOVWF  x97
06C8:  RCALL  0638
....................  
....................     delay_ms(5); 
06CA:  MOVLW  05
06CC:  MOVWF  x92
06CE:  RCALL  05D0
....................      
....................    } 
06D0:  INCF   x8A,F
06D2:  BRA    06AC
....................  
.................... } 
06D4:  GOTO   146C (RETURN)
....................  
.................... //---------------------------- 
....................  
.................... void lcd_gotoxy(int8 x, int8 y) 
.................... { 
.................... int8 address; 
....................  
....................    switch(y) { 
*
06DC:  MOVLW  01
06DE:  SUBWF  x93,W
06E0:  ADDLW  FC
06E2:  BC    0702
06E4:  ADDLW  04
06E6:  GOTO   0716
....................      case 1 : address=0x80;break; 
06EA:  MOVLW  80
06EC:  MOVWF  x94
06EE:  BRA    0702
....................      case 2 : address=0xc0;break; 
06F0:  MOVLW  C0
06F2:  MOVWF  x94
06F4:  BRA    0702
....................      case 3 : address=0x94;break; 
06F6:  MOVLW  94
06F8:  MOVWF  x94
06FA:  BRA    0702
....................      case 4 : address=0xd4;break; 
06FC:  MOVLW  D4
06FE:  MOVWF  x94
0700:  BRA    0702
....................    } 
.................... address += x-1; 
0702:  MOVLW  01
0704:  SUBWF  x92,W
0706:  ADDWF  x94,F
.................... lcd_send_byte(0, 0x80 | address); 
0708:  MOVF   x94,W
070A:  IORLW  80
070C:  MOVWF  x95
070E:  CLRF   x96
0710:  MOVWF  x97
0712:  RCALL  0638
.................... } 
0714:  RETLW  00
....................  
.................... //----------------------------- 
.................... void lcd_putc(char c) 
.................... { 
....................  switch(c) 
....................    { 
*
0738:  MOVF   x91,W
073A:  XORLW  0C
073C:  BZ    0754
073E:  XORLW  06
0740:  BZ    0768
0742:  XORLW  02
0744:  BZ    0776
0746:  XORLW  6B
0748:  BZ    0780
074A:  XORLW  04
074C:  BZ    078A
074E:  XORLW  0F
0750:  BZ    0794
0752:  BRA    079E
....................     case '\f':                //limpia pantalla 
....................       lcd_send_byte(0,1); 
0754:  CLRF   x96
0756:  MOVLW  01
0758:  MOVWF  x97
075A:  RCALL  0638
....................       lcdline=1; 
075C:  MOVLW  01
075E:  MOVWF  0C
....................       delay_ms(8); 
0760:  MOVLW  08
0762:  MOVWF  x92
0764:  RCALL  05D0
....................       break; 
0766:  BRA    07AA
....................  
....................     case '\n':                //cambio de linea 
....................        lcd_gotoxy(1,++lcdline); 
0768:  INCF   0C,F
076A:  MOVLW  01
076C:  MOVWF  x92
076E:  MOVFF  0C,93
0772:  RCALL  06DC
....................        break; 
0774:  BRA    07AA
....................  
....................     case '\b':                //retrocede 1 caracter 
....................        lcd_send_byte(0,0x10); 
0776:  CLRF   x96
0778:  MOVLW  10
077A:  MOVWF  x97
077C:  RCALL  0638
....................        break; 
077E:  BRA    07AA
....................         
....................     case '\c':                //on display 
....................     lcd_send_byte(0,0x0c); 
0780:  CLRF   x96
0782:  MOVLW  0C
0784:  MOVWF  x97
0786:  RCALL  0638
....................     break; 
0788:  BRA    07AA
....................     
....................     case '\g':                 
....................     lcd_send_byte(0,0x0f);    // prende cursor y parpadea 
078A:  CLRF   x96
078C:  MOVLW  0F
078E:  MOVWF  x97
0790:  RCALL  0638
....................     break;   
0792:  BRA    07AA
....................  
....................     case '\h':                //retrocede 1 caracter 
....................     lcd_send_byte(0,0x0f);    // prende cursor y parpadea 
0794:  CLRF   x96
0796:  MOVLW  0F
0798:  MOVWF  x97
079A:  RCALL  0638
....................     break; 
079C:  BRA    07AA
....................      
....................     default: 
....................        lcd_send_byte(1,c); 
079E:  MOVLW  01
07A0:  MOVWF  x96
07A2:  MOVFF  91,97
07A6:  RCALL  0638
....................        break; 
07A8:  BRA    07AA
....................    } 
.................... } 
07AA:  RETLW  00
....................  
.................... //------------------------------ 
....................  
.................... void lcd_cursor_vb(short visible, short blink) {  
....................   lcd_send_byte(0, 0xC|(visible<<1)|blink);  
.................... }  
....................  
....................  
.................... #include <KBD18F.c>       //LIBRERIA TECLADO 
.................... //////////////////////////////////////////////////////////////////////////////////// 
.................... //                                   KBD.C                                        // 
.................... //               FUNCIONES PARA ESCANEO DE UN TECLADO MATRICIAL                   // 
.................... //                         4X4 HEXADECIMAL, EN EL PORTB                           // 
.................... //       kbd_init()       Debe ser invocada antes que las otras funciones.         // 
.................... //       c=lcd_getc(c)    Si h sido presionada una tecla devuelve el caracter c    // 
.................... //                  y lo salva en el char c, sino se presiona una tecla       // 
.................... //                  retorna el valor /0, esta funcin puede invocarse         // 
.................... //                  frecuentemente para no perder teclas pulsadas.            // 
.................... //        NOTA: REQUIERE COLOCAR RESISTENCIAS (2.2K) EN LOS PINES DE COLUMNAS     // 
.................... //               PINES DE COLUMNAS DE RB0(COL0) A RB3(COL3))                   // 
.................... //               PINES DE FILAS DE RB4(ROW0)) A RB7(ROW3))                    //  
.................... //                  MODIF.: ING. FRANK GIRALDO - UD                       // 
.................... //////////////////////////////////////////////////////////////////////////////////// 
.................... /*//////////////////////////////////////////////////////////////////////////////////  
.................... *    RB0 RB1 RB2 RB3    
.................... *     |   |   |   | 
.................... *     c0  c1  c2  c3   
.................... *   | 1 | 2 | 3 | F | r0 - RB4 
.................... *   | 4 | 5 | 6 | E | r1 - RB5 
.................... *   | 7 | 8 | 9 | D | r2 - RB6 
.................... *   | A | 0 | B | C | r3 - RB7 
.................... * 
.................... *   COLUMNS=OUTs 
.................... *   ROWS=INs 
.................... *   SE HABILITAN PULL-UP INTERNAS  
.................... *   SE REQUIERE COLOCAR RESISTENCIAS (2.2K) EN LOS PINES DE COLUMNAS  
.................... * 
.................... */////////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... #byte portkbd = 0XF81                  //portkbd = portB 
.................... //Keypad connection:   (Column 0 es B0) 
.................... //                Bx: 
.................... #define COL0 (0 << 0) 
.................... #define COL1 (0 << 1) 
.................... #define COL2 (0 << 2) 
.................... #define COL3 (0 << 3) 
.................... #define ROW0 (1 << 4) 
.................... #define ROW1 (1 << 5) 
.................... #define ROW2 (1 << 6) 
.................... #define ROW3 (1 << 7) 
.................... #define ALL_ROWS (ROW3|ROW2|ROW1|ROW0) 
.................... #define ALL_PINS (ALL_ROWS|COL3|COL2|COL1|COL0) 
....................  
.................... char const KEYS[4][4] = {{'1','2','3','A'}, 
....................                          {'4','5','6','B'}, 
....................                          {'7','8','9','C'}, 
....................                          {'*','0','#','D'}}; 
....................  
.................... #define KBD_DEBOUNCE_FACTOR 0.2 
.................... // Modifique el valor de temporizacin antirrebote con (KBD_DEBOUNCE_FACTOR = n/333), 
.................... // en donde n es el nmero de veces por segundo en los que ud. invoca 
.................... //la funcin kbd_getc(). 
.................... // 
....................  
.................... void kbd_init(){ 
.................... } 
*
06D8:  GOTO   1470 (RETURN)
....................  
.................... char kbd_getc( ) 
.................... { 
....................    static BYTE kbd_call_count; 
....................    static short int kbd_down; 
....................    static char last_key; 
....................    static BYTE col; 
....................    BYTE kchar; 
....................    BYTE row; 
....................    port_b_pullups(TRUE); 
*
0A44:  BCF    FF1.7
....................    kchar='\0'; 
0A46:  CLRF   x8A
....................  
....................    if(++kbd_call_count>KBD_DEBOUNCE_FACTOR) 
0A48:  INCF   0D,F
0A4A:  CLRF   x8D
0A4C:  MOVFF  0D,8C
0A50:  BRA    0994
0A52:  MOVLW  CD
0A54:  MOVWF  x8F
0A56:  MOVLW  CC
0A58:  MOVWF  x8E
0A5A:  MOVLW  4C
0A5C:  MOVWF  x8D
0A5E:  MOVLW  7C
0A60:  MOVWF  x8C
0A62:  MOVFF  03,93
0A66:  MOVFF  02,92
0A6A:  MOVFF  01,91
0A6E:  MOVFF  00,90
0A72:  BRA    09CC
0A74:  BNC   0B2C
....................    { 
....................        switch (col) 
....................        { 
0A76:  MOVF   10,W
0A78:  ADDLW  FC
0A7A:  BC    0AAA
0A7C:  ADDLW  04
0A7E:  GOTO   0B3A
....................          case 0   : set_tris_b(ALL_PINS&~COL0); 
0A82:  MOVLW  F0
0A84:  MOVWF  F93
....................                     portkbd=(0b1110); 
0A86:  MOVLW  0E
0A88:  MOVWF  F81
....................                     break; 
0A8A:  BRA    0AAA
....................  
....................          case 1   : set_tris_b(ALL_PINS&~COL1); 
0A8C:  MOVLW  F0
0A8E:  MOVWF  F93
....................                     portkbd=(0b1101); 
0A90:  MOVLW  0D
0A92:  MOVWF  F81
....................                     break; 
0A94:  BRA    0AAA
....................  
....................          case 2   : set_tris_b(ALL_PINS&~COL2); 
0A96:  MOVLW  F0
0A98:  MOVWF  F93
....................                     portkbd=(0b1011); 
0A9A:  MOVLW  0B
0A9C:  MOVWF  F81
....................                     break; 
0A9E:  BRA    0AAA
....................  
....................          case 3   : set_tris_b(ALL_PINS&~COL3); 
0AA0:  MOVLW  F0
0AA2:  MOVWF  F93
....................                     portkbd=(0b0111); 
0AA4:  MOVLW  07
0AA6:  MOVWF  F81
....................                     break; 
0AA8:  BRA    0AAA
....................        } 
....................  
....................        if(kbd_down) 
0AAA:  BTFSS  0E.0
0AAC:  BRA    0AC0
....................        { 
....................          if((portkbd & (ALL_ROWS))==(ALL_ROWS)) 
0AAE:  MOVF   F81,W
0AB0:  ANDLW  F0
0AB2:  SUBLW  F0
0AB4:  BNZ   0ABE
....................          { 
....................            kbd_down=FALSE; 
0AB6:  BCF    0E.0
....................            kchar=last_key; 
0AB8:  MOVFF  0F,8A
....................            last_key='\0'; 
0ABC:  CLRF   0F
....................          } 
....................        } 
....................        else 
0ABE:  BRA    0B2A
....................        { 
....................           if((portkbd & (ALL_ROWS))!=(ALL_ROWS)) 
0AC0:  MOVF   F81,W
0AC2:  ANDLW  F0
0AC4:  SUBLW  F0
0AC6:  BZ    0B20
....................           { 
....................              if((portkbd & ROW0) == 0) 
0AC8:  MOVF   F81,W
0ACA:  ANDLW  10
0ACC:  BNZ   0AD2
....................                row = 0; 
0ACE:  CLRF   x8B
....................              else if((portkbd & ROW1) == 0) 
0AD0:  BRA    0AF4
0AD2:  MOVF   F81,W
0AD4:  ANDLW  20
0AD6:  BNZ   0ADE
....................                row = 1; 
0AD8:  MOVLW  01
0ADA:  MOVWF  x8B
....................              else if((portkbd & ROW2) == 0) 
0ADC:  BRA    0AF4
0ADE:  MOVF   F81,W
0AE0:  ANDLW  40
0AE2:  BNZ   0AEA
....................                row = 2; 
0AE4:  MOVLW  02
0AE6:  MOVWF  x8B
....................              else if((portkbd & ROW3) == 0) 
0AE8:  BRA    0AF4
0AEA:  MOVF   F81,W
0AEC:  ANDLW  80
0AEE:  BNZ   0AF4
....................                row = 3; 
0AF0:  MOVLW  03
0AF2:  MOVWF  x8B
....................              last_key = KEYS[row][col]; 
0AF4:  MOVF   x8B,W
0AF6:  MULLW  04
0AF8:  MOVF   FF3,W
0AFA:  CLRF   x8D
0AFC:  MOVWF  x8C
0AFE:  CLRF   03
0B00:  MOVF   10,W
0B02:  ADDWF  x8C,W
0B04:  MOVWF  01
0B06:  MOVF   x8D,W
0B08:  ADDWFC 03,F
0B0A:  MOVF   01,W
0B0C:  MOVFF  FF2,8C
0B10:  BCF    FF2.7
0B12:  CALL   0018
0B16:  BTFSC  x8C.7
0B18:  BSF    FF2.7
0B1A:  MOVWF  0F
....................              kbd_down = TRUE; 
0B1C:  BSF    0E.0
....................           } 
....................           else 
0B1E:  BRA    0B2A
....................           { 
....................              ++col; 
0B20:  INCF   10,F
....................              if(col==4) 
0B22:  MOVF   10,W
0B24:  SUBLW  04
0B26:  BNZ   0B2A
....................              col=0; 
0B28:  CLRF   10
....................           } 
....................        } 
....................       kbd_call_count=0; 
0B2A:  CLRF   0D
....................    } 
....................   kchar = last_key; 
0B2C:  MOVFF  0F,8A
....................   set_tris_b(ALL_PINS); 
0B30:  MOVLW  F0
0B32:  MOVWF  F93
....................   return(kchar); 
0B34:  MOVFF  8A,01
.................... } 
0B38:  RETLW  00
....................  
.................... /*char dato; 
.................... char tecla() 
.................... { 
....................    dato='\0'; 
....................    while(dato=='\0') 
....................    { 
....................       dato=kbd_getc(); 
....................       delay_ms(100); 
....................    } 
.................... return dato; 
.................... } */ 
....................  
.................... #include <DS1307A.c>      //LIBRERIA RELOJ 
.................... /////////////////////////////////////////////////////////////////////////////////////// 
.................... ///                               DS1307.C                                           /// 
.................... ///                     Driver for Real Time Clock                                   /// 
.................... ///                     modified by Redpic 08/2006                                   /// 
.................... ///                  http://picmania.garcia-cuervo.com                               /// 
.................... ///                                                                                  /// 
.................... /// void ds1307_init(val)                                                            /// 
.................... ///                  - Enable oscillator without clearing the seconds register       /// 
.................... ///                    used when PIC loses power and DS1307 run from 3V BAT          /// 
.................... ///                  - Config Control Register with next parameters:                 /// 
.................... ///                     DS1307_ALL_DISABLED          All disabled                    /// 
.................... ///                     DS1307_OUT_ON_DISABLED_HIHG  Out to Hight on Disable Out     /// 
.................... ///                     DS1307_OUT_ENABLED           Out Enabled                     /// 
.................... ///                     DS1307_OUT_1_HZ              Freq. Out to 1 Hz               /// 
.................... ///                     DS1307_OUT_4_KHZ             Freq. Out to 4.096 Khz          /// 
.................... ///                     DS1307_OUT_8_KHZ             Freq. Out to 8.192 Khz          /// 
.................... ///                     DS1307_OUT_32_KHZ            Freq. Out to 32.768 Khz         /// 
.................... ///                                                                                  /// 
.................... ///                     Example init:                                                /// 
.................... ///                     ds1307_init(DS1307_ALL_DISABLED);                            /// 
.................... ///                     ds1307_init(DS1307_OUT_ENABLED | DS1307_OUT_1_HZ);           /// 
.................... ///                                                                                  /// 
.................... /// void ds1307_set_date_time(day,mth,year,dow,hour,min,sec) - Set the date/time     /// 
.................... ///                                                                                  /// 
.................... /// void ds1307_get_date(day,mth,year,dow)                   - Get the date          /// 
.................... ///                                                                                  /// 
.................... /// void ds1307_get_time(hr,min,sec)                         - Get the time          /// 
.................... ///                                                                                  /// 
.................... /// char ds1307_read_nvram_byte(char addr)                   - Read byte in address  /// 
.................... ///                                                                                  /// 
.................... /// void ds1307_write_nvram_byte(char addr, char value)      - Write byte in address /// 
.................... ///                                                                                  /// 
.................... /// void ds1307_get_day_of_week(char* ptr)                   - Get string Day Of Week/// 
.................... ///                                                                                  /// 
.................... /// If defined USE_INTERRUPTS all functions disable Global Interrupts on starts and  /// 
.................... ///                           enable Global on ends else usar can do it hiself       /// 
.................... ///                                                                                  /// 
.................... /////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef RTC_SDA 
.................... #define RTC_SDA  PIN_A1 
.................... #define RTC_SCL  PIN_A0 
.................... #endif 
....................  
.................... #use i2c(master, sda=RTC_SDA, scl=RTC_SCL) 
*
0E86:  MOVLW  08
0E88:  MOVWF  01
0E8A:  MOVLW  05
0E8C:  MOVWF  00
0E8E:  DECFSZ 00,F
0E90:  BRA    0E8E
0E92:  BCF    F89.0
0E94:  BCF    F92.0
0E96:  MOVLW  06
0E98:  MOVWF  00
0E9A:  DECFSZ 00,F
0E9C:  BRA    0E9A
0E9E:  RLCF   x8E,F
0EA0:  BCF    F89.1
0EA2:  BTFSC  FD8.0
0EA4:  BSF    F92.1
0EA6:  BTFSS  FD8.0
0EA8:  BCF    F92.1
0EAA:  BSF    F92.0
0EAC:  BTFSS  F80.0
0EAE:  BRA    0EAC
0EB0:  DECFSZ 01,F
0EB2:  BRA    0E8A
0EB4:  MOVLW  05
0EB6:  MOVWF  00
0EB8:  DECFSZ 00,F
0EBA:  BRA    0EB8
0EBC:  BCF    F89.0
0EBE:  BCF    F92.0
0EC0:  NOP   
0EC2:  BSF    F92.1
0EC4:  MOVLW  06
0EC6:  MOVWF  00
0EC8:  DECFSZ 00,F
0ECA:  BRA    0EC8
0ECC:  MOVLW  06
0ECE:  MOVWF  00
0ED0:  DECFSZ 00,F
0ED2:  BRA    0ED0
0ED4:  BSF    F92.0
0ED6:  BTFSS  F80.0
0ED8:  BRA    0ED6
0EDA:  CLRF   01
0EDC:  MOVLW  06
0EDE:  MOVWF  00
0EE0:  DECFSZ 00,F
0EE2:  BRA    0EE0
0EE4:  BTFSC  F80.1
0EE6:  BSF    01.0
0EE8:  BCF    F89.0
0EEA:  BCF    F92.0
0EEC:  BCF    F89.1
0EEE:  BCF    F92.1
0EF0:  RETLW  00
0EF2:  MOVLW  08
0EF4:  MOVWF  x8F
0EF6:  MOVFF  00,90
0EFA:  BSF    F92.1
0EFC:  MOVLW  06
0EFE:  MOVWF  00
0F00:  DECFSZ 00,F
0F02:  BRA    0F00
0F04:  BSF    F92.0
0F06:  BTFSS  F80.0
0F08:  BRA    0F06
0F0A:  BTFSC  F80.1
0F0C:  BSF    FD8.0
0F0E:  BTFSS  F80.1
0F10:  BCF    FD8.0
0F12:  RLCF   01,F
0F14:  MOVLW  05
0F16:  MOVWF  00
0F18:  DECFSZ 00,F
0F1A:  BRA    0F18
0F1C:  BCF    F92.0
0F1E:  BCF    F89.0
0F20:  DECFSZ x8F,F
0F22:  BRA    0EFA
0F24:  BSF    F92.1
0F26:  MOVLW  06
0F28:  MOVWF  00
0F2A:  DECFSZ 00,F
0F2C:  BRA    0F2A
0F2E:  BCF    F89.1
0F30:  MOVF   x90,W
0F32:  BTFSS  FD8.2
0F34:  BCF    F92.1
0F36:  NOP   
0F38:  BSF    F92.0
0F3A:  BTFSS  F80.0
0F3C:  BRA    0F3A
0F3E:  MOVLW  05
0F40:  MOVWF  00
0F42:  DECFSZ 00,F
0F44:  BRA    0F42
0F46:  BCF    F89.0
0F48:  BCF    F92.0
0F4A:  MOVLW  06
0F4C:  MOVWF  00
0F4E:  DECFSZ 00,F
0F50:  BRA    0F4E
0F52:  BCF    F89.1
0F54:  BCF    F92.1
0F56:  RETLW  00
....................  
.................... #define DS1307_ALL_DISABLED         0b00000000 // All disabled 
.................... #define DS1307_OUT_ON_DISABLED_HIHG 0b10000000 // Out to Hight on Disable Out 
.................... #define DS1307_OUT_ENABLED          0b00010000 // Out Enabled 
.................... #define DS1307_OUT_1_HZ             0b00000000 // Freq. Out to 1 Hz 
.................... #define DS1307_OUT_4_KHZ            0b00000001 // Freq. Out to 4.096 Khz 
.................... #define DS1307_OUT_8_KHZ            0b00000010 // Freq. Out to 8.192 Khz 
.................... #define DS1307_OUT_32_KHZ           0b00000011 // Freq. Out to 32.768 Khz 
....................  
.................... #define Start_user_address_nvram    0x08 
.................... #define End_user_address_nvram      0x3f 
....................  
.................... char days_of_week[7][11]={"Lunes\0","Martes\0","Mircoles\0","Jueves\0","Viernes\0","Sbado\0","Domingo\0"}; 
....................  
.................... byte ds1307_bin2bcd(byte binary_value); 
.................... byte ds1307_bcd2bin(byte bcd_value); 
....................  
.................... void ds1307_init(int val){ 
....................  
....................    byte seconds = 0; 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    disable_interrupts(global); 
.................... #endif 
....................  
....................    i2c_start(); 
....................    i2c_write(0xD0); 
....................    i2c_write(0x00); 
....................    i2c_start(); 
....................    i2c_write(0xD1); 
....................    seconds = ds1307_bcd2bin(i2c_read(0)); 
....................    i2c_stop(); 
....................    seconds &= 0x7F; 
....................  
....................    delay_us(3); 
....................  
....................    i2c_start(); 
....................    i2c_write(0xD0); 
....................    i2c_write(0x00); 
....................    i2c_write(ds1307_bin2bcd(seconds)); 
....................    i2c_start(); 
....................    i2c_write(0xD0); 
....................    i2c_write(0x07); 
....................    i2c_write(val); 
....................    i2c_stop(); 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    enable_interrupts(global); 
.................... #endif 
....................  
.................... } 
....................  
.................... void ds1307_set_date_time(byte day, byte mth, byte year, byte dow, byte hr, byte min, byte sec){ 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    disable_interrupts(global); 
.................... #endif 
....................  
....................   sec &= 0x7F; 
....................   hr &= 0x3F; 
....................  
....................   i2c_start(); 
....................   i2c_write(0xD0); 
....................   i2c_write(0x00); 
....................   i2c_write(ds1307_bin2bcd(sec)); 
....................   i2c_write(ds1307_bin2bcd(min)); 
....................   i2c_write(ds1307_bin2bcd(hr)); 
....................   i2c_write(ds1307_bin2bcd(dow)); 
....................   i2c_write(ds1307_bin2bcd(day)); 
....................   i2c_write(ds1307_bin2bcd(mth)); 
....................   i2c_write(ds1307_bin2bcd(year)); 
....................   i2c_stop(); 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    enable_interrupts(global); 
.................... #endif 
....................  
.................... } 
....................  
.................... void ds1307_get_date(byte &day, byte &mth, byte &year, byte &dow){ 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    disable_interrupts(global); 
*
1076:  BCF    FF2.6
1078:  BCF    FF2.7
107A:  BTFSC  FF2.7
107C:  BRA    1078
.................... #endif 
....................  
....................   i2c_start(); 
107E:  BSF    F92.1
1080:  MOVLW  05
1082:  MOVWF  00
1084:  DECFSZ 00,F
1086:  BRA    1084
1088:  BSF    F92.0
108A:  MOVLW  06
108C:  MOVWF  00
108E:  DECFSZ 00,F
1090:  BRA    108E
1092:  BCF    F89.1
1094:  BCF    F92.1
1096:  MOVLW  05
1098:  MOVWF  00
109A:  DECFSZ 00,F
109C:  BRA    109A
109E:  BCF    F89.0
10A0:  BCF    F92.0
....................   i2c_write(0xD0); 
10A2:  MOVLW  D0
10A4:  MOVWF  x8E
10A6:  RCALL  0E86
....................   i2c_write(0x03); 
10A8:  MOVLW  03
10AA:  MOVWF  x8E
10AC:  RCALL  0E86
....................   i2c_start(); 
10AE:  BSF    F92.1
10B0:  MOVLW  05
10B2:  MOVWF  00
10B4:  DECFSZ 00,F
10B6:  BRA    10B4
10B8:  BSF    F92.0
10BA:  MOVLW  06
10BC:  MOVWF  00
10BE:  DECFSZ 00,F
10C0:  BRA    10BE
10C2:  BTFSS  F80.0
10C4:  BRA    10C2
10C6:  BCF    F89.1
10C8:  BCF    F92.1
10CA:  MOVLW  05
10CC:  MOVWF  00
10CE:  DECFSZ 00,F
10D0:  BRA    10CE
10D2:  BCF    F89.0
10D4:  BCF    F92.0
....................   i2c_write(0xD1); 
10D6:  MOVLW  D1
10D8:  MOVWF  x8E
10DA:  RCALL  0E86
....................   dow  = ds1307_bcd2bin(i2c_read() & 0x7f); 
10DC:  MOVLW  01
10DE:  MOVWF  00
10E0:  RCALL  0EF2
10E2:  MOVF   01,W
10E4:  ANDLW  7F
10E6:  MOVWF  x8A
10E8:  MOVWF  x8F
10EA:  RCALL  0F58
10EC:  MOVFF  01,88
....................   day  = ds1307_bcd2bin(i2c_read() & 0x3f); 
10F0:  MOVLW  01
10F2:  MOVWF  00
10F4:  RCALL  0EF2
10F6:  MOVF   01,W
10F8:  ANDLW  3F
10FA:  MOVWF  x8A
10FC:  MOVWF  x8F
10FE:  RCALL  0F58
1100:  MOVFF  01,85
....................   mth  = ds1307_bcd2bin(i2c_read() & 0x1f); 
1104:  MOVLW  01
1106:  MOVWF  00
1108:  RCALL  0EF2
110A:  MOVF   01,W
110C:  ANDLW  1F
110E:  MOVWF  x8A
1110:  MOVWF  x8F
1112:  RCALL  0F58
1114:  MOVFF  01,86
....................   year = ds1307_bcd2bin(i2c_read(0)); 
1118:  CLRF   00
111A:  RCALL  0EF2
111C:  MOVFF  01,8A
1120:  MOVFF  01,8F
1124:  RCALL  0F58
1126:  MOVFF  01,87
....................   i2c_stop(); 
112A:  BCF    F92.1
112C:  NOP   
112E:  BSF    F92.0
1130:  BTFSS  F80.0
1132:  BRA    1130
1134:  MOVLW  05
1136:  MOVWF  00
1138:  DECFSZ 00,F
113A:  BRA    1138
113C:  BRA    113E
113E:  NOP   
1140:  BSF    F92.1
1142:  MOVLW  05
1144:  MOVWF  00
1146:  DECFSZ 00,F
1148:  BRA    1146
....................  
.................... #ifndef USE_INTERRUPTS 
....................    enable_interrupts(global); 
114A:  MOVLW  C0
114C:  IORWF  FF2,F
.................... #endif 
....................  
.................... } 
....................  
.................... void ds1307_get_time(byte &hr, byte &min, byte &sec){ 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    disable_interrupts(global); 
*
11DE:  BCF    FF2.6
11E0:  BCF    FF2.7
11E2:  BTFSC  FF2.7
11E4:  BRA    11E0
.................... #endif 
....................  
....................   i2c_start(); 
11E6:  BSF    F92.1
11E8:  MOVLW  05
11EA:  MOVWF  00
11EC:  DECFSZ 00,F
11EE:  BRA    11EC
11F0:  BSF    F92.0
11F2:  MOVLW  06
11F4:  MOVWF  00
11F6:  DECFSZ 00,F
11F8:  BRA    11F6
11FA:  BCF    F89.1
11FC:  BCF    F92.1
11FE:  MOVLW  05
1200:  MOVWF  00
1202:  DECFSZ 00,F
1204:  BRA    1202
1206:  BCF    F89.0
1208:  BCF    F92.0
....................   i2c_write(0xD0); 
120A:  MOVLW  D0
120C:  MOVWF  x8E
120E:  RCALL  0E86
....................   i2c_write(0x00); 
1210:  CLRF   x8E
1212:  RCALL  0E86
....................   i2c_start(); 
1214:  BSF    F92.1
1216:  MOVLW  05
1218:  MOVWF  00
121A:  DECFSZ 00,F
121C:  BRA    121A
121E:  BSF    F92.0
1220:  MOVLW  06
1222:  MOVWF  00
1224:  DECFSZ 00,F
1226:  BRA    1224
1228:  BTFSS  F80.0
122A:  BRA    1228
122C:  BCF    F89.1
122E:  BCF    F92.1
1230:  MOVLW  05
1232:  MOVWF  00
1234:  DECFSZ 00,F
1236:  BRA    1234
1238:  BCF    F89.0
123A:  BCF    F92.0
....................   i2c_write(0xD1); 
123C:  MOVLW  D1
123E:  MOVWF  x8E
1240:  RCALL  0E86
....................   sec = ds1307_bcd2bin(i2c_read() & 0x7f); 
1242:  MOVLW  01
1244:  MOVWF  00
1246:  RCALL  0EF2
1248:  MOVF   01,W
124A:  ANDLW  7F
124C:  MOVWF  x8A
124E:  MOVWF  x8F
1250:  RCALL  0F58
1252:  MOVFF  01,84
....................   min = ds1307_bcd2bin(i2c_read() & 0x7f); 
1256:  MOVLW  01
1258:  MOVWF  00
125A:  RCALL  0EF2
125C:  MOVF   01,W
125E:  ANDLW  7F
1260:  MOVWF  x8A
1262:  MOVWF  x8F
1264:  RCALL  0F58
1266:  MOVFF  01,83
....................   hr  = ds1307_bcd2bin(i2c_read(0) & 0x3f); 
126A:  CLRF   00
126C:  RCALL  0EF2
126E:  MOVF   01,W
1270:  ANDLW  3F
1272:  MOVWF  x8A
1274:  MOVWF  x8F
1276:  RCALL  0F58
1278:  MOVFF  01,82
....................   i2c_stop(); 
127C:  BCF    F92.1
127E:  NOP   
1280:  BSF    F92.0
1282:  BTFSS  F80.0
1284:  BRA    1282
1286:  MOVLW  05
1288:  MOVWF  00
128A:  DECFSZ 00,F
128C:  BRA    128A
128E:  BRA    1290
1290:  NOP   
1292:  BSF    F92.1
1294:  MOVLW  05
1296:  MOVWF  00
1298:  DECFSZ 00,F
129A:  BRA    1298
....................  
.................... #ifndef USE_INTERRUPTS 
....................    enable_interrupts(global); 
129C:  MOVLW  C0
129E:  IORWF  FF2,F
.................... #endif 
....................  
.................... } 
....................  
....................  
.................... char ds1307_read_nvram_byte(char addr){ 
....................  
....................    char retval; 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    disable_interrupts(global); 
.................... #endif 
....................  
....................    i2c_start(); 
....................    i2c_write(0xD0); 
....................    i2c_write(addr); 
....................  
....................    i2c_start(); 
....................    i2c_write(0xD1); 
....................    retval = i2c_read(0); 
....................    i2c_stop(); 
....................  
....................    return(retval); 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    enable_interrupts(global); 
.................... #endif 
....................  
.................... } 
....................  
.................... void ds1307_write_nvram_byte(char addr, char value){ 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    disable_interrupts(global); 
.................... #endif 
....................  
....................    i2c_start(); 
....................    i2c_write(0xD0); 
....................    i2c_write(addr); 
....................    i2c_write(value); 
....................    i2c_stop(); 
....................  
.................... #ifndef USE_INTERRUPTS 
....................    enable_interrupts(global); 
.................... #endif 
....................  
.................... } 
....................  
.................... void ds1307_get_day_of_week(char* ptr){ 
....................  
....................    byte lday; 
....................    byte lmonth; 
....................    byte lyr; 
....................    byte ldow; 
....................    ds1307_get_date(lday,lmonth,lyr,ldow); 
....................    sprintf(ptr,"%s",days_of_week[ldow]); 
.................... } 
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
....................  
.................... byte ds1307_bin2bcd(byte binary_value){ 
....................  
....................   byte temp; 
....................   byte retval; 
....................  
....................   temp = binary_value; 
....................   retval = 0; 
....................   while(1){ 
....................     if(temp >= 10){ 
....................       temp -= 10; 
....................       retval += 0x10; 
....................     }else{ 
....................       retval += temp; 
....................       break; 
....................     } 
....................   } 
....................   return(retval); 
.................... } 
....................  
.................... byte ds1307_bcd2bin(byte bcd_value){ 
....................  
....................   byte temp; 
....................  
....................   temp = bcd_value; 
*
0F58:  MOVFF  8F,90
....................   temp >>= 1; 
0F5C:  BCF    FD8.0
0F5E:  RRCF   x90,F
....................   temp &= 0x78; 
0F60:  MOVLW  78
0F62:  ANDWF  x90,F
....................   return(temp + (temp >> 2) + (bcd_value & 0x0f)); 
0F64:  RRCF   x90,W
0F66:  MOVWF  00
0F68:  RRCF   00,F
0F6A:  MOVLW  3F
0F6C:  ANDWF  00,F
0F6E:  MOVF   00,W
0F70:  ADDWF  x90,W
0F72:  MOVWF  x91
0F74:  MOVF   x8F,W
0F76:  ANDLW  0F
0F78:  ADDWF  x91,W
0F7A:  MOVWF  01
.................... } 
0F7C:  RETLW  00
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #include <24C512.c> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////   Library for a 24LC512 serial EEPROM                             //// 
.................... ////                                                                   //// 
.................... ////   init_ext_eeprom();    Call before the other functions are used  //// 
.................... ////                                                                   //// 
.................... ////   write_ext_eeprom(a, d);  Write the byte d to the address a      //// 
.................... ////                                                                   //// 
.................... ////   d = read_ext_eeprom(a);   Read the byte d from the address a    //// 
.................... ////                                                                   //// 
.................... ////   The main program may define eeprom_sda                          //// 
.................... ////   and eeprom_scl to override the defaults below.                  //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef EEPROM_SDA 
....................  
.................... #define EEPROM_SDA  PIN_A1 
.................... #define EEPROM_SCL  PIN_A0 
....................  
.................... #endif 
....................  
.................... #use i2c(master, sda=EEPROM_SDA, scl=EEPROM_SCL) 
*
07E8:  MOVLW  08
07EA:  MOVWF  01
07EC:  MOVLW  05
07EE:  MOVWF  00
07F0:  DECFSZ 00,F
07F2:  BRA    07F0
07F4:  BCF    F89.0
07F6:  BCF    F92.0
07F8:  MOVLW  06
07FA:  MOVWF  00
07FC:  DECFSZ 00,F
07FE:  BRA    07FC
0800:  RLCF   x91,F
0802:  BCF    F89.1
0804:  BTFSC  FD8.0
0806:  BSF    F92.1
0808:  BTFSS  FD8.0
080A:  BCF    F92.1
080C:  BSF    F92.0
080E:  BTFSS  F80.0
0810:  BRA    080E
0812:  DECFSZ 01,F
0814:  BRA    07EC
0816:  MOVLW  05
0818:  MOVWF  00
081A:  DECFSZ 00,F
081C:  BRA    081A
081E:  BCF    F89.0
0820:  BCF    F92.0
0822:  NOP   
0824:  BSF    F92.1
0826:  MOVLW  06
0828:  MOVWF  00
082A:  DECFSZ 00,F
082C:  BRA    082A
082E:  MOVLW  06
0830:  MOVWF  00
0832:  DECFSZ 00,F
0834:  BRA    0832
0836:  BSF    F92.0
0838:  BTFSS  F80.0
083A:  BRA    0838
083C:  CLRF   01
083E:  MOVLW  06
0840:  MOVWF  00
0842:  DECFSZ 00,F
0844:  BRA    0842
0846:  BTFSC  F80.1
0848:  BSF    01.0
084A:  BCF    F89.0
084C:  BCF    F92.0
084E:  BCF    F89.1
0850:  BCF    F92.1
0852:  RETLW  00
0854:  MOVLW  08
0856:  MOVWF  x90
0858:  MOVFF  00,91
085C:  BSF    F92.1
085E:  MOVLW  06
0860:  MOVWF  00
0862:  DECFSZ 00,F
0864:  BRA    0862
0866:  BSF    F92.0
0868:  BTFSS  F80.0
086A:  BRA    0868
086C:  BTFSC  F80.1
086E:  BSF    FD8.0
0870:  BTFSS  F80.1
0872:  BCF    FD8.0
0874:  RLCF   01,F
0876:  MOVLW  05
0878:  MOVWF  00
087A:  DECFSZ 00,F
087C:  BRA    087A
087E:  BCF    F92.0
0880:  BCF    F89.0
0882:  DECFSZ x90,F
0884:  BRA    085C
0886:  BSF    F92.1
0888:  MOVLW  06
088A:  MOVWF  00
088C:  DECFSZ 00,F
088E:  BRA    088C
0890:  BCF    F89.1
0892:  MOVF   x91,W
0894:  BTFSS  FD8.2
0896:  BCF    F92.1
0898:  NOP   
089A:  BSF    F92.0
089C:  BTFSS  F80.0
089E:  BRA    089C
08A0:  MOVLW  05
08A2:  MOVWF  00
08A4:  DECFSZ 00,F
08A6:  BRA    08A4
08A8:  BCF    F89.0
08AA:  BCF    F92.0
08AC:  MOVLW  06
08AE:  MOVWF  00
08B0:  DECFSZ 00,F
08B2:  BRA    08B0
08B4:  BCF    F89.1
08B6:  BCF    F92.1
08B8:  GOTO   092A (RETURN)
....................  
.................... #define EEPROM_ADDRESS long int 
.................... #define EEPROM_SIZE   65535 
....................  
.................... void init_ext_eeprom() 
.................... { 
....................    output_float(EEPROM_SCL); 
....................    output_float(EEPROM_SDA); 
....................  
.................... } 
....................  
.................... void write_ext_eeprom(long int address, BYTE data) 
.................... { 
....................    short int status; 
....................    i2c_start(); 
*
0D5C:  BSF    F92.1
0D5E:  MOVLW  05
0D60:  MOVWF  00
0D62:  DECFSZ 00,F
0D64:  BRA    0D62
0D66:  BSF    F92.0
0D68:  MOVLW  06
0D6A:  MOVWF  00
0D6C:  DECFSZ 00,F
0D6E:  BRA    0D6C
0D70:  BCF    F89.1
0D72:  BCF    F92.1
0D74:  MOVLW  05
0D76:  MOVWF  00
0D78:  DECFSZ 00,F
0D7A:  BRA    0D78
0D7C:  BCF    F89.0
0D7E:  BCF    F92.0
....................    i2c_write(0xa0); 
0D80:  MOVLW  A0
0D82:  MOVWF  x91
0D84:  RCALL  07E8
....................    i2c_write(address>>8); 
0D86:  MOVFF  8C,8F
0D8A:  CLRF   x90
0D8C:  MOVFF  8C,91
0D90:  RCALL  07E8
....................    i2c_write(address); 
0D92:  MOVFF  8B,91
0D96:  RCALL  07E8
....................    i2c_write(data); 
0D98:  MOVFF  8D,91
0D9C:  RCALL  07E8
....................    i2c_stop(); 
0D9E:  BCF    F92.1
0DA0:  NOP   
0DA2:  BSF    F92.0
0DA4:  BTFSS  F80.0
0DA6:  BRA    0DA4
0DA8:  MOVLW  05
0DAA:  MOVWF  00
0DAC:  DECFSZ 00,F
0DAE:  BRA    0DAC
0DB0:  BRA    0DB2
0DB2:  NOP   
0DB4:  BSF    F92.1
0DB6:  MOVLW  05
0DB8:  MOVWF  00
0DBA:  DECFSZ 00,F
0DBC:  BRA    0DBA
....................    i2c_start(); 
0DBE:  BSF    F92.1
0DC0:  MOVLW  05
0DC2:  MOVWF  00
0DC4:  DECFSZ 00,F
0DC6:  BRA    0DC4
0DC8:  BSF    F92.0
0DCA:  MOVLW  06
0DCC:  MOVWF  00
0DCE:  DECFSZ 00,F
0DD0:  BRA    0DCE
0DD2:  BCF    F89.1
0DD4:  BCF    F92.1
0DD6:  MOVLW  05
0DD8:  MOVWF  00
0DDA:  DECFSZ 00,F
0DDC:  BRA    0DDA
0DDE:  BCF    F89.0
0DE0:  BCF    F92.0
....................    status=i2c_write(0xa0); 
0DE2:  MOVLW  A0
0DE4:  MOVWF  x91
0DE6:  RCALL  07E8
0DE8:  MOVF   01,W
0DEA:  BCF    x8E.0
0DEC:  BTFSC  01.0
0DEE:  BSF    x8E.0
....................    while(status==1) 
....................    { 
0DF0:  BTFSS  x8E.0
0DF2:  BRA    0E2C
....................       i2c_start(); 
0DF4:  BSF    F92.1
0DF6:  MOVLW  05
0DF8:  MOVWF  00
0DFA:  DECFSZ 00,F
0DFC:  BRA    0DFA
0DFE:  BSF    F92.0
0E00:  MOVLW  06
0E02:  MOVWF  00
0E04:  DECFSZ 00,F
0E06:  BRA    0E04
0E08:  BTFSS  F80.0
0E0A:  BRA    0E08
0E0C:  BCF    F89.1
0E0E:  BCF    F92.1
0E10:  MOVLW  05
0E12:  MOVWF  00
0E14:  DECFSZ 00,F
0E16:  BRA    0E14
0E18:  BCF    F89.0
0E1A:  BCF    F92.0
....................       status=i2c_write(0xa0); 
0E1C:  MOVLW  A0
0E1E:  MOVWF  x91
0E20:  RCALL  07E8
0E22:  MOVF   01,W
0E24:  BCF    x8E.0
0E26:  BTFSC  01.0
0E28:  BSF    x8E.0
....................    } 
0E2A:  BRA    0DF0
....................    i2c_stop(); 
0E2C:  BCF    F92.1
0E2E:  NOP   
0E30:  BSF    F92.0
0E32:  BTFSS  F80.0
0E34:  BRA    0E32
0E36:  MOVLW  05
0E38:  MOVWF  00
0E3A:  DECFSZ 00,F
0E3C:  BRA    0E3A
0E3E:  BRA    0E40
0E40:  NOP   
0E42:  BSF    F92.1
0E44:  MOVLW  05
0E46:  MOVWF  00
0E48:  DECFSZ 00,F
0E4A:  BRA    0E48
.................... } 
0E4C:  GOTO   0E76 (RETURN)
....................  
.................... BYTE read_ext_eeprom(long int address) { 
....................    BYTE data; 
....................    i2c_start(); 
*
08BC:  BSF    F92.1
08BE:  MOVLW  05
08C0:  MOVWF  00
08C2:  DECFSZ 00,F
08C4:  BRA    08C2
08C6:  BSF    F92.0
08C8:  MOVLW  06
08CA:  MOVWF  00
08CC:  DECFSZ 00,F
08CE:  BRA    08CC
08D0:  BCF    F89.1
08D2:  BCF    F92.1
08D4:  MOVLW  05
08D6:  MOVWF  00
08D8:  DECFSZ 00,F
08DA:  BRA    08D8
08DC:  BCF    F89.0
08DE:  BCF    F92.0
....................    i2c_write(0xa0); 
08E0:  MOVLW  A0
08E2:  MOVWF  x91
08E4:  RCALL  07E8
....................    i2c_write(address>>8); 
08E6:  MOVFF  8D,8F
08EA:  CLRF   x90
08EC:  MOVFF  8D,91
08F0:  RCALL  07E8
....................    i2c_write(address); 
08F2:  MOVFF  8C,91
08F6:  RCALL  07E8
....................    i2c_start(); 
08F8:  BSF    F92.1
08FA:  MOVLW  05
08FC:  MOVWF  00
08FE:  DECFSZ 00,F
0900:  BRA    08FE
0902:  BSF    F92.0
0904:  MOVLW  06
0906:  MOVWF  00
0908:  DECFSZ 00,F
090A:  BRA    0908
090C:  BTFSS  F80.0
090E:  BRA    090C
0910:  BCF    F89.1
0912:  BCF    F92.1
0914:  MOVLW  05
0916:  MOVWF  00
0918:  DECFSZ 00,F
091A:  BRA    0918
091C:  BCF    F89.0
091E:  BCF    F92.0
....................    i2c_write(0xa1); 
0920:  MOVLW  A1
0922:  MOVWF  x91
0924:  RCALL  07E8
....................    data=i2c_read(0); 
0926:  CLRF   00
0928:  BRA    0854
092A:  MOVFF  01,8E
....................    i2c_stop(); 
092E:  BCF    F92.1
0930:  NOP   
0932:  BSF    F92.0
0934:  BTFSS  F80.0
0936:  BRA    0934
0938:  MOVLW  05
093A:  MOVWF  00
093C:  DECFSZ 00,F
093E:  BRA    093C
0940:  BRA    0942
0942:  NOP   
0944:  BSF    F92.1
0946:  MOVLW  05
0948:  MOVWF  00
094A:  DECFSZ 00,F
094C:  BRA    094A
....................    return(data); 
094E:  MOVFF  8E,01
.................... } 
0952:  GOTO   097A (RETURN)
....................  
.................... #ROM     0xf00000={0x4523}     //colocar 0 para usuario 1, estan al reves primero esta los dos digitos ultimos y luego los otros 
.................... #ROM     0xf00002={0x5634}     //esto es asignacion de claves para los usuarios 
.................... #define SW PIN A5 
.................... //Vamos a nombrar los registros de proposito GRAL 
.................... int i, b, dato, clave[4], datoi[4], datoe[4], adres,  dato1, dato2; 
.................... char datom; 
.................... float valor; 
.................... short flag; 
.................... long segundos, auxsegundos; 
.................... int hour, min, day, mth, year, dow, sec, time[8]; 
.................... //long contador; 
....................  
.................... /************************** 
.................... SECCION DE METODOS 
.................... ************************/ 
....................  
.................... void teclado() 
.................... {  
....................      lcd_putc('\f'); 
*
0B5C:  MOVLW  0C
0B5E:  MOVWF  x91
0B60:  RCALL  0738
....................     segundos=0; 
0B62:  CLRF   x78
0B64:  CLRF   x77
....................     auxsegundos=0; 
0B66:  CLRF   x7A
0B68:  CLRF   x79
....................     b=6; 
0B6A:  MOVLW  06
0B6C:  MOVWF  x61
....................      for(i=0;i<4; i++) 
0B6E:  CLRF   x60
0B70:  MOVF   x60,W
0B72:  SUBLW  03
0B74:  BTFSS  FD8.0
0B76:  BRA    0CD6
....................       { 
....................         do{ 
....................             datom=kbd_getc(); // escanea teclado 
0B78:  RCALL  0A44
0B7A:  MOVFF  01,72
....................             delay_ms(60); 
0B7E:  MOVLW  3C
0B80:  MOVWF  x92
0B82:  RCALL  05D0
....................              if(datom!='\0')  //si hay dato valido 
0B84:  MOVF   x72,F
0B86:  BTFSC  FD8.2
0B88:  BRA    0C7A
....................               { 
....................                  switch (i+1) 
....................                   { 
0B8A:  MOVLW  01
0B8C:  ADDWF  x60,W
0B8E:  ADDLW  FF
0B90:  ADDLW  FC
0B92:  BTFSC  FD8.0
0B94:  BRA    0C62
0B96:  ADDLW  04
0B98:  GOTO   0CD8
....................                    case 1: 
....................                    lcd_gotoxy(6,1); 
0B9C:  MOVLW  06
0B9E:  MOVWF  x92
0BA0:  MOVLW  01
0BA2:  MOVWF  x93
0BA4:  RCALL  06DC
....................                    lcd_putc(datom); 
0BA6:  MOVFF  72,91
0BAA:  RCALL  0738
....................                    //printf(lcd_putc,datom); 
....................                    clave[0]=datom-0X30; 
0BAC:  MOVLW  30
0BAE:  SUBWF  x72,W
0BB0:  MOVWF  x63
....................                    swap(clave[0]); 
0BB2:  SWAPF  x63,F
....................                    lcd_gotoxy(6,2); 
0BB4:  MOVLW  06
0BB6:  MOVWF  x92
0BB8:  MOVLW  02
0BBA:  MOVWF  x93
0BBC:  RCALL  06DC
....................                    printf(lcd_putc,"*"); 
0BBE:  MOVLW  2A
0BC0:  MOVWF  x91
0BC2:  RCALL  0738
....................                    delay_ms(50); 
0BC4:  MOVLW  32
0BC6:  MOVWF  x92
0BC8:  RCALL  05D0
....................                    break; 
0BCA:  BRA    0C62
....................            
....................                    case 2: 
....................                    lcd_gotoxy(7,1); 
0BCC:  MOVLW  07
0BCE:  MOVWF  x92
0BD0:  MOVLW  01
0BD2:  MOVWF  x93
0BD4:  RCALL  06DC
....................                    lcd_putc(datom); 
0BD6:  MOVFF  72,91
0BDA:  RCALL  0738
....................                   // printf(lcd_putc,datom); 
....................                    clave[1]=datom-0X30; 
0BDC:  MOVLW  30
0BDE:  SUBWF  x72,W
0BE0:  MOVWF  x64
....................                    clave[0]=clave[0]+clave[1]; 
0BE2:  MOVF   x64,W
0BE4:  ADDWF  x63,F
....................                    lcd_gotoxy(7,2); 
0BE6:  MOVLW  07
0BE8:  MOVWF  x92
0BEA:  MOVLW  02
0BEC:  MOVWF  x93
0BEE:  RCALL  06DC
....................                    printf(lcd_putc,"*"); 
0BF0:  MOVLW  2A
0BF2:  MOVWF  x91
0BF4:  RCALL  0738
....................                    delay_ms(50); 
0BF6:  MOVLW  32
0BF8:  MOVWF  x92
0BFA:  RCALL  05D0
....................                    break; 
0BFC:  BRA    0C62
....................               
....................                    case 3: 
....................                    lcd_gotoxy(8,1); 
0BFE:  MOVLW  08
0C00:  MOVWF  x92
0C02:  MOVLW  01
0C04:  MOVWF  x93
0C06:  RCALL  06DC
....................                    lcd_putc(datom); 
0C08:  MOVFF  72,91
0C0C:  RCALL  0738
....................                    //printf(lcd_putc,datom); 
....................                    clave[2]=datom-0X30; 
0C0E:  MOVLW  30
0C10:  SUBWF  x72,W
0C12:  MOVWF  x65
....................                    swap(clave[2]); 
0C14:  SWAPF  x65,F
....................                    lcd_gotoxy(8,2); 
0C16:  MOVLW  08
0C18:  MOVWF  x92
0C1A:  MOVLW  02
0C1C:  MOVWF  x93
0C1E:  RCALL  06DC
....................                    printf(lcd_putc,"*"); 
0C20:  MOVLW  2A
0C22:  MOVWF  x91
0C24:  RCALL  0738
....................                    delay_ms(50); 
0C26:  MOVLW  32
0C28:  MOVWF  x92
0C2A:  RCALL  05D0
....................                    break; 
0C2C:  BRA    0C62
....................               
....................                    case 4: 
....................                    lcd_gotoxy(9,1); 
0C2E:  MOVLW  09
0C30:  MOVWF  x92
0C32:  MOVLW  01
0C34:  MOVWF  x93
0C36:  RCALL  06DC
....................                    lcd_putc(datom); 
0C38:  MOVFF  72,91
0C3C:  RCALL  0738
....................                   // printf(lcd_putc,datom); 
....................                    clave[3]=datom-0X30; 
0C3E:  MOVLW  30
0C40:  SUBWF  x72,W
0C42:  MOVWF  x66
....................                    clave[1]=clave[2]+clave[3]; 
0C44:  MOVF   x66,W
0C46:  ADDWF  x65,W
0C48:  MOVWF  x64
....................                    lcd_gotoxy(9,2); 
0C4A:  MOVLW  09
0C4C:  MOVWF  x92
0C4E:  MOVLW  02
0C50:  MOVWF  x93
0C52:  RCALL  06DC
....................                    printf(lcd_putc,"*"); 
0C54:  MOVLW  2A
0C56:  MOVWF  x91
0C58:  RCALL  0738
....................                    delay_ms(50); 
0C5A:  MOVLW  32
0C5C:  MOVWF  x92
0C5E:  RCALL  05D0
....................                    break; 
0C60:  BRA    0C62
....................                  }  
....................                   i++; 
0C62:  INCF   x60,F
....................                   delay_ms(500); 
0C64:  MOVLW  02
0C66:  MOVWF  x8A
0C68:  MOVLW  FA
0C6A:  MOVWF  x92
0C6C:  RCALL  05D0
0C6E:  DECFSZ x8A,F
0C70:  BRA    0C68
....................                   auxsegundos=0; 
0C72:  CLRF   x7A
0C74:  CLRF   x79
....................                   segundos=0; 
0C76:  CLRF   x78
0C78:  CLRF   x77
....................            } 
....................            auxsegundos++; 
0C7A:  INCF   x79,F
0C7C:  BTFSC  FD8.2
0C7E:  INCF   x7A,F
....................            if(auxsegundos > 20) 
0C80:  MOVF   x7A,F
0C82:  BNZ   0C8A
0C84:  MOVF   x79,W
0C86:  SUBLW  14
0C88:  BC    0C94
....................             { 
....................               segundos++; 
0C8A:  INCF   x77,F
0C8C:  BTFSC  FD8.2
0C8E:  INCF   x78,F
....................               auxsegundos=0; 
0C90:  CLRF   x7A
0C92:  CLRF   x79
....................             } 
....................          
....................       
....................     
....................     }while(i<4 && segundos<6); 
0C94:  MOVF   x60,W
0C96:  SUBLW  03
0C98:  BNC   0CA6
0C9A:  MOVF   x78,F
0C9C:  BNZ   0CA6
0C9E:  MOVF   x77,W
0CA0:  SUBLW  05
0CA2:  BTFSC  FD8.0
0CA4:  BRA    0B78
....................       clave[i]='#'; 
0CA6:  CLRF   03
0CA8:  MOVF   x60,W
0CAA:  ADDLW  63
0CAC:  MOVWF  FE9
0CAE:  MOVLW  00
0CB0:  ADDWFC 03,W
0CB2:  MOVWF  FEA
0CB4:  MOVLW  23
0CB6:  MOVWF  FEF
....................       lcd_gotoxy(b,1); 
0CB8:  MOVFF  61,92
0CBC:  MOVLW  01
0CBE:  MOVWF  x93
0CC0:  RCALL  06DC
....................       printf(lcd_putc,"*") ; 
0CC2:  MOVLW  2A
0CC4:  MOVWF  x91
0CC6:  RCALL  0738
....................       b++; 
0CC8:  INCF   x61,F
....................       auxsegundos=0; 
0CCA:  CLRF   x7A
0CCC:  CLRF   x79
....................       segundos=0; 
0CCE:  CLRF   x78
0CD0:  CLRF   x77
....................    } 
0CD2:  INCF   x60,F
0CD4:  BRA    0B70
.................... } 
0CD6:  RETLW  00
....................  
....................  
.................... void un_digito() 
.................... { lcd_putc('\f'); 
*
0CFA:  MOVLW  0C
0CFC:  MOVWF  x91
0CFE:  RCALL  0738
....................   segundos=0; 
0D00:  CLRF   x78
0D02:  CLRF   x77
....................   auxsegundos=0; 
0D04:  CLRF   x7A
0D06:  CLRF   x79
....................   flag=false; 
0D08:  BCF    0E.1
....................   do{ 
....................       datom=kbd_getc(); 
0D0A:  RCALL  0A44
0D0C:  MOVFF  01,72
....................       delay_ms(60); 
0D10:  MOVLW  3C
0D12:  MOVWF  x92
0D14:  RCALL  05D0
....................       if(datom !='\0') 
0D16:  MOVF   x72,F
0D18:  BZ    0D32
....................         { 
....................           lcd_gotoxy(8,1);  //coloque el numero digitado  en posicion del LCD 
0D1A:  MOVLW  08
0D1C:  MOVWF  x92
0D1E:  MOVLW  01
0D20:  MOVWF  x93
0D22:  RCALL  06DC
....................           lcd_putc(datom); //visualice datom 
0D24:  MOVFF  72,91
0D28:  RCALL  0738
....................           datom=datom-0x30; //quitele ASCII 
0D2A:  MOVLW  30
0D2C:  SUBWF  x72,F
....................           flag=true; 
0D2E:  BSF    0E.1
....................            
....................         }else { 
0D30:  BRA    0D4C
....................                auxsegundos++; 
0D32:  INCF   x79,F
0D34:  BTFSC  FD8.2
0D36:  INCF   x7A,F
....................                if(auxsegundos>20) 
0D38:  MOVF   x7A,F
0D3A:  BNZ   0D42
0D3C:  MOVF   x79,W
0D3E:  SUBLW  14
0D40:  BC    0D4C
....................                { 
....................                  segundos++; 
0D42:  INCF   x77,F
0D44:  BTFSC  FD8.2
0D46:  INCF   x78,F
....................                  auxsegundos=0; 
0D48:  CLRF   x7A
0D4A:  CLRF   x79
....................                 } 
....................        } 
....................          
....................   }while(segundos<6 && flag==false ); 
0D4C:  MOVF   x78,F
0D4E:  BNZ   0D5A
0D50:  MOVF   x77,W
0D52:  SUBLW  05
0D54:  BNC   0D5A
0D56:  BTFSS  0E.1
0D58:  BRA    0D0A
.................... } 
0D5A:  RETLW  00
....................  
.................... void escribir_memoria_ext() 
.................... { 
....................   for(i=0; i<2; i++) 
*
0E50:  CLRF   x60
0E52:  MOVF   x60,W
0E54:  SUBLW  01
0E56:  BNC   0E84
....................   {  write_ext_eeprom(adres, clave[i]); 
0E58:  CLRF   03
0E5A:  MOVF   x60,W
0E5C:  ADDLW  63
0E5E:  MOVWF  FE9
0E60:  MOVLW  00
0E62:  ADDWFC 03,W
0E64:  MOVWF  FEA
0E66:  MOVFF  FEF,8A
0E6A:  CLRF   x8C
0E6C:  MOVFF  6F,8B
0E70:  MOVFF  8A,8D
0E74:  BRA    0D5C
....................      delay_ms(5); 
0E76:  MOVLW  05
0E78:  MOVWF  x92
0E7A:  CALL   05D0
....................      adres++; 
0E7E:  INCF   x6F,F
....................   } 
0E80:  INCF   x60,F
0E82:  BRA    0E52
.................... } 
0E84:  RETLW  00
....................  
....................  
.................... void leer() 
.................... { 
....................   for(i=0; i<4; i++) 
*
07AC:  CLRF   x60
07AE:  MOVF   x60,W
07B0:  SUBLW  03
07B2:  BNC   07E4
....................   { 
....................     datoi[i]=read_eeprom(i); 
07B4:  CLRF   03
07B6:  MOVF   x60,W
07B8:  ADDLW  67
07BA:  MOVWF  FE9
07BC:  MOVLW  00
07BE:  ADDWFC 03,W
07C0:  MOVWF  FEA
07C2:  MOVFF  FF2,8C
07C6:  BCF    FF2.7
07C8:  MOVFF  60,FA9
07CC:  BCF    FA6.6
07CE:  BCF    FA6.7
07D0:  BSF    FA6.0
07D2:  MOVF   FA8,W
07D4:  BTFSC  x8C.7
07D6:  BSF    FF2.7
07D8:  MOVWF  FEF
....................     delay_ms(1); 
07DA:  MOVLW  01
07DC:  MOVWF  x92
07DE:  RCALL  05D0
....................   } 
07E0:  INCF   x60,F
07E2:  BRA    07AE
.................... } 
07E4:  GOTO   15EA (RETURN)
....................  
....................  
.................... void leer_men_ext() 
.................... { 
....................   for(i=0; i<4; i++) 
*
0956:  CLRF   x60
0958:  MOVF   x60,W
095A:  SUBLW  03
095C:  BNC   0990
....................   { 
....................     datoe[i]=read_ext_eeprom(i); 
095E:  CLRF   03
0960:  MOVF   x60,W
0962:  ADDLW  6B
0964:  MOVWF  01
0966:  MOVLW  00
0968:  ADDWFC 03,F
096A:  MOVFF  01,8A
096E:  MOVFF  03,8B
0972:  CLRF   x8D
0974:  MOVFF  60,8C
0978:  BRA    08BC
097A:  MOVFF  8B,FEA
097E:  MOVFF  8A,FE9
0982:  MOVFF  01,FEF
....................     delay_ms(1); 
0986:  MOVLW  01
0988:  MOVWF  x92
098A:  RCALL  05D0
....................    } 
098C:  INCF   x60,F
098E:  BRA    0958
.................... } 
0990:  GOTO   15EE (RETURN)
....................  
.................... void hora_fecha(){ 
....................    //ds1307_get_date(day, mth, year, dow); 
....................    ds1307_get_date(time[3], time[4], time[5], time[6]); 
....................    lcd_putc('\f'); 
*
114E:  MOVLW  0C
1150:  MOVWF  x91
1152:  CALL   0738
....................    lcd_gotoxy(1,1); 
1156:  MOVLW  01
1158:  MOVWF  x92
115A:  MOVWF  x93
115C:  CALL   06DC
....................    printf(lcd_putc,"DATE "); 
1160:  CLRF   x8A
1162:  MOVF   x8A,W
1164:  CALL   0038
1168:  INCF   x8A,F
116A:  MOVWF  00
116C:  MOVWF  x91
116E:  CALL   0738
1172:  MOVLW  05
1174:  SUBWF  x8A,W
1176:  BNZ   1162
....................     
....................    for(i=3;i<6;i++){ 
1178:  MOVLW  03
117A:  MOVWF  x60
117C:  MOVF   x60,W
117E:  SUBLW  05
1180:  BNC   11B2
....................       printf(lcd_putc,"%2d/",time[i]); 
1182:  CLRF   03
1184:  MOVF   x60,W
1186:  ADDLW  82
1188:  MOVWF  FE9
118A:  MOVLW  00
118C:  ADDWFC 03,W
118E:  MOVWF  FEA
1190:  MOVFF  FEF,8A
1194:  MOVFF  8A,8B
1198:  MOVLW  11
119A:  MOVWF  x8C
119C:  RCALL  0FA6
119E:  MOVLW  2F
11A0:  MOVWF  x91
11A2:  CALL   0738
....................       delay_ms(200); 
11A6:  MOVLW  C8
11A8:  MOVWF  x92
11AA:  CALL   05D0
....................        
....................    } 
11AE:  INCF   x60,F
11B0:  BRA    117C
....................    lcd_gotoxy(16,1); 
11B2:  MOVLW  10
11B4:  MOVWF  x92
11B6:  MOVLW  01
11B8:  MOVWF  x93
11BA:  CALL   06DC
....................    lcd_putc("D "); 
11BE:  CLRF   x8A
11C0:  MOVF   x8A,W
11C2:  CALL   004E
11C6:  IORLW  00
11C8:  BZ    11D4
11CA:  INCF   x8A,F
11CC:  MOVWF  x91
11CE:  CALL   0738
11D2:  BRA    11C0
....................     
....................     for(i=0;i<10;i++){ 
11D4:  CLRF   x60
11D6:  MOVF   x60,W
11D8:  SUBLW  09
11DA:  BTFSS  FD8.0
11DC:  BRA    132E
....................          //ds1307_get_time(hour, min, sec); 
....................          ds1307_get_time(time[0],time[1],time[2]); 
....................          lcd_gotoxy(1,2); 
*
12A0:  MOVLW  01
12A2:  MOVWF  x92
12A4:  MOVLW  02
12A6:  MOVWF  x93
12A8:  CALL   06DC
....................          printf(lcd_putc,"HORA:"); 
12AC:  CLRF   x8A
12AE:  MOVF   x8A,W
12B0:  CALL   0062
12B4:  INCF   x8A,F
12B6:  MOVWF  00
12B8:  MOVWF  x91
12BA:  CALL   0738
12BE:  MOVLW  05
12C0:  SUBWF  x8A,W
12C2:  BNZ   12AE
....................     for(i=0;i<3;i++){ 
12C4:  CLRF   x60
12C6:  MOVF   x60,W
12C8:  SUBLW  02
12CA:  BNC   12FC
....................         printf(lcd_putc,"%2d:",time[i]); 
12CC:  CLRF   03
12CE:  MOVF   x60,W
12D0:  ADDLW  82
12D2:  MOVWF  FE9
12D4:  MOVLW  00
12D6:  ADDWFC 03,W
12D8:  MOVWF  FEA
12DA:  MOVFF  FEF,8A
12DE:  MOVFF  8A,8B
12E2:  MOVLW  11
12E4:  MOVWF  x8C
12E6:  RCALL  0FA6
12E8:  MOVLW  3A
12EA:  MOVWF  x91
12EC:  CALL   0738
....................         delay_ms(200); 
12F0:  MOVLW  C8
12F2:  MOVWF  x92
12F4:  CALL   05D0
....................     } 
12F8:  INCF   x60,F
12FA:  BRA    12C6
....................      
....................       lcd_gotoxy(16,2); 
12FC:  MOVLW  10
12FE:  MOVWF  x92
1300:  MOVLW  02
1302:  MOVWF  x93
1304:  CALL   06DC
....................       printf(lcd_putc,"%1d:",time[6]); 
1308:  MOVFF  88,8B
130C:  MOVLW  18
130E:  MOVWF  x8C
1310:  RCALL  0FA6
1312:  MOVLW  3A
1314:  MOVWF  x91
1316:  CALL   0738
....................       //lcd_putc(time[6]); 
....................      delay_ms(995); 
131A:  MOVLW  05
131C:  MOVWF  x8A
131E:  MOVLW  C7
1320:  MOVWF  x92
1322:  CALL   05D0
1326:  DECFSZ x8A,F
1328:  BRA    131E
....................     } 
132A:  INCF   x60,F
132C:  BRA    11D6
....................     
.................... } 
132E:  RETLW  00
....................  
.................... void actualizar(){ 
....................     day=0x1C;    //dia27 
....................     mth=0x09;    //mes 
....................     year=0x15;   //aos21 
....................     dow=0x03;    //dow lun 
....................     hour=0x011;   //hora 7 
....................     min=0x28;    //min   50 
....................     sec=0x00;    //sec 
....................     ds1307_set_date_time(day, mth, year, dow, hour, min,sec); 
....................    } 
....................  
....................  
....................    
.................... /************************** 
.................... PROGRAMA PRINCIPAL 
.................... ************************/   
....................  
.................... void main() 
.................... {#zero_ram 
1330:  CLRF   FF8
1332:  BCF    FD0.7
1334:  MOVLW  FE
1336:  MOVWF  00
1338:  MOVLW  08
133A:  MOVWF  01
133C:  MOVLW  02
133E:  MOVWF  FE9
1340:  MOVLW  00
1342:  MOVWF  FEA
1344:  CLRF   FEE
1346:  DECFSZ 00,F
1348:  BRA    1344
134A:  DECFSZ 01,F
134C:  BRA    1344
134E:  CLRF   FEA
1350:  CLRF   FE9
1352:  MOVF   FC1,W
1354:  ANDLW  C0
1356:  IORLW  0F
1358:  MOVWF  FC1
135A:  MOVLW  07
135C:  MOVWF  FB4
135E:  CLRF   05
1360:  CLRF   06
1362:  CLRF   0D
1364:  BCF    0E.0
1366:  CLRF   0F
1368:  CLRF   10
136A:  MOVLW  4C
136C:  MOVWF  11
136E:  MOVLW  75
1370:  MOVWF  12
1372:  MOVLW  6E
1374:  MOVWF  13
1376:  MOVLW  65
1378:  MOVWF  14
137A:  MOVLW  73
137C:  MOVWF  15
137E:  CLRF   16
1380:  CLRF   17
1382:  CLRF   18
1384:  CLRF   19
1386:  CLRF   1A
1388:  CLRF   1B
138A:  MOVLW  4D
138C:  MOVWF  1C
138E:  MOVLW  61
1390:  MOVWF  1D
1392:  MOVLW  72
1394:  MOVWF  1E
1396:  MOVLW  74
1398:  MOVWF  1F
139A:  MOVLW  65
139C:  MOVWF  20
139E:  MOVLW  73
13A0:  MOVWF  21
13A2:  CLRF   22
13A4:  CLRF   23
13A6:  CLRF   24
13A8:  CLRF   25
13AA:  CLRF   26
13AC:  MOVLW  4D
13AE:  MOVWF  27
13B0:  MOVLW  69
13B2:  MOVWF  28
13B4:  MOVLW  E9
13B6:  MOVWF  29
13B8:  MOVLW  72
13BA:  MOVWF  2A
13BC:  MOVLW  63
13BE:  MOVWF  2B
13C0:  MOVLW  6F
13C2:  MOVWF  2C
13C4:  MOVLW  6C
13C6:  MOVWF  2D
13C8:  MOVLW  65
13CA:  MOVWF  2E
13CC:  MOVLW  73
13CE:  MOVWF  2F
13D0:  CLRF   30
13D2:  CLRF   31
13D4:  MOVLW  4A
13D6:  MOVWF  32
13D8:  MOVLW  75
13DA:  MOVWF  33
13DC:  MOVLW  65
13DE:  MOVWF  34
13E0:  MOVLW  76
13E2:  MOVWF  35
13E4:  MOVLW  65
13E6:  MOVWF  36
13E8:  MOVLW  73
13EA:  MOVWF  37
13EC:  CLRF   38
13EE:  CLRF   39
13F0:  CLRF   3A
13F2:  CLRF   3B
13F4:  CLRF   3C
13F6:  MOVLW  56
13F8:  MOVWF  3D
13FA:  MOVLW  69
13FC:  MOVWF  3E
13FE:  MOVLW  65
1400:  MOVWF  3F
1402:  MOVLW  72
1404:  MOVWF  40
1406:  MOVLW  6E
1408:  MOVWF  41
140A:  MOVLW  65
140C:  MOVWF  42
140E:  MOVLW  73
1410:  MOVWF  43
1412:  CLRF   44
1414:  CLRF   45
1416:  CLRF   46
1418:  CLRF   47
141A:  MOVLW  53
141C:  MOVWF  48
141E:  MOVLW  E1
1420:  MOVWF  49
1422:  MOVLW  62
1424:  MOVWF  4A
1426:  MOVLW  61
1428:  MOVWF  4B
142A:  MOVLW  64
142C:  MOVWF  4C
142E:  MOVLW  6F
1430:  MOVWF  4D
1432:  CLRF   4E
1434:  CLRF   4F
1436:  CLRF   50
1438:  CLRF   51
143A:  CLRF   52
143C:  MOVLW  44
143E:  MOVWF  53
1440:  MOVLW  6F
1442:  MOVWF  54
1444:  MOVLW  6D
1446:  MOVWF  55
1448:  MOVLW  69
144A:  MOVWF  56
144C:  MOVLW  6E
144E:  MOVWF  57
1450:  MOVLW  67
1452:  MOVWF  58
1454:  MOVLW  6F
1456:  MOVWF  59
1458:  CLRF   5A
145A:  CLRF   5B
145C:  CLRF   5E
.................... inicio:                       //etiquetas siempre a la izquierda 
....................     set_tris_A(0x28);         /*0010 1000 EL 28 SALE ES DIVIDIENDO LOS 8BITS EN 4 DIGITOS Y TOMAR A QUE NUMERO CORRESPONCEN 
145E:  MOVLW  28
1460:  MOVWF  F92
....................     RA0 PIN 2  FREE 
....................     RA1 PIN 3  FREE 
....................     RA2 PIN 4  FREE 
....................     RA3 PIN 5  FREE 
....................     RA4 PIN 6  FREE 
....................     RA5 PIN 7  FREE 
....................     RA6 PIN 14 FREE 
....................     RA7 NO EXISTE */ 
....................      
....................     set_tris_B(0x00); /*0000 0000 EL 28 SALE ES DIVIDIENDO LOS 8BITS EN 4 DIGITOS Y TOMAR A QUE NUMERO CORRESPONCEN 
1462:  MOVLW  00
1464:  MOVWF  F93
....................     RB0 PIN 33  LED1 
....................     RB1 PIN 34  LED2 
....................     RB2 PIN 35  LED4 
....................     RB3 PIN 36  LED5 
....................     RB4 PIN 37  LED6 
....................     RB5 PIN 38  LED7 
....................     RB6 PIN 39  LED8 
....................     RB7 PIN 40  LED8 */ 
....................      
....................     set_tris_D(0x00); /*0000 0000 EL 28 SALE ES DIVIDIENDO LOS 8BITS EN 4 DIGITOS Y TOMAR A QUE NUMERO CORRESPONCEN 
1466:  MOVWF  F95
....................     RB0 PIN 33  LED1 
....................     RB1 PIN 34  LED2 
....................     RB2 PIN 35  LED4 
....................     RB3 PIN 36  LED5 
....................     RB4 PIN 37  LED6 
....................     RB5 PIN 38  LED7 
....................     RB6 PIN 39  LED8 
....................     RB7 PIN 40  LED8 */ 
....................      
....................     lcd_init(); 
1468:  GOTO   0678
....................     kbd_init(); 
146C:  GOTO   06D8
....................     output_A(0x00);                            //Limpiar el puerto A 
1470:  CLRF   F92
1472:  CLRF   F89
....................     output_B(0x00);                           //Limipiar el puerto B 
1474:  CLRF   F93
1476:  CLRF   F8A
....................     output_D(0x00);                           //Limipiar el puerto D 
1478:  CLRF   F95
147A:  CLRF   F8C
....................    // actualizar(); 
.................... menu: 
....................      lcd_putc('\f');                            //Limpiar pantalla comando 
147C:  MOVLW  0C
147E:  MOVWF  x91
1480:  CALL   0738
....................      lcd_gotoxy(1,1);                           //escribir en a primera fila primera posicion  
1484:  MOVLW  01
1486:  MOVWF  x92
1488:  MOVWF  x93
148A:  CALL   06DC
....................      lcd_putc("   BIENVENIDOS  ");              //lo que se escribe 
148E:  CLRF   x8A
1490:  MOVF   x8A,W
1492:  CALL   0078
1496:  IORLW  00
1498:  BZ    14A4
149A:  INCF   x8A,F
149C:  MOVWF  x91
149E:  CALL   0738
14A2:  BRA    1490
....................      lcd_gotoxy(1,2);                           //escribir en a primera fila primera posicion  
14A4:  MOVLW  01
14A6:  MOVWF  x92
14A8:  MOVLW  02
14AA:  MOVWF  x93
14AC:  CALL   06DC
....................      lcd_putc("ARQ. COMP. TARDE"); 
14B0:  CLRF   x8A
14B2:  MOVF   x8A,W
14B4:  CALL   009A
14B8:  IORLW  00
14BA:  BZ    14C6
14BC:  INCF   x8A,F
14BE:  MOVWF  x91
14C0:  CALL   0738
14C4:  BRA    14B2
....................      delay_ms(3000); 
14C6:  MOVLW  0C
14C8:  MOVWF  x8A
14CA:  MOVLW  FA
14CC:  MOVWF  x92
14CE:  CALL   05D0
14D2:  DECFSZ x8A,F
14D4:  BRA    14CA
....................     
....................      lcd_putc('\f');                            //Limpiar pantalla comando 
14D6:  MOVLW  0C
14D8:  MOVWF  x91
14DA:  CALL   0738
....................      lcd_gotoxy(1,1);                           //escribir en a primera fila primera posicion  
14DE:  MOVLW  01
14E0:  MOVWF  x92
14E2:  MOVWF  x93
14E4:  CALL   06DC
....................      lcd_putc("MIGUEL MENDEZ");                 //lo que se escribe 
14E8:  CLRF   x8A
14EA:  MOVF   x8A,W
14EC:  CALL   00BC
14F0:  IORLW  00
14F2:  BZ    14FE
14F4:  INCF   x8A,F
14F6:  MOVWF  x91
14F8:  CALL   0738
14FC:  BRA    14EA
....................      lcd_gotoxy(1,2);                           //escribir en a primera fila primera posicion  
14FE:  MOVLW  01
1500:  MOVWF  x92
1502:  MOVLW  02
1504:  MOVWF  x93
1506:  CALL   06DC
....................      lcd_putc(" DAVID MARTINEZ "); 
150A:  CLRF   x8A
150C:  MOVF   x8A,W
150E:  CALL   00DA
1512:  IORLW  00
1514:  BZ    1520
1516:  INCF   x8A,F
1518:  MOVWF  x91
151A:  CALL   0738
151E:  BRA    150C
....................      //printf(lcd_putc,"\f   MIGUEL MENDEZ\n DAVID MARTINEZ ");// /n pase a sigueinet linea 
....................      delay_ms(3000); 
1520:  MOVLW  0C
1522:  MOVWF  x8A
1524:  MOVLW  FA
1526:  MOVWF  x92
1528:  CALL   05D0
152C:  DECFSZ x8A,F
152E:  BRA    1524
....................     
....................      lcd_putc('\f');                           //Limpiar pantalla comando 
1530:  MOVLW  0C
1532:  MOVWF  x91
1534:  CALL   0738
....................      lcd_gotoxy(3,1);                          //escribir en a primera fila primera posicion  
1538:  MOVLW  03
153A:  MOVWF  x92
153C:  MOVLW  01
153E:  MOVWF  x93
1540:  CALL   06DC
....................      lcd_putc("GRUPO");                        //lo que se escribe 
1544:  CLRF   x8A
1546:  MOVF   x8A,W
1548:  CALL   00FC
154C:  IORLW  00
154E:  BZ    155A
1550:  INCF   x8A,F
1552:  MOVWF  x91
1554:  CALL   0738
1558:  BRA    1546
....................      lcd_gotoxy(2,2);                          //escribir en a primera fila primera posicion  
155A:  MOVLW  02
155C:  MOVWF  x92
155E:  MOVWF  x93
1560:  CALL   06DC
....................      lcd_putc(" NUMERO"); 
1564:  CLRF   x8A
1566:  MOVF   x8A,W
1568:  CALL   0112
156C:  IORLW  00
156E:  BZ    157A
1570:  INCF   x8A,F
1572:  MOVWF  x91
1574:  CALL   0738
1578:  BRA    1566
....................      //printf(lcd_putc,"\f        GRUPO   \n       NUMERO    ");// /n pase a sigueinet linea 
....................      delay_ms(3000); 
157A:  MOVLW  0C
157C:  MOVWF  x8A
157E:  MOVLW  FA
1580:  MOVWF  x92
1582:  CALL   05D0
1586:  DECFSZ x8A,F
1588:  BRA    157E
....................     
....................      lcd_putc('\f');                          //Limpiar pantalla comando 
158A:  MOVLW  0C
158C:  MOVWF  x91
158E:  CALL   0738
....................      lcd_gotoxy(2,1);                         //escribir en a primera fila primera posicion  
1592:  MOVLW  02
1594:  MOVWF  x92
1596:  MOVLW  01
1598:  MOVWF  x93
159A:  CALL   06DC
....................      lcd_putc("POR FAVOR");                   //lo que se escribe 
159E:  CLRF   x8A
15A0:  MOVF   x8A,W
15A2:  CALL   012A
15A6:  IORLW  00
15A8:  BZ    15B4
15AA:  INCF   x8A,F
15AC:  MOVWF  x91
15AE:  CALL   0738
15B2:  BRA    15A0
....................      lcd_gotoxy(1,2);                         //escribir en a primera fila primera posicion  
15B4:  MOVLW  01
15B6:  MOVWF  x92
15B8:  MOVLW  02
15BA:  MOVWF  x93
15BC:  CALL   06DC
....................      lcd_putc("INGRESE CLAVE"); 
15C0:  CLRF   x8A
15C2:  MOVF   x8A,W
15C4:  CALL   0144
15C8:  IORLW  00
15CA:  BZ    15D6
15CC:  INCF   x8A,F
15CE:  MOVWF  x91
15D0:  CALL   0738
15D4:  BRA    15C2
....................      //printf(lcd_putc,"\f    POR FAVOR   \n INGRESE CLAVE");// /n pase a sigueinet linea 
....................      delay_ms(3000); 
15D6:  MOVLW  0C
15D8:  MOVWF  x8A
15DA:  MOVLW  FA
15DC:  MOVWF  x92
15DE:  CALL   05D0
15E2:  DECFSZ x8A,F
15E4:  BRA    15DA
....................     
....................     
....................     
....................      leer();                                    //datoi[0]= clave que le demos datoi[1]=clave que le demos 
15E6:  GOTO   07AC
....................      leer_men_ext(); 
15EA:  GOTO   0956
....................      teclado();                                 //clave [0]=0x34, clave[1]=0x78 
15EE:  CALL   0B5C
....................   if(clave[0]==0x12 & clave[1]==0x34) 
15F2:  MOVF   x63,W
15F4:  SUBLW  12
15F6:  BZ    15FC
15F8:  MOVLW  00
15FA:  BRA    15FE
15FC:  MOVLW  01
15FE:  MOVWF  x8A
1600:  MOVF   x64,W
1602:  SUBLW  34
1604:  BZ    160A
1606:  MOVLW  00
1608:  BRA    160C
160A:  MOVLW  01
160C:  ANDWF  x8A,W
160E:  BTFSC  FD8.2
1610:  BRA    17D6
....................    { 
.................... admin:  
....................       lcd_putc('\f');                          //Limpiar pantalla comando 
1612:  MOVLW  0C
1614:  MOVWF  x91
1616:  CALL   0738
....................       lcd_gotoxy(1,1);                         //escribir en a primera fila primera posicion  
161A:  MOVLW  01
161C:  MOVWF  x92
161E:  MOVWF  x93
1620:  CALL   06DC
....................       lcd_putc("BIENVENIDOS AL");              //lo que se escribe 
1624:  CLRF   x8A
1626:  MOVF   x8A,W
1628:  CALL   0162
162C:  IORLW  00
162E:  BZ    163A
1630:  INCF   x8A,F
1632:  MOVWF  x91
1634:  CALL   0738
1638:  BRA    1626
....................       lcd_gotoxy(4,2);                         //escribir en a primera fila primera posicion  
163A:  MOVLW  04
163C:  MOVWF  x92
163E:  MOVLW  02
1640:  MOVWF  x93
1642:  CALL   06DC
....................       lcd_putc(" MENU"); 
1646:  CLRF   x8A
1648:  MOVF   x8A,W
164A:  CALL   0182
164E:  IORLW  00
1650:  BZ    165C
1652:  INCF   x8A,F
1654:  MOVWF  x91
1656:  CALL   0738
165A:  BRA    1648
....................       //printf(lcd_putc,"\f    POR FAVOR   \n INGRESE CLAVE");// /n pase a sigueinet linea 
....................       delay_ms(3000); 
165C:  MOVLW  0C
165E:  MOVWF  x8A
1660:  MOVLW  FA
1662:  MOVWF  x92
1664:  CALL   05D0
1668:  DECFSZ x8A,F
166A:  BRA    1660
....................       
....................       lcd_putc('\f');                         //Limpiar pantalla comando 
166C:  MOVLW  0C
166E:  MOVWF  x91
1670:  CALL   0738
....................       lcd_gotoxy(1,1);                        //escribir en a primera fila primera posicion  
1674:  MOVLW  01
1676:  MOVWF  x92
1678:  MOVWF  x93
167A:  CALL   06DC
....................       lcd_putc("MARQUE 1 PARA EL");           //lo que se escribe 
167E:  CLRF   x8A
1680:  MOVF   x8A,W
1682:  CALL   0198
1686:  IORLW  00
1688:  BZ    1694
168A:  INCF   x8A,F
168C:  MOVWF  x91
168E:  CALL   0738
1692:  BRA    1680
....................       lcd_gotoxy(1,2);                        //escribir en a primera fila primera posicion  
1694:  MOVLW  01
1696:  MOVWF  x92
1698:  MOVLW  02
169A:  MOVWF  x93
169C:  CALL   06DC
....................       lcd_putc("MENU DE DAVID"); 
16A0:  CLRF   x8A
16A2:  MOVF   x8A,W
16A4:  CALL   01BA
16A8:  IORLW  00
16AA:  BZ    16B6
16AC:  INCF   x8A,F
16AE:  MOVWF  x91
16B0:  CALL   0738
16B4:  BRA    16A2
....................       //printf(lcd_putc,"\f    POR FAVOR   \n INGRESE CLAVE");// /n pase a sigueinet linea 
....................       delay_ms(3000); 
16B6:  MOVLW  0C
16B8:  MOVWF  x8A
16BA:  MOVLW  FA
16BC:  MOVWF  x92
16BE:  CALL   05D0
16C2:  DECFSZ x8A,F
16C4:  BRA    16BA
....................     
....................       lcd_putc('\f');                         //Limpiar pantalla comando 
16C6:  MOVLW  0C
16C8:  MOVWF  x91
16CA:  CALL   0738
....................       lcd_gotoxy(1,1);                        //escribir en a primera fila primera posicion  
16CE:  MOVLW  01
16D0:  MOVWF  x92
16D2:  MOVWF  x93
16D4:  CALL   06DC
....................       lcd_putc("MARQUE 2 PARA EL");           //lo que se escribe 
16D8:  CLRF   x8A
16DA:  MOVF   x8A,W
16DC:  CALL   01D8
16E0:  IORLW  00
16E2:  BZ    16EE
16E4:  INCF   x8A,F
16E6:  MOVWF  x91
16E8:  CALL   0738
16EC:  BRA    16DA
....................       lcd_gotoxy(1,2);                        //escribir en a primera fila primera posicion  
16EE:  MOVLW  01
16F0:  MOVWF  x92
16F2:  MOVLW  02
16F4:  MOVWF  x93
16F6:  CALL   06DC
....................       lcd_putc("MENU DE MIGUEL"); 
16FA:  CLRF   x8A
16FC:  MOVF   x8A,W
16FE:  CALL   01FA
1702:  IORLW  00
1704:  BZ    1710
1706:  INCF   x8A,F
1708:  MOVWF  x91
170A:  CALL   0738
170E:  BRA    16FC
....................       //printf(lcd_putc,"\f    POR FAVOR   \n INGRESE CLAVE");// /n pase a sigueinet linea 
....................       delay_ms(3000); 
1710:  MOVLW  0C
1712:  MOVWF  x8A
1714:  MOVLW  FA
1716:  MOVWF  x92
1718:  CALL   05D0
171C:  DECFSZ x8A,F
171E:  BRA    1714
....................      
....................       lcd_putc('\f');                         //Limpiar pantalla comando 
1720:  MOVLW  0C
1722:  MOVWF  x91
1724:  CALL   0738
....................       lcd_gotoxy(1,1);                        //escribir en a primera fila primera posicion  
1728:  MOVLW  01
172A:  MOVWF  x92
172C:  MOVWF  x93
172E:  CALL   06DC
....................       lcd_putc("MARQUE 3 PARA ");             //lo que se escribe 
1732:  CLRF   x8A
1734:  MOVF   x8A,W
1736:  CALL   021A
173A:  IORLW  00
173C:  BZ    1748
173E:  INCF   x8A,F
1740:  MOVWF  x91
1742:  CALL   0738
1746:  BRA    1734
....................       lcd_gotoxy(1,2);                        //escribir en a primera fila primera posicion  
1748:  MOVLW  01
174A:  MOVWF  x92
174C:  MOVLW  02
174E:  MOVWF  x93
1750:  CALL   06DC
....................       lcd_putc("SALIR"); 
1754:  CLRF   x8A
1756:  MOVF   x8A,W
1758:  CALL   023A
175C:  IORLW  00
175E:  BZ    176A
1760:  INCF   x8A,F
1762:  MOVWF  x91
1764:  CALL   0738
1768:  BRA    1756
....................       //printf(lcd_putc,"\f    POR FAVOR   \n INGRESE CLAVE");// /n pase a sigueinet linea 
....................       delay_ms(3000); 
176A:  MOVLW  0C
176C:  MOVWF  x8A
176E:  MOVLW  FA
1770:  MOVWF  x92
1772:  CALL   05D0
1776:  DECFSZ x8A,F
1778:  BRA    176E
....................     
....................     
....................        //bienvenidos al menu del diseador 
....................        //marque 1 para menu de MIGUEL 
....................        //marque 2 para menu de David 
....................        //marque 3 salir  */ 
....................         
....................         
....................      un_digito(); 
177A:  CALL   0CFA
....................     if(datom==0x01) 
177E:  DECFSZ x72,W
1780:  BRA    1786
....................      { 
....................         goto David; 
1782:  GOTO   1EBC
....................      } 
....................      if(datom==0x02) 
1786:  MOVF   x72,W
1788:  SUBLW  02
178A:  BNZ   178E
....................      { 
....................         goto Miguel; 
178C:  BRA    17F6
....................      } 
....................      if(datom==0x03) 
178E:  MOVF   x72,W
1790:  SUBLW  03
1792:  BNZ   1796
....................      { 
....................         reset_cpu();  //salir 
1794:  RESET
....................      } 
....................      lcd_putc('\f');                        //Limpiar pantalla comando 
1796:  MOVLW  0C
1798:  MOVWF  x91
179A:  CALL   0738
....................      lcd_gotoxy(1,2);                       //escribir en a primera fila primera posicion  
179E:  MOVLW  01
17A0:  MOVWF  x92
17A2:  MOVLW  02
17A4:  MOVWF  x93
17A6:  CALL   06DC
....................      lcd_putc("ERROR DE NUMERO");           //lo que se escribe 
17AA:  CLRF   x8A
17AC:  MOVF   x8A,W
17AE:  CALL   0250
17B2:  IORLW  00
17B4:  BZ    17C0
17B6:  INCF   x8A,F
17B8:  MOVWF  x91
17BA:  CALL   0738
17BE:  BRA    17AC
....................      delay_ms(3000); 
17C0:  MOVLW  0C
17C2:  MOVWF  x8A
17C4:  MOVLW  FA
17C6:  MOVWF  x92
17C8:  CALL   05D0
17CC:  DECFSZ x8A,F
17CE:  BRA    17C4
....................      goto admin; 
17D0:  BRA    1612
....................      }  
....................      else if(clave[0]==datoe[0] & clave[1]==datoe[1]) 
17D2:  GOTO   259C
17D6:  MOVF   x6B,W
17D8:  SUBWF  x63,W
17DA:  BZ    17E0
17DC:  MOVLW  00
17DE:  BRA    17E2
17E0:  MOVLW  01
17E2:  MOVWF  x8A
17E4:  MOVF   x6C,W
17E6:  SUBWF  x64,W
17E8:  BZ    17EE
17EA:  MOVLW  00
17EC:  BRA    17F0
17EE:  MOVLW  01
17F0:  ANDWF  x8A,W
17F2:  BTFSC  FD8.2
17F4:  BRA    1E9C
....................       { 
.................... Miguel:adres=0x00; 
17F6:  CLRF   x6F
....................        /*escribirle al lcd 
....................        bienvenidos al menu del diseador 
....................        marque 1 para cambiar clave 
....................        marque 2 para fecha y hora 
....................        marque 3 para reportes 
....................        marque 4 para motor paso a paso 
....................        marque 5 para servomotor 
....................        marque 6 para cad 
....................        marque 7 para DTMF 
....................        marque 8 para sensores 
....................        marque 9 para salir*/ 
....................       
....................     lcd_putc('\f');                       //Limpiar pantalla comando 
17F8:  MOVLW  0C
17FA:  MOVWF  x91
17FC:  CALL   0738
....................     lcd_gotoxy(1,1);                      //escribir en a primera fila primera posicion  
1800:  MOVLW  01
1802:  MOVWF  x92
1804:  MOVWF  x93
1806:  CALL   06DC
....................     lcd_putc("MENU USUAR.");              //lo que se escribe 
180A:  CLRF   x8A
180C:  MOVF   x8A,W
180E:  CALL   0270
1812:  IORLW  00
1814:  BZ    1820
1816:  INCF   x8A,F
1818:  MOVWF  x91
181A:  CALL   0738
181E:  BRA    180C
....................     lcd_gotoxy(1,2);                      //escribir en a primera fila primera posicion  
1820:  MOVLW  01
1822:  MOVWF  x92
1824:  MOVLW  02
1826:  MOVWF  x93
1828:  CALL   06DC
....................     lcd_putc("MIGUEL"); 
182C:  CLRF   x8A
182E:  MOVF   x8A,W
1830:  CALL   028C
1834:  IORLW  00
1836:  BZ    1842
1838:  INCF   x8A,F
183A:  MOVWF  x91
183C:  CALL   0738
1840:  BRA    182E
....................     delay_ms(3000);  
1842:  MOVLW  0C
1844:  MOVWF  x8A
1846:  MOVLW  FA
1848:  MOVWF  x92
184A:  CALL   05D0
184E:  DECFSZ x8A,F
1850:  BRA    1846
....................         
....................     lcd_putc('\f');                       //Limpiar pantalla comando 
1852:  MOVLW  0C
1854:  MOVWF  x91
1856:  CALL   0738
....................     lcd_gotoxy(1,1);                      //escribir en a primera fila primera posicion  
185A:  MOVLW  01
185C:  MOVWF  x92
185E:  MOVWF  x93
1860:  CALL   06DC
....................     lcd_putc("MARQUE NUM PARA");          //lo que se escribe 
1864:  CLRF   x8A
1866:  MOVF   x8A,W
1868:  CALL   02A4
186C:  IORLW  00
186E:  BZ    187A
1870:  INCF   x8A,F
1872:  MOVWF  x91
1874:  CALL   0738
1878:  BRA    1866
....................     lcd_gotoxy(1,2);                      //escribir en a primera fila primera posicion  
187A:  MOVLW  01
187C:  MOVWF  x92
187E:  MOVLW  02
1880:  MOVWF  x93
1882:  CALL   06DC
....................     lcd_putc("1 CAMBIAR CLAVE"); 
1886:  CLRF   x8A
1888:  MOVF   x8A,W
188A:  CALL   02C4
188E:  IORLW  00
1890:  BZ    189C
1892:  INCF   x8A,F
1894:  MOVWF  x91
1896:  CALL   0738
189A:  BRA    1888
....................     delay_ms(3000);   
189C:  MOVLW  0C
189E:  MOVWF  x8A
18A0:  MOVLW  FA
18A2:  MOVWF  x92
18A4:  CALL   05D0
18A8:  DECFSZ x8A,F
18AA:  BRA    18A0
....................      
....................     lcd_putc('\f');                      //Limpiar pantalla comando 
18AC:  MOVLW  0C
18AE:  MOVWF  x91
18B0:  CALL   0738
....................     lcd_gotoxy(1,1);                     //escribir en a primera fila primera posicion  
18B4:  MOVLW  01
18B6:  MOVWF  x92
18B8:  MOVWF  x93
18BA:  CALL   06DC
....................     lcd_putc("2 FECHA Y HORA");          //lo que se escribe 
18BE:  CLRF   x8A
18C0:  MOVF   x8A,W
18C2:  CALL   02E4
18C6:  IORLW  00
18C8:  BZ    18D4
18CA:  INCF   x8A,F
18CC:  MOVWF  x91
18CE:  CALL   0738
18D2:  BRA    18C0
....................     lcd_gotoxy(1,2);                     //escribir en a primera fila primera posicion  
18D4:  MOVLW  01
18D6:  MOVWF  x92
18D8:  MOVLW  02
18DA:  MOVWF  x93
18DC:  CALL   06DC
....................     lcd_putc("3 REPORTES"); 
18E0:  CLRF   x8A
18E2:  MOVF   x8A,W
18E4:  CALL   0304
18E8:  IORLW  00
18EA:  BZ    18F6
18EC:  INCF   x8A,F
18EE:  MOVWF  x91
18F0:  CALL   0738
18F4:  BRA    18E2
....................     delay_ms(3000); 
18F6:  MOVLW  0C
18F8:  MOVWF  x8A
18FA:  MOVLW  FA
18FC:  MOVWF  x92
18FE:  CALL   05D0
1902:  DECFSZ x8A,F
1904:  BRA    18FA
....................      
....................     lcd_putc('\f');                      //Limpiar pantalla comando 
1906:  MOVLW  0C
1908:  MOVWF  x91
190A:  CALL   0738
....................     lcd_gotoxy(1,1);                     //escribir en a primera fila primera posicion  
190E:  MOVLW  01
1910:  MOVWF  x92
1912:  MOVWF  x93
1914:  CALL   06DC
....................     lcd_putc("4 MOTOR PAS A PA");        //lo que se escribe 
1918:  CLRF   x8A
191A:  MOVF   x8A,W
191C:  CALL   0320
1920:  IORLW  00
1922:  BZ    192E
1924:  INCF   x8A,F
1926:  MOVWF  x91
1928:  CALL   0738
192C:  BRA    191A
....................     lcd_gotoxy(1,2);                     //escribir en a primera fila primera posicion  
192E:  MOVLW  01
1930:  MOVWF  x92
1932:  MOVLW  02
1934:  MOVWF  x93
1936:  CALL   06DC
....................     lcd_putc("5 SERVOMOTOR"); 
193A:  CLRF   x8A
193C:  MOVF   x8A,W
193E:  CALL   0342
1942:  IORLW  00
1944:  BZ    1950
1946:  INCF   x8A,F
1948:  MOVWF  x91
194A:  CALL   0738
194E:  BRA    193C
....................     delay_ms(3000); 
1950:  MOVLW  0C
1952:  MOVWF  x8A
1954:  MOVLW  FA
1956:  MOVWF  x92
1958:  CALL   05D0
195C:  DECFSZ x8A,F
195E:  BRA    1954
....................      
....................     lcd_putc('\f');                      //Limpiar pantalla comando 
1960:  MOVLW  0C
1962:  MOVWF  x91
1964:  CALL   0738
....................     lcd_gotoxy(1,1);                     //escribir en a primera fila primera posicion  
1968:  MOVLW  01
196A:  MOVWF  x92
196C:  MOVWF  x93
196E:  CALL   06DC
....................     lcd_putc("6 CAD");                   //lo que se escribe 
1972:  CLRF   x8A
1974:  MOVF   x8A,W
1976:  CALL   0360
197A:  IORLW  00
197C:  BZ    1988
197E:  INCF   x8A,F
1980:  MOVWF  x91
1982:  CALL   0738
1986:  BRA    1974
....................     lcd_gotoxy(1,2);                     //escribir en a primera fila primera posicion  
1988:  MOVLW  01
198A:  MOVWF  x92
198C:  MOVLW  02
198E:  MOVWF  x93
1990:  CALL   06DC
....................     lcd_putc("7 DTMF"); 
1994:  CLRF   x8A
1996:  MOVF   x8A,W
1998:  CALL   0376
199C:  IORLW  00
199E:  BZ    19AA
19A0:  INCF   x8A,F
19A2:  MOVWF  x91
19A4:  CALL   0738
19A8:  BRA    1996
....................     delay_ms(3000); 
19AA:  MOVLW  0C
19AC:  MOVWF  x8A
19AE:  MOVLW  FA
19B0:  MOVWF  x92
19B2:  CALL   05D0
19B6:  DECFSZ x8A,F
19B8:  BRA    19AE
....................      
....................     lcd_putc('\f');                      //Limpiar pantalla comando 
19BA:  MOVLW  0C
19BC:  MOVWF  x91
19BE:  CALL   0738
....................     lcd_gotoxy(1,1);                     //escribir en a primera fila primera posicion  
19C2:  MOVLW  01
19C4:  MOVWF  x92
19C6:  MOVWF  x93
19C8:  CALL   06DC
....................     lcd_putc("8 SENSORES");              //lo que se escribe 
19CC:  CLRF   x8A
19CE:  MOVF   x8A,W
19D0:  CALL   038E
19D4:  IORLW  00
19D6:  BZ    19E2
19D8:  INCF   x8A,F
19DA:  MOVWF  x91
19DC:  CALL   0738
19E0:  BRA    19CE
....................     lcd_gotoxy(3,2);                     //escribir en a primera fila primera posicion  
19E2:  MOVLW  03
19E4:  MOVWF  x92
19E6:  MOVLW  02
19E8:  MOVWF  x93
19EA:  CALL   06DC
....................     lcd_putc("9 SALIR"); 
19EE:  CLRF   x8A
19F0:  MOVF   x8A,W
19F2:  CALL   03AA
19F6:  IORLW  00
19F8:  BZ    1A04
19FA:  INCF   x8A,F
19FC:  MOVWF  x91
19FE:  CALL   0738
1A02:  BRA    19F0
....................     delay_ms(3000); 
1A04:  MOVLW  0C
1A06:  MOVWF  x8A
1A08:  MOVLW  FA
1A0A:  MOVWF  x92
1A0C:  CALL   05D0
1A10:  DECFSZ x8A,F
1A12:  BRA    1A08
....................      
....................     un_digito(); 
1A14:  CALL   0CFA
....................     if(datom==0x01) 
1A18:  DECFSZ x72,W
1A1A:  BRA    1B9C
....................      { 
....................         lcd_putc('\f');                   //Limpiar pantalla comando 
1A1C:  MOVLW  0C
1A1E:  MOVWF  x91
1A20:  CALL   0738
....................         lcd_gotoxy(1,1);                  //escribir en a primera fila primera posicion  
1A24:  MOVLW  01
1A26:  MOVWF  x92
1A28:  MOVWF  x93
1A2A:  CALL   06DC
....................         lcd_putc("MEN CAMBIAR CLAV");     //lo que se escribe 
1A2E:  CLRF   x8A
1A30:  MOVF   x8A,W
1A32:  CALL   03C2
1A36:  IORLW  00
1A38:  BZ    1A44
1A3A:  INCF   x8A,F
1A3C:  MOVWF  x91
1A3E:  CALL   0738
1A42:  BRA    1A30
....................         lcd_gotoxy(3,2);                  //escribir en a primera fila primera posicion  
1A44:  MOVLW  03
1A46:  MOVWF  x92
1A48:  MOVLW  02
1A4A:  MOVWF  x93
1A4C:  CALL   06DC
....................         lcd_putc("DIGITE NU. CLAVE");     //clave[0]= y clave[1]= 
1A50:  CLRF   x8A
1A52:  MOVF   x8A,W
1A54:  CALL   03E4
1A58:  IORLW  00
1A5A:  BZ    1A66
1A5C:  INCF   x8A,F
1A5E:  MOVWF  x91
1A60:  CALL   0738
1A64:  BRA    1A52
....................         delay_ms(3000); 
1A66:  MOVLW  0C
1A68:  MOVWF  x8A
1A6A:  MOVLW  FA
1A6C:  MOVWF  x92
1A6E:  CALL   05D0
1A72:  DECFSZ x8A,F
1A74:  BRA    1A6A
....................         teclado(); 
1A76:  CALL   0B5C
....................         
....................         dato1=clave[0]; 
1A7A:  MOVFF  63,70
....................         dato2=clave[1]; 
1A7E:  MOVFF  64,71
....................         
....................         lcd_putc('\f');                   //Limpiar pantalla comando 
1A82:  MOVLW  0C
1A84:  MOVWF  x91
1A86:  CALL   0738
....................         lcd_gotoxy(1,1);                  //escribir en a primera fila primera posicion  
1A8A:  MOVLW  01
1A8C:  MOVWF  x92
1A8E:  MOVWF  x93
1A90:  CALL   06DC
....................         lcd_putc("POR FAVOR DIGITE");     //lo que se escribe 
1A94:  CLRF   x8A
1A96:  MOVF   x8A,W
1A98:  CALL   0406
1A9C:  IORLW  00
1A9E:  BZ    1AAA
1AA0:  INCF   x8A,F
1AA2:  MOVWF  x91
1AA4:  CALL   0738
1AA8:  BRA    1A96
....................         lcd_gotoxy(1,2);                  //escribir en a primera fila primera posicion  
1AAA:  MOVLW  01
1AAC:  MOVWF  x92
1AAE:  MOVLW  02
1AB0:  MOVWF  x93
1AB2:  CALL   06DC
....................         lcd_putc("DIGITE NUE.CLAVE");    
1AB6:  CLRF   x8A
1AB8:  MOVF   x8A,W
1ABA:  CALL   0428
1ABE:  IORLW  00
1AC0:  BZ    1ACC
1AC2:  INCF   x8A,F
1AC4:  MOVWF  x91
1AC6:  CALL   0738
1ACA:  BRA    1AB8
....................         delay_ms(3000); 
1ACC:  MOVLW  0C
1ACE:  MOVWF  x8A
1AD0:  MOVLW  FA
1AD2:  MOVWF  x92
1AD4:  CALL   05D0
1AD8:  DECFSZ x8A,F
1ADA:  BRA    1AD0
....................         
....................         teclado(); 
1ADC:  CALL   0B5C
....................         
....................        if(clave[0]==dato1 & clave[1]==dato2) 
1AE0:  MOVF   x70,W
1AE2:  SUBWF  x63,W
1AE4:  BZ    1AEA
1AE6:  MOVLW  00
1AE8:  BRA    1AEC
1AEA:  MOVLW  01
1AEC:  MOVWF  x8A
1AEE:  MOVF   x71,W
1AF0:  SUBWF  x64,W
1AF2:  BZ    1AF8
1AF4:  MOVLW  00
1AF6:  BRA    1AFA
1AF8:  MOVLW  01
1AFA:  ANDWF  x8A,W
1AFC:  BZ    1B60
....................        { 
....................          escribir_memoria_ext(); 
1AFE:  CALL   0E50
....................          lcd_putc('\f');                   //Limpiar pantalla comando 
1B02:  MOVLW  0C
1B04:  MOVWF  x91
1B06:  CALL   0738
....................          lcd_gotoxy(1,1);                  //escribir en a primera fila primera posicion  
1B0A:  MOVLW  01
1B0C:  MOVWF  x92
1B0E:  MOVWF  x93
1B10:  CALL   06DC
....................          lcd_putc("CLAVE MODIFICADA");     //lo que se escribe 
1B14:  CLRF   x8A
1B16:  MOVF   x8A,W
1B18:  CALL   044A
1B1C:  IORLW  00
1B1E:  BZ    1B2A
1B20:  INCF   x8A,F
1B22:  MOVWF  x91
1B24:  CALL   0738
1B28:  BRA    1B16
....................          lcd_gotoxy(3,2);                  //escribir en a primera fila primera posicion  
1B2A:  MOVLW  03
1B2C:  MOVWF  x92
1B2E:  MOVLW  02
1B30:  MOVWF  x93
1B32:  CALL   06DC
....................          lcd_putc("CON EXITO");    
1B36:  CLRF   x8A
1B38:  MOVF   x8A,W
1B3A:  CALL   046C
1B3E:  IORLW  00
1B40:  BZ    1B4C
1B42:  INCF   x8A,F
1B44:  MOVWF  x91
1B46:  CALL   0738
1B4A:  BRA    1B38
....................          delay_ms(3000); 
1B4C:  MOVLW  0C
1B4E:  MOVWF  x8A
1B50:  MOVLW  FA
1B52:  MOVWF  x92
1B54:  CALL   05D0
1B58:  DECFSZ x8A,F
1B5A:  BRA    1B50
....................          goto Miguel; 
1B5C:  BRA    17F6
....................        } 
....................        else{ 
1B5E:  BRA    1B9A
....................             lcd_putc('\f');                   //Limpiar pantalla comando 
1B60:  MOVLW  0C
1B62:  MOVWF  x91
1B64:  CALL   0738
....................             lcd_gotoxy(1,1);                  //escribir en a primera fila primera posicion  
1B68:  MOVLW  01
1B6A:  MOVWF  x92
1B6C:  MOVWF  x93
1B6E:  CALL   06DC
....................             lcd_putc("ERROR DE CLAVE");     //lo que se escribe 
1B72:  CLRF   x8A
1B74:  MOVF   x8A,W
1B76:  CALL   0486
1B7A:  IORLW  00
1B7C:  BZ    1B88
1B7E:  INCF   x8A,F
1B80:  MOVWF  x91
1B82:  CALL   0738
1B86:  BRA    1B74
....................             delay_ms(3000); 
1B88:  MOVLW  0C
1B8A:  MOVWF  x8A
1B8C:  MOVLW  FA
1B8E:  MOVWF  x92
1B90:  CALL   05D0
1B94:  DECFSZ x8A,F
1B96:  BRA    1B8C
....................             goto Miguel; 
1B98:  BRA    17F6
....................             } 
....................        
....................        
....................      } 
....................      else if(datom==0x02) 
1B9A:  BRA    1E98
1B9C:  MOVF   x72,W
1B9E:  SUBLW  02
1BA0:  BNZ   1BF2
....................      { 
....................        lcd_putc('\f');                  //Limpiar pantalla comando 
1BA2:  MOVLW  0C
1BA4:  MOVWF  x91
1BA6:  CALL   0738
....................        lcd_gotoxy(1,1);                 //escribir en a primera fila primera posicion  
1BAA:  MOVLW  01
1BAC:  MOVWF  x92
1BAE:  MOVWF  x93
1BB0:  CALL   06DC
....................        lcd_putc("MEN FECHA Y HORA");    //lo que se escribe 
1BB4:  CLRF   x8A
1BB6:  MOVF   x8A,W
1BB8:  CALL   04A6
1BBC:  IORLW  00
1BBE:  BZ    1BCA
1BC0:  INCF   x8A,F
1BC2:  MOVWF  x91
1BC4:  CALL   0738
1BC8:  BRA    1BB6
....................        delay_ms(3000); 
1BCA:  MOVLW  0C
1BCC:  MOVWF  x8A
1BCE:  MOVLW  FA
1BD0:  MOVWF  x92
1BD2:  CALL   05D0
1BD6:  DECFSZ x8A,F
1BD8:  BRA    1BCE
....................        hora_fecha(); 
1BDA:  CALL   1076
....................        delay_ms(10000); 
1BDE:  MOVLW  28
1BE0:  MOVWF  x8A
1BE2:  MOVLW  FA
1BE4:  MOVWF  x92
1BE6:  CALL   05D0
1BEA:  DECFSZ x8A,F
1BEC:  BRA    1BE2
....................        goto Miguel; 
1BEE:  BRA    17F6
....................      } 
....................      else if(datom==0x03) 
1BF0:  BRA    1E98
1BF2:  MOVF   x72,W
1BF4:  SUBLW  03
1BF6:  BNZ   1C56
....................      { 
....................        lcd_putc('\f');                //Limpiar pantalla comando 
1BF8:  MOVLW  0C
1BFA:  MOVWF  x91
1BFC:  CALL   0738
....................        lcd_gotoxy(1,1);               //escribir en a primera fila primera posicion  
1C00:  MOVLW  01
1C02:  MOVWF  x92
1C04:  MOVWF  x93
1C06:  CALL   06DC
....................        lcd_putc("MENU REPORTES");     //lo que se escribe 
1C0A:  CLRF   x8A
1C0C:  MOVF   x8A,W
1C0E:  CALL   04C8
1C12:  IORLW  00
1C14:  BZ    1C20
1C16:  INCF   x8A,F
1C18:  MOVWF  x91
1C1A:  CALL   0738
1C1E:  BRA    1C0C
....................        lcd_gotoxy(3,2);               //escribir en a primera fila primera posicion  
1C20:  MOVLW  03
1C22:  MOVWF  x92
1C24:  MOVLW  02
1C26:  MOVWF  x93
1C28:  CALL   06DC
....................        lcd_putc("EN CONSTRUCCION"); 
1C2C:  CLRF   x8A
1C2E:  MOVF   x8A,W
1C30:  CALL   04E6
1C34:  IORLW  00
1C36:  BZ    1C42
1C38:  INCF   x8A,F
1C3A:  MOVWF  x91
1C3C:  CALL   0738
1C40:  BRA    1C2E
....................        delay_ms(3000); 
1C42:  MOVLW  0C
1C44:  MOVWF  x8A
1C46:  MOVLW  FA
1C48:  MOVWF  x92
1C4A:  CALL   05D0
1C4E:  DECFSZ x8A,F
1C50:  BRA    1C46
....................        goto Miguel; 
1C52:  BRA    17F6
....................      } 
....................      else if(datom==0x04) 
1C54:  BRA    1E98
1C56:  MOVF   x72,W
1C58:  SUBLW  04
1C5A:  BNZ   1CBA
....................      { 
....................        lcd_putc('\f');               //Limpiar pantalla comando 
1C5C:  MOVLW  0C
1C5E:  MOVWF  x91
1C60:  CALL   0738
....................        lcd_gotoxy(1,1);              //escribir en a primera fila primera posicion  
1C64:  MOVLW  01
1C66:  MOVWF  x92
1C68:  MOVWF  x93
1C6A:  CALL   06DC
....................        lcd_putc("MEN MOTOR PAS A."); //lo que se escribe 
1C6E:  CLRF   x8A
1C70:  MOVF   x8A,W
1C72:  CALL   0506
1C76:  IORLW  00
1C78:  BZ    1C84
1C7A:  INCF   x8A,F
1C7C:  MOVWF  x91
1C7E:  CALL   0738
1C82:  BRA    1C70
....................        lcd_gotoxy(3,2);              //escribir en a primera fila primera posicion  
1C84:  MOVLW  03
1C86:  MOVWF  x92
1C88:  MOVLW  02
1C8A:  MOVWF  x93
1C8C:  CALL   06DC
....................        lcd_putc("EN CONSTRUCCION"); 
1C90:  CLRF   x8A
1C92:  MOVF   x8A,W
1C94:  CALL   04E6
1C98:  IORLW  00
1C9A:  BZ    1CA6
1C9C:  INCF   x8A,F
1C9E:  MOVWF  x91
1CA0:  CALL   0738
1CA4:  BRA    1C92
....................        delay_ms(3000); 
1CA6:  MOVLW  0C
1CA8:  MOVWF  x8A
1CAA:  MOVLW  FA
1CAC:  MOVWF  x92
1CAE:  CALL   05D0
1CB2:  DECFSZ x8A,F
1CB4:  BRA    1CAA
....................        goto Miguel; 
1CB6:  BRA    17F6
....................      } 
....................      else if(datom==0x05) 
1CB8:  BRA    1E98
1CBA:  MOVF   x72,W
1CBC:  SUBLW  05
1CBE:  BNZ   1D1E
....................      { 
....................        lcd_putc('\f');              //Limpiar pantalla comando 
1CC0:  MOVLW  0C
1CC2:  MOVWF  x91
1CC4:  CALL   0738
....................        lcd_gotoxy(1,1);             //escribir en a primera fila primera posicion  
1CC8:  MOVLW  01
1CCA:  MOVWF  x92
1CCC:  MOVWF  x93
1CCE:  CALL   06DC
....................        lcd_putc("MEN SERVOMOTOR");  //lo que se escribe 
1CD2:  CLRF   x8A
1CD4:  MOVF   x8A,W
1CD6:  CALL   0528
1CDA:  IORLW  00
1CDC:  BZ    1CE8
1CDE:  INCF   x8A,F
1CE0:  MOVWF  x91
1CE2:  CALL   0738
1CE6:  BRA    1CD4
....................        lcd_gotoxy(3,2);             //escribir en a primera fila primera posicion  
1CE8:  MOVLW  03
1CEA:  MOVWF  x92
1CEC:  MOVLW  02
1CEE:  MOVWF  x93
1CF0:  CALL   06DC
....................        lcd_putc("EN CONSTRUCCION"); 
1CF4:  CLRF   x8A
1CF6:  MOVF   x8A,W
1CF8:  CALL   04E6
1CFC:  IORLW  00
1CFE:  BZ    1D0A
1D00:  INCF   x8A,F
1D02:  MOVWF  x91
1D04:  CALL   0738
1D08:  BRA    1CF6
....................        delay_ms(3000); 
1D0A:  MOVLW  0C
1D0C:  MOVWF  x8A
1D0E:  MOVLW  FA
1D10:  MOVWF  x92
1D12:  CALL   05D0
1D16:  DECFSZ x8A,F
1D18:  BRA    1D0E
....................        goto Miguel; 
1D1A:  BRA    17F6
....................      } 
....................      else if(datom==0x06) 
1D1C:  BRA    1E98
1D1E:  MOVF   x72,W
1D20:  SUBLW  06
1D22:  BNZ   1D82
....................      { 
....................        lcd_putc('\f');               //Limpiar pantalla comando 
1D24:  MOVLW  0C
1D26:  MOVWF  x91
1D28:  CALL   0738
....................        lcd_gotoxy(1,1);              //escribir en a primera fila primera posicion  
1D2C:  MOVLW  01
1D2E:  MOVWF  x92
1D30:  MOVWF  x93
1D32:  CALL   06DC
....................        lcd_putc("MENU CAD");         //lo que se escribe 
1D36:  CLRF   x8A
1D38:  MOVF   x8A,W
1D3A:  CALL   0548
1D3E:  IORLW  00
1D40:  BZ    1D4C
1D42:  INCF   x8A,F
1D44:  MOVWF  x91
1D46:  CALL   0738
1D4A:  BRA    1D38
....................        lcd_gotoxy(3,2);              //escribir en a primera fila primera posicion  
1D4C:  MOVLW  03
1D4E:  MOVWF  x92
1D50:  MOVLW  02
1D52:  MOVWF  x93
1D54:  CALL   06DC
....................        lcd_putc("EN CONSTRUCCION"); 
1D58:  CLRF   x8A
1D5A:  MOVF   x8A,W
1D5C:  CALL   04E6
1D60:  IORLW  00
1D62:  BZ    1D6E
1D64:  INCF   x8A,F
1D66:  MOVWF  x91
1D68:  CALL   0738
1D6C:  BRA    1D5A
....................        delay_ms(3000); 
1D6E:  MOVLW  0C
1D70:  MOVWF  x8A
1D72:  MOVLW  FA
1D74:  MOVWF  x92
1D76:  CALL   05D0
1D7A:  DECFSZ x8A,F
1D7C:  BRA    1D72
....................        goto Miguel; 
1D7E:  BRA    17F6
....................      } 
....................      else if(datom==0x07) 
1D80:  BRA    1E98
1D82:  MOVF   x72,W
1D84:  SUBLW  07
1D86:  BNZ   1DE6
....................      { 
....................        lcd_putc('\f');               //Limpiar pantalla comando 
1D88:  MOVLW  0C
1D8A:  MOVWF  x91
1D8C:  CALL   0738
....................        lcd_gotoxy(1,1);              //escribir en a primera fila primera posicion  
1D90:  MOVLW  01
1D92:  MOVWF  x92
1D94:  MOVWF  x93
1D96:  CALL   06DC
....................        lcd_putc("MEN DTMF");         //lo que se escribe 
1D9A:  CLRF   x8A
1D9C:  MOVF   x8A,W
1D9E:  CALL   0562
1DA2:  IORLW  00
1DA4:  BZ    1DB0
1DA6:  INCF   x8A,F
1DA8:  MOVWF  x91
1DAA:  CALL   0738
1DAE:  BRA    1D9C
....................        lcd_gotoxy(3,2);              //escribir en a primera fila primera posicion  
1DB0:  MOVLW  03
1DB2:  MOVWF  x92
1DB4:  MOVLW  02
1DB6:  MOVWF  x93
1DB8:  CALL   06DC
....................        lcd_putc("EN CONSTRUCCION"); 
1DBC:  CLRF   x8A
1DBE:  MOVF   x8A,W
1DC0:  CALL   04E6
1DC4:  IORLW  00
1DC6:  BZ    1DD2
1DC8:  INCF   x8A,F
1DCA:  MOVWF  x91
1DCC:  CALL   0738
1DD0:  BRA    1DBE
....................        delay_ms(3000); 
1DD2:  MOVLW  0C
1DD4:  MOVWF  x8A
1DD6:  MOVLW  FA
1DD8:  MOVWF  x92
1DDA:  CALL   05D0
1DDE:  DECFSZ x8A,F
1DE0:  BRA    1DD6
....................       goto Miguel; 
1DE2:  BRA    17F6
....................      } 
....................      else if(datom==0x08) 
1DE4:  BRA    1E98
1DE6:  MOVF   x72,W
1DE8:  SUBLW  08
1DEA:  BNZ   1E4A
....................      { 
....................        lcd_putc('\f');              //Limpiar pantalla comando 
1DEC:  MOVLW  0C
1DEE:  MOVWF  x91
1DF0:  CALL   0738
....................        lcd_gotoxy(1,1);             //escribir en a primera fila primera posicion  
1DF4:  MOVLW  01
1DF6:  MOVWF  x92
1DF8:  MOVWF  x93
1DFA:  CALL   06DC
....................        lcd_putc("MEN SENSORES");    //lo que se escribe 
1DFE:  CLRF   x8A
1E00:  MOVF   x8A,W
1E02:  CALL   057C
1E06:  IORLW  00
1E08:  BZ    1E14
1E0A:  INCF   x8A,F
1E0C:  MOVWF  x91
1E0E:  CALL   0738
1E12:  BRA    1E00
....................        lcd_gotoxy(3,2);             //escribir en a primera fila primera posicion  
1E14:  MOVLW  03
1E16:  MOVWF  x92
1E18:  MOVLW  02
1E1A:  MOVWF  x93
1E1C:  CALL   06DC
....................        lcd_putc("EN CONSTRUCCION"); 
1E20:  CLRF   x8A
1E22:  MOVF   x8A,W
1E24:  CALL   04E6
1E28:  IORLW  00
1E2A:  BZ    1E36
1E2C:  INCF   x8A,F
1E2E:  MOVWF  x91
1E30:  CALL   0738
1E34:  BRA    1E22
....................        delay_ms(3000); 
1E36:  MOVLW  0C
1E38:  MOVWF  x8A
1E3A:  MOVLW  FA
1E3C:  MOVWF  x92
1E3E:  CALL   05D0
1E42:  DECFSZ x8A,F
1E44:  BRA    1E3A
....................        goto Miguel; 
1E46:  BRA    17F6
....................      } 
....................      else if(datom==0x09) 
1E48:  BRA    1E98
1E4A:  MOVF   x72,W
1E4C:  SUBLW  09
1E4E:  BNZ   1E56
....................      { 
....................       goto admin; 
1E50:  GOTO   1612
....................      } 
....................      else{ 
1E54:  BRA    1E98
....................           lcd_putc('\f');                 //Limpiar pantalla comando 
1E56:  MOVLW  0C
1E58:  MOVWF  x91
1E5A:  CALL   0738
....................           lcd_gotoxy(1,2);                //escribir en a primera fila primera posicion  
1E5E:  MOVLW  01
1E60:  MOVWF  x92
1E62:  MOVLW  02
1E64:  MOVWF  x93
1E66:  CALL   06DC
....................           lcd_putc("ERROR DE NUMERO");   //lo que se escribe 
1E6A:  CLRF   x8A
1E6C:  MOVF   x8A,W
1E6E:  CALL   0250
1E72:  IORLW  00
1E74:  BZ    1E80
1E76:  INCF   x8A,F
1E78:  MOVWF  x91
1E7A:  CALL   0738
1E7E:  BRA    1E6C
....................           delay_ms(3000); 
1E80:  MOVLW  0C
1E82:  MOVWF  x8A
1E84:  MOVLW  FA
1E86:  MOVWF  x92
1E88:  CALL   05D0
1E8C:  DECFSZ x8A,F
1E8E:  BRA    1E84
....................           goto menu; 
1E90:  GOTO   147C
....................      goto admin; 
1E94:  GOTO   1612
....................      } 
....................      } 
....................    
....................     else if(clave[0]==datoe[2] & clave[1]==datoe[3]) 
1E98:  GOTO   259C
1E9C:  MOVF   x6D,W
1E9E:  SUBWF  x63,W
1EA0:  BZ    1EA6
1EA2:  MOVLW  00
1EA4:  BRA    1EA8
1EA6:  MOVLW  01
1EA8:  MOVWF  x8A
1EAA:  MOVF   x6E,W
1EAC:  SUBWF  x64,W
1EAE:  BZ    1EB4
1EB0:  MOVLW  00
1EB2:  BRA    1EB6
1EB4:  MOVLW  01
1EB6:  ANDWF  x8A,W
1EB8:  BTFSC  FD8.2
1EBA:  BRA    255E
....................     { 
.................... David:adres=0x02; 
1EBC:  MOVLW  02
1EBE:  MOVWF  x6F
....................        /*escribirle al lcd 
....................        bienvenidos al menu del diseador 
....................        marque 1 para cambiar clave 
....................        marque 2 para fecha y hora 
....................        marque 3 para reportes 
....................        marque 4 para motor paso a paso 
....................        marque 5 para servomotor 
....................        marque 6 para cad 
....................        marque 7 para DTMF 
....................        marque 8 para sensores 
....................        marque 9 para salir*/ 
....................       
....................     lcd_putc('\f');                       //Limpiar pantalla comando 
1EC0:  MOVLW  0C
1EC2:  MOVWF  x91
1EC4:  CALL   0738
....................     lcd_gotoxy(1,1);                      //escribir en a primera fila primera posicion  
1EC8:  MOVLW  01
1ECA:  MOVWF  x92
1ECC:  MOVWF  x93
1ECE:  CALL   06DC
....................     lcd_putc("MENU USUAR.");              //lo que se escribe 
1ED2:  CLRF   x8A
1ED4:  MOVF   x8A,W
1ED6:  CALL   0270
1EDA:  IORLW  00
1EDC:  BZ    1EE8
1EDE:  INCF   x8A,F
1EE0:  MOVWF  x91
1EE2:  CALL   0738
1EE6:  BRA    1ED4
....................     lcd_gotoxy(4,2);                      //escribir en a primera fila primera posicion  
1EE8:  MOVLW  04
1EEA:  MOVWF  x92
1EEC:  MOVLW  02
1EEE:  MOVWF  x93
1EF0:  CALL   06DC
....................     lcd_putc("DAVID"); 
1EF4:  CLRF   x8A
1EF6:  MOVF   x8A,W
1EF8:  CALL   059A
1EFC:  IORLW  00
1EFE:  BZ    1F0A
1F00:  INCF   x8A,F
1F02:  MOVWF  x91
1F04:  CALL   0738
1F08:  BRA    1EF6
....................     delay_ms(3000);  
1F0A:  MOVLW  0C
1F0C:  MOVWF  x8A
1F0E:  MOVLW  FA
1F10:  MOVWF  x92
1F12:  CALL   05D0
1F16:  DECFSZ x8A,F
1F18:  BRA    1F0E
....................         
....................     lcd_putc('\f');                       //Limpiar pantalla comando 
1F1A:  MOVLW  0C
1F1C:  MOVWF  x91
1F1E:  CALL   0738
....................     lcd_gotoxy(1,1);                      //escribir en a primera fila primera posicion  
1F22:  MOVLW  01
1F24:  MOVWF  x92
1F26:  MOVWF  x93
1F28:  CALL   06DC
....................     lcd_putc("MARQUE NUM PARA");          //lo que se escribe 
1F2C:  CLRF   x8A
1F2E:  MOVF   x8A,W
1F30:  CALL   02A4
1F34:  IORLW  00
1F36:  BZ    1F42
1F38:  INCF   x8A,F
1F3A:  MOVWF  x91
1F3C:  CALL   0738
1F40:  BRA    1F2E
....................     lcd_gotoxy(1,2);                      //escribir en a primera fila primera posicion  
1F42:  MOVLW  01
1F44:  MOVWF  x92
1F46:  MOVLW  02
1F48:  MOVWF  x93
1F4A:  CALL   06DC
....................     lcd_putc("1 CAMBIAR CLAVE"); 
1F4E:  CLRF   x8A
1F50:  MOVF   x8A,W
1F52:  CALL   02C4
1F56:  IORLW  00
1F58:  BZ    1F64
1F5A:  INCF   x8A,F
1F5C:  MOVWF  x91
1F5E:  CALL   0738
1F62:  BRA    1F50
....................     delay_ms(3000);   
1F64:  MOVLW  0C
1F66:  MOVWF  x8A
1F68:  MOVLW  FA
1F6A:  MOVWF  x92
1F6C:  CALL   05D0
1F70:  DECFSZ x8A,F
1F72:  BRA    1F68
....................      
....................     lcd_putc('\f');                      //Limpiar pantalla comando 
1F74:  MOVLW  0C
1F76:  MOVWF  x91
1F78:  CALL   0738
....................     lcd_gotoxy(1,1);                     //escribir en a primera fila primera posicion  
1F7C:  MOVLW  01
1F7E:  MOVWF  x92
1F80:  MOVWF  x93
1F82:  CALL   06DC
....................     lcd_putc("2 FECHA Y HORA");          //lo que se escribe 
1F86:  CLRF   x8A
1F88:  MOVF   x8A,W
1F8A:  CALL   02E4
1F8E:  IORLW  00
1F90:  BZ    1F9C
1F92:  INCF   x8A,F
1F94:  MOVWF  x91
1F96:  CALL   0738
1F9A:  BRA    1F88
....................     lcd_gotoxy(1,2);                     //escribir en a primera fila primera posicion  
1F9C:  MOVLW  01
1F9E:  MOVWF  x92
1FA0:  MOVLW  02
1FA2:  MOVWF  x93
1FA4:  CALL   06DC
....................     lcd_putc("3 REPORTES"); 
1FA8:  CLRF   x8A
1FAA:  MOVF   x8A,W
1FAC:  CALL   0304
1FB0:  IORLW  00
1FB2:  BZ    1FBE
1FB4:  INCF   x8A,F
1FB6:  MOVWF  x91
1FB8:  CALL   0738
1FBC:  BRA    1FAA
....................     delay_ms(3000); 
1FBE:  MOVLW  0C
1FC0:  MOVWF  x8A
1FC2:  MOVLW  FA
1FC4:  MOVWF  x92
1FC6:  CALL   05D0
1FCA:  DECFSZ x8A,F
1FCC:  BRA    1FC2
....................      
....................     lcd_putc('\f');                     //Limpiar pantalla comando 
1FCE:  MOVLW  0C
1FD0:  MOVWF  x91
1FD2:  CALL   0738
....................     lcd_gotoxy(1,1);                    //escribir en a primera fila primera posicion  
1FD6:  MOVLW  01
1FD8:  MOVWF  x92
1FDA:  MOVWF  x93
1FDC:  CALL   06DC
....................     lcd_putc("4 MOTOR PAS A PA");       //lo que se escribe 
1FE0:  CLRF   x8A
1FE2:  MOVF   x8A,W
1FE4:  CALL   0320
1FE8:  IORLW  00
1FEA:  BZ    1FF6
1FEC:  INCF   x8A,F
1FEE:  MOVWF  x91
1FF0:  CALL   0738
1FF4:  BRA    1FE2
....................     lcd_gotoxy(1,2);                     //escribir en a primera fila primera posicion  
1FF6:  MOVLW  01
1FF8:  MOVWF  x92
1FFA:  MOVLW  02
1FFC:  MOVWF  x93
1FFE:  CALL   06DC
....................     lcd_putc("5 SERVOMOTOR"); 
2002:  CLRF   x8A
2004:  MOVF   x8A,W
2006:  CALL   0342
200A:  IORLW  00
200C:  BZ    2018
200E:  INCF   x8A,F
2010:  MOVWF  x91
2012:  CALL   0738
2016:  BRA    2004
....................     delay_ms(3000); 
2018:  MOVLW  0C
201A:  MOVWF  x8A
201C:  MOVLW  FA
201E:  MOVWF  x92
2020:  CALL   05D0
2024:  DECFSZ x8A,F
2026:  BRA    201C
....................      
....................     lcd_putc('\f');                      //Limpiar pantalla comando 
2028:  MOVLW  0C
202A:  MOVWF  x91
202C:  CALL   0738
....................     lcd_gotoxy(1,1);                     //escribir en a primera fila primera posicion  
2030:  MOVLW  01
2032:  MOVWF  x92
2034:  MOVWF  x93
2036:  CALL   06DC
....................     lcd_putc("6 CAD");                   //lo que se escribe 
203A:  CLRF   x8A
203C:  MOVF   x8A,W
203E:  CALL   0360
2042:  IORLW  00
2044:  BZ    2050
2046:  INCF   x8A,F
2048:  MOVWF  x91
204A:  CALL   0738
204E:  BRA    203C
....................     lcd_gotoxy(1,2);                     //escribir en a primera fila primera posicion  
2050:  MOVLW  01
2052:  MOVWF  x92
2054:  MOVLW  02
2056:  MOVWF  x93
2058:  CALL   06DC
....................     lcd_putc("7 DTMF"); 
205C:  CLRF   x8A
205E:  MOVF   x8A,W
2060:  CALL   0376
2064:  IORLW  00
2066:  BZ    2072
2068:  INCF   x8A,F
206A:  MOVWF  x91
206C:  CALL   0738
2070:  BRA    205E
....................     delay_ms(3000); 
2072:  MOVLW  0C
2074:  MOVWF  x8A
2076:  MOVLW  FA
2078:  MOVWF  x92
207A:  CALL   05D0
207E:  DECFSZ x8A,F
2080:  BRA    2076
....................      
....................     lcd_putc('\f');                      //Limpiar pantalla comando 
2082:  MOVLW  0C
2084:  MOVWF  x91
2086:  CALL   0738
....................     lcd_gotoxy(1,1);                     //escribir en a primera fila primera posicion  
208A:  MOVLW  01
208C:  MOVWF  x92
208E:  MOVWF  x93
2090:  CALL   06DC
....................     lcd_putc("8 SENSORES");              //lo que se escribe 
2094:  CLRF   x8A
2096:  MOVF   x8A,W
2098:  CALL   038E
209C:  IORLW  00
209E:  BZ    20AA
20A0:  INCF   x8A,F
20A2:  MOVWF  x91
20A4:  CALL   0738
20A8:  BRA    2096
....................     lcd_gotoxy(3,2);                     //escribir en a primera fila primera posicion  
20AA:  MOVLW  03
20AC:  MOVWF  x92
20AE:  MOVLW  02
20B0:  MOVWF  x93
20B2:  CALL   06DC
....................     lcd_putc("9 SALIR"); 
20B6:  CLRF   x8A
20B8:  MOVF   x8A,W
20BA:  CALL   03AA
20BE:  IORLW  00
20C0:  BZ    20CC
20C2:  INCF   x8A,F
20C4:  MOVWF  x91
20C6:  CALL   0738
20CA:  BRA    20B8
....................     delay_ms(3000); 
20CC:  MOVLW  0C
20CE:  MOVWF  x8A
20D0:  MOVLW  FA
20D2:  MOVWF  x92
20D4:  CALL   05D0
20D8:  DECFSZ x8A,F
20DA:  BRA    20D0
....................      
....................     un_digito(); 
20DC:  CALL   0CFA
....................     if(datom==0x01) 
20E0:  DECFSZ x72,W
20E2:  BRA    2264
....................      { 
....................        lcd_putc('\f');                   //Limpiar pantalla comando 
20E4:  MOVLW  0C
20E6:  MOVWF  x91
20E8:  CALL   0738
....................        lcd_gotoxy(1,1);                  //escribir en a primera fila primera posicion  
20EC:  MOVLW  01
20EE:  MOVWF  x92
20F0:  MOVWF  x93
20F2:  CALL   06DC
....................        lcd_putc("MEN CAMBIAR CLAV");     //lo que se escribe 
20F6:  CLRF   x8A
20F8:  MOVF   x8A,W
20FA:  CALL   03C2
20FE:  IORLW  00
2100:  BZ    210C
2102:  INCF   x8A,F
2104:  MOVWF  x91
2106:  CALL   0738
210A:  BRA    20F8
....................        lcd_gotoxy(3,2);                  //escribir en a primera fila primera posicion  
210C:  MOVLW  03
210E:  MOVWF  x92
2110:  MOVLW  02
2112:  MOVWF  x93
2114:  CALL   06DC
....................        lcd_putc("DIGITE NU. CLAVE");     //clave[0]= y clave[1]= 
2118:  CLRF   x8A
211A:  MOVF   x8A,W
211C:  CALL   03E4
2120:  IORLW  00
2122:  BZ    212E
2124:  INCF   x8A,F
2126:  MOVWF  x91
2128:  CALL   0738
212C:  BRA    211A
....................        delay_ms(3000); 
212E:  MOVLW  0C
2130:  MOVWF  x8A
2132:  MOVLW  FA
2134:  MOVWF  x92
2136:  CALL   05D0
213A:  DECFSZ x8A,F
213C:  BRA    2132
....................        teclado(); 
213E:  CALL   0B5C
....................         
....................        dato1=clave[0]; 
2142:  MOVFF  63,70
....................        dato2=clave[1]; 
2146:  MOVFF  64,71
....................         
....................        lcd_putc('\f');                   //Limpiar pantalla comando 
214A:  MOVLW  0C
214C:  MOVWF  x91
214E:  CALL   0738
....................        lcd_gotoxy(1,1);                  //escribir en a primera fila primera posicion  
2152:  MOVLW  01
2154:  MOVWF  x92
2156:  MOVWF  x93
2158:  CALL   06DC
....................        lcd_putc("POR FAVOR DIGITE");     //lo que se escribe 
215C:  CLRF   x8A
215E:  MOVF   x8A,W
2160:  CALL   0406
2164:  IORLW  00
2166:  BZ    2172
2168:  INCF   x8A,F
216A:  MOVWF  x91
216C:  CALL   0738
2170:  BRA    215E
....................        lcd_gotoxy(1,2);                  //escribir en a primera fila primera posicion  
2172:  MOVLW  01
2174:  MOVWF  x92
2176:  MOVLW  02
2178:  MOVWF  x93
217A:  CALL   06DC
....................        lcd_putc("DIGITE NUE.CLAVE");    
217E:  CLRF   x8A
2180:  MOVF   x8A,W
2182:  CALL   0428
2186:  IORLW  00
2188:  BZ    2194
218A:  INCF   x8A,F
218C:  MOVWF  x91
218E:  CALL   0738
2192:  BRA    2180
....................        delay_ms(3000); 
2194:  MOVLW  0C
2196:  MOVWF  x8A
2198:  MOVLW  FA
219A:  MOVWF  x92
219C:  CALL   05D0
21A0:  DECFSZ x8A,F
21A2:  BRA    2198
....................         
....................        teclado(); 
21A4:  CALL   0B5C
....................         
....................        if(clave[0]==dato1 & clave[1]==dato2) 
21A8:  MOVF   x70,W
21AA:  SUBWF  x63,W
21AC:  BZ    21B2
21AE:  MOVLW  00
21B0:  BRA    21B4
21B2:  MOVLW  01
21B4:  MOVWF  x8A
21B6:  MOVF   x71,W
21B8:  SUBWF  x64,W
21BA:  BZ    21C0
21BC:  MOVLW  00
21BE:  BRA    21C2
21C0:  MOVLW  01
21C2:  ANDWF  x8A,W
21C4:  BZ    2228
....................        { 
....................         escribir_memoria_ext(); 
21C6:  CALL   0E50
....................         lcd_putc('\f');                   //Limpiar pantalla comando 
21CA:  MOVLW  0C
21CC:  MOVWF  x91
21CE:  CALL   0738
....................         lcd_gotoxy(1,1);                  //escribir en a primera fila primera posicion  
21D2:  MOVLW  01
21D4:  MOVWF  x92
21D6:  MOVWF  x93
21D8:  CALL   06DC
....................         lcd_putc("CLAVE MODIFICADA");     //lo que se escribe 
21DC:  CLRF   x8A
21DE:  MOVF   x8A,W
21E0:  CALL   044A
21E4:  IORLW  00
21E6:  BZ    21F2
21E8:  INCF   x8A,F
21EA:  MOVWF  x91
21EC:  CALL   0738
21F0:  BRA    21DE
....................         lcd_gotoxy(3,2);                  //escribir en a primera fila primera posicion  
21F2:  MOVLW  03
21F4:  MOVWF  x92
21F6:  MOVLW  02
21F8:  MOVWF  x93
21FA:  CALL   06DC
....................         lcd_putc("CON EXITO");    
21FE:  CLRF   x8A
2200:  MOVF   x8A,W
2202:  CALL   046C
2206:  IORLW  00
2208:  BZ    2214
220A:  INCF   x8A,F
220C:  MOVWF  x91
220E:  CALL   0738
2212:  BRA    2200
....................         delay_ms(3000); 
2214:  MOVLW  0C
2216:  MOVWF  x8A
2218:  MOVLW  FA
221A:  MOVWF  x92
221C:  CALL   05D0
2220:  DECFSZ x8A,F
2222:  BRA    2218
....................         goto David; 
2224:  BRA    1EBC
....................        } 
....................        else{ 
2226:  BRA    2262
....................        lcd_putc('\f');                   //Limpiar pantalla comando 
2228:  MOVLW  0C
222A:  MOVWF  x91
222C:  CALL   0738
....................        lcd_gotoxy(1,1);                  //escribir en a primera fila primera posicion  
2230:  MOVLW  01
2232:  MOVWF  x92
2234:  MOVWF  x93
2236:  CALL   06DC
....................        lcd_putc("ERROR DE CLAVE");     //lo que se escribe 
223A:  CLRF   x8A
223C:  MOVF   x8A,W
223E:  CALL   0486
2242:  IORLW  00
2244:  BZ    2250
2246:  INCF   x8A,F
2248:  MOVWF  x91
224A:  CALL   0738
224E:  BRA    223C
....................        delay_ms(3000); 
2250:  MOVLW  0C
2252:  MOVWF  x8A
2254:  MOVLW  FA
2256:  MOVWF  x92
2258:  CALL   05D0
225C:  DECFSZ x8A,F
225E:  BRA    2254
....................        goto David; 
2260:  BRA    1EBC
....................        } 
....................         
....................      } 
....................      else if(datom==0x02) 
2262:  BRA    255C
2264:  MOVF   x72,W
2266:  SUBLW  02
2268:  BNZ   22BA
....................      { 
....................       lcd_putc('\f');                  //Limpiar pantalla comando 
226A:  MOVLW  0C
226C:  MOVWF  x91
226E:  CALL   0738
....................        lcd_gotoxy(1,1);                 //escribir en a primera fila primera posicion  
2272:  MOVLW  01
2274:  MOVWF  x92
2276:  MOVWF  x93
2278:  CALL   06DC
....................        lcd_putc("MEN FECHA Y HORA");    //lo que se escribe 
227C:  CLRF   x8A
227E:  MOVF   x8A,W
2280:  CALL   04A6
2284:  IORLW  00
2286:  BZ    2292
2288:  INCF   x8A,F
228A:  MOVWF  x91
228C:  CALL   0738
2290:  BRA    227E
....................        delay_ms(3000); 
2292:  MOVLW  0C
2294:  MOVWF  x8A
2296:  MOVLW  FA
2298:  MOVWF  x92
229A:  CALL   05D0
229E:  DECFSZ x8A,F
22A0:  BRA    2296
....................        hora_fecha(); 
22A2:  CALL   1076
....................        delay_ms(10000); 
22A6:  MOVLW  28
22A8:  MOVWF  x8A
22AA:  MOVLW  FA
22AC:  MOVWF  x92
22AE:  CALL   05D0
22B2:  DECFSZ x8A,F
22B4:  BRA    22AA
....................        goto David; 
22B6:  BRA    1EBC
....................      } 
....................      else  if(datom==0x03) 
22B8:  BRA    255C
22BA:  MOVF   x72,W
22BC:  SUBLW  03
22BE:  BNZ   231E
....................      { 
....................        lcd_putc('\f');                //Limpiar pantalla comando 
22C0:  MOVLW  0C
22C2:  MOVWF  x91
22C4:  CALL   0738
....................        lcd_gotoxy(1,1);               //escribir en a primera fila primera posicion  
22C8:  MOVLW  01
22CA:  MOVWF  x92
22CC:  MOVWF  x93
22CE:  CALL   06DC
....................        lcd_putc("MENU REPORTES");     //lo que se escribe 
22D2:  CLRF   x8A
22D4:  MOVF   x8A,W
22D6:  CALL   04C8
22DA:  IORLW  00
22DC:  BZ    22E8
22DE:  INCF   x8A,F
22E0:  MOVWF  x91
22E2:  CALL   0738
22E6:  BRA    22D4
....................        lcd_gotoxy(3,2);               //escribir en a primera fila primera posicion  
22E8:  MOVLW  03
22EA:  MOVWF  x92
22EC:  MOVLW  02
22EE:  MOVWF  x93
22F0:  CALL   06DC
....................        lcd_putc("EN CONSTRUCCION"); 
22F4:  CLRF   x8A
22F6:  MOVF   x8A,W
22F8:  CALL   04E6
22FC:  IORLW  00
22FE:  BZ    230A
2300:  INCF   x8A,F
2302:  MOVWF  x91
2304:  CALL   0738
2308:  BRA    22F6
....................        delay_ms(3000); 
230A:  MOVLW  0C
230C:  MOVWF  x8A
230E:  MOVLW  FA
2310:  MOVWF  x92
2312:  CALL   05D0
2316:  DECFSZ x8A,F
2318:  BRA    230E
....................        goto David;; 
231A:  BRA    1EBC
....................      } 
....................      else if(datom==0x04) 
231C:  BRA    255C
231E:  MOVF   x72,W
2320:  SUBLW  04
2322:  BNZ   2382
....................      { 
....................        lcd_putc('\f');               //Limpiar pantalla comando 
2324:  MOVLW  0C
2326:  MOVWF  x91
2328:  CALL   0738
....................        lcd_gotoxy(1,1);              //escribir en a primera fila primera posicion  
232C:  MOVLW  01
232E:  MOVWF  x92
2330:  MOVWF  x93
2332:  CALL   06DC
....................        lcd_putc("MEN MOTOR PAS A."); //lo que se escribe 
2336:  CLRF   x8A
2338:  MOVF   x8A,W
233A:  CALL   0506
233E:  IORLW  00
2340:  BZ    234C
2342:  INCF   x8A,F
2344:  MOVWF  x91
2346:  CALL   0738
234A:  BRA    2338
....................        lcd_gotoxy(3,2);              //escribir en a primera fila primera posicion  
234C:  MOVLW  03
234E:  MOVWF  x92
2350:  MOVLW  02
2352:  MOVWF  x93
2354:  CALL   06DC
....................        lcd_putc("EN CONSTRUCCION"); 
2358:  CLRF   x8A
235A:  MOVF   x8A,W
235C:  CALL   04E6
2360:  IORLW  00
2362:  BZ    236E
2364:  INCF   x8A,F
2366:  MOVWF  x91
2368:  CALL   0738
236C:  BRA    235A
....................        delay_ms(3000); 
236E:  MOVLW  0C
2370:  MOVWF  x8A
2372:  MOVLW  FA
2374:  MOVWF  x92
2376:  CALL   05D0
237A:  DECFSZ x8A,F
237C:  BRA    2372
....................        goto David; 
237E:  BRA    1EBC
....................      } 
....................      else if(datom==0x05) 
2380:  BRA    255C
2382:  MOVF   x72,W
2384:  SUBLW  05
2386:  BNZ   23E6
....................      { 
....................        lcd_putc('\f');              //Limpiar pantalla comando 
2388:  MOVLW  0C
238A:  MOVWF  x91
238C:  CALL   0738
....................        lcd_gotoxy(1,1);             //escribir en a primera fila primera posicion  
2390:  MOVLW  01
2392:  MOVWF  x92
2394:  MOVWF  x93
2396:  CALL   06DC
....................        lcd_putc("MEN SERVOMOTOR");  //lo que se escribe 
239A:  CLRF   x8A
239C:  MOVF   x8A,W
239E:  CALL   0528
23A2:  IORLW  00
23A4:  BZ    23B0
23A6:  INCF   x8A,F
23A8:  MOVWF  x91
23AA:  CALL   0738
23AE:  BRA    239C
....................        lcd_gotoxy(3,2);             //escribir en a primera fila primera posicion  
23B0:  MOVLW  03
23B2:  MOVWF  x92
23B4:  MOVLW  02
23B6:  MOVWF  x93
23B8:  CALL   06DC
....................        lcd_putc("EN CONSTRUCCION"); 
23BC:  CLRF   x8A
23BE:  MOVF   x8A,W
23C0:  CALL   04E6
23C4:  IORLW  00
23C6:  BZ    23D2
23C8:  INCF   x8A,F
23CA:  MOVWF  x91
23CC:  CALL   0738
23D0:  BRA    23BE
....................        delay_ms(3000); 
23D2:  MOVLW  0C
23D4:  MOVWF  x8A
23D6:  MOVLW  FA
23D8:  MOVWF  x92
23DA:  CALL   05D0
23DE:  DECFSZ x8A,F
23E0:  BRA    23D6
....................        goto David; 
23E2:  BRA    1EBC
....................      } 
....................      else if(datom==0x06) 
23E4:  BRA    255C
23E6:  MOVF   x72,W
23E8:  SUBLW  06
23EA:  BNZ   244A
....................      { 
....................        lcd_putc('\f');               //Limpiar pantalla comando 
23EC:  MOVLW  0C
23EE:  MOVWF  x91
23F0:  CALL   0738
....................        lcd_gotoxy(1,1);              //escribir en a primera fila primera posicion  
23F4:  MOVLW  01
23F6:  MOVWF  x92
23F8:  MOVWF  x93
23FA:  CALL   06DC
....................        lcd_putc("MENU CAD");         //lo que se escribe 
23FE:  CLRF   x8A
2400:  MOVF   x8A,W
2402:  CALL   0548
2406:  IORLW  00
2408:  BZ    2414
240A:  INCF   x8A,F
240C:  MOVWF  x91
240E:  CALL   0738
2412:  BRA    2400
....................        lcd_gotoxy(3,2);              //escribir en a primera fila primera posicion  
2414:  MOVLW  03
2416:  MOVWF  x92
2418:  MOVLW  02
241A:  MOVWF  x93
241C:  CALL   06DC
....................        lcd_putc("EN CONSTRUCCION"); 
2420:  CLRF   x8A
2422:  MOVF   x8A,W
2424:  CALL   04E6
2428:  IORLW  00
242A:  BZ    2436
242C:  INCF   x8A,F
242E:  MOVWF  x91
2430:  CALL   0738
2434:  BRA    2422
....................        delay_ms(3000); 
2436:  MOVLW  0C
2438:  MOVWF  x8A
243A:  MOVLW  FA
243C:  MOVWF  x92
243E:  CALL   05D0
2442:  DECFSZ x8A,F
2444:  BRA    243A
....................        goto David; 
2446:  BRA    1EBC
....................      } 
....................      else if(datom==0x07) 
2448:  BRA    255C
244A:  MOVF   x72,W
244C:  SUBLW  07
244E:  BNZ   24AE
....................      { 
....................        lcd_putc('\f');               //Limpiar pantalla comando 
2450:  MOVLW  0C
2452:  MOVWF  x91
2454:  CALL   0738
....................        lcd_gotoxy(1,1);              //escribir en a primera fila primera posicion  
2458:  MOVLW  01
245A:  MOVWF  x92
245C:  MOVWF  x93
245E:  CALL   06DC
....................        lcd_putc("MEN DTMF");         //lo que se escribe 
2462:  CLRF   x8A
2464:  MOVF   x8A,W
2466:  CALL   0562
246A:  IORLW  00
246C:  BZ    2478
246E:  INCF   x8A,F
2470:  MOVWF  x91
2472:  CALL   0738
2476:  BRA    2464
....................        lcd_gotoxy(3,2);              //escribir en a primera fila primera posicion  
2478:  MOVLW  03
247A:  MOVWF  x92
247C:  MOVLW  02
247E:  MOVWF  x93
2480:  CALL   06DC
....................        lcd_putc("EN CONSTRUCCION"); 
2484:  CLRF   x8A
2486:  MOVF   x8A,W
2488:  CALL   04E6
248C:  IORLW  00
248E:  BZ    249A
2490:  INCF   x8A,F
2492:  MOVWF  x91
2494:  CALL   0738
2498:  BRA    2486
....................        delay_ms(3000); 
249A:  MOVLW  0C
249C:  MOVWF  x8A
249E:  MOVLW  FA
24A0:  MOVWF  x92
24A2:  CALL   05D0
24A6:  DECFSZ x8A,F
24A8:  BRA    249E
....................        goto David; 
24AA:  BRA    1EBC
....................      } 
....................      else if(datom==0x08) 
24AC:  BRA    255C
24AE:  MOVF   x72,W
24B0:  SUBLW  08
24B2:  BNZ   2512
....................      { 
....................        lcd_putc('\f');              //Limpiar pantalla comando 
24B4:  MOVLW  0C
24B6:  MOVWF  x91
24B8:  CALL   0738
....................        lcd_gotoxy(1,1);             //escribir en a primera fila primera posicion  
24BC:  MOVLW  01
24BE:  MOVWF  x92
24C0:  MOVWF  x93
24C2:  CALL   06DC
....................        lcd_putc("MEN SENSORES");    //lo que se escribe 
24C6:  CLRF   x8A
24C8:  MOVF   x8A,W
24CA:  CALL   057C
24CE:  IORLW  00
24D0:  BZ    24DC
24D2:  INCF   x8A,F
24D4:  MOVWF  x91
24D6:  CALL   0738
24DA:  BRA    24C8
....................        lcd_gotoxy(3,2);             //escribir en a primera fila primera posicion  
24DC:  MOVLW  03
24DE:  MOVWF  x92
24E0:  MOVLW  02
24E2:  MOVWF  x93
24E4:  CALL   06DC
....................        lcd_putc("EN CONSTRUCCION"); 
24E8:  CLRF   x8A
24EA:  MOVF   x8A,W
24EC:  CALL   04E6
24F0:  IORLW  00
24F2:  BZ    24FE
24F4:  INCF   x8A,F
24F6:  MOVWF  x91
24F8:  CALL   0738
24FC:  BRA    24EA
....................        delay_ms(3000); 
24FE:  MOVLW  0C
2500:  MOVWF  x8A
2502:  MOVLW  FA
2504:  MOVWF  x92
2506:  CALL   05D0
250A:  DECFSZ x8A,F
250C:  BRA    2502
....................        goto David; 
250E:  BRA    1EBC
....................      } 
....................      else if(datom==0x09) 
2510:  BRA    255C
2512:  MOVF   x72,W
2514:  SUBLW  09
2516:  BNZ   251E
....................      { 
....................       goto admin; 
2518:  GOTO   1612
....................      } 
....................      else{ 
251C:  BRA    255C
....................           lcd_putc('\f');                 //Limpiar pantalla comando 
251E:  MOVLW  0C
2520:  MOVWF  x91
2522:  CALL   0738
....................           lcd_gotoxy(1,2);                //escribir en a primera fila primera posicion  
2526:  MOVLW  01
2528:  MOVWF  x92
252A:  MOVLW  02
252C:  MOVWF  x93
252E:  CALL   06DC
....................           lcd_putc("ERROR DE NUMERO");   //lo que se escribe 
2532:  CLRF   x8A
2534:  MOVF   x8A,W
2536:  CALL   0250
253A:  IORLW  00
253C:  BZ    2548
253E:  INCF   x8A,F
2540:  MOVWF  x91
2542:  CALL   0738
2546:  BRA    2534
....................           delay_ms(3000); 
2548:  MOVLW  0C
254A:  MOVWF  x8A
254C:  MOVLW  FA
254E:  MOVWF  x92
2550:  CALL   05D0
2554:  DECFSZ x8A,F
2556:  BRA    254C
....................           goto menu; 
2558:  GOTO   147C
....................       } 
....................      }else{ 
255C:  BRA    259C
....................      lcd_putc('\f');                 //Limpiar pantalla comando 
255E:  MOVLW  0C
2560:  MOVWF  x91
2562:  CALL   0738
....................      lcd_gotoxy(1,2);                //escribir en a primera fila primera posicion  
2566:  MOVLW  01
2568:  MOVWF  x92
256A:  MOVLW  02
256C:  MOVWF  x93
256E:  CALL   06DC
....................      lcd_putc("CONTRA. ERRONEA");   //lo que se escribe 
2572:  CLRF   x8A
2574:  MOVF   x8A,W
2576:  CALL   05B0
257A:  IORLW  00
257C:  BZ    2588
257E:  INCF   x8A,F
2580:  MOVWF  x91
2582:  CALL   0738
2586:  BRA    2574
....................      delay_ms(3000); 
2588:  MOVLW  0C
258A:  MOVWF  x8A
258C:  MOVLW  FA
258E:  MOVWF  x92
2590:  CALL   05D0
2594:  DECFSZ x8A,F
2596:  BRA    258C
....................      goto menu; 
2598:  GOTO   147C
....................      } 
....................    } 
....................     
....................  
259C:  SLEEP 

Configuration Fuses:
   Word  1: 0C00   NOIESO NOFCMEN HS PLL1 CPUDIV1 NOUSBDIV
   Word  2: 1E18   NOBROWNOUT NOWDT BORV20 PUT WDT32768 NOVREGEN
   Word  3: 0300   PBADEN CCP2C1 NOMCLR NOLPT1OSC
   Word  4: 0081   STVREN NODEBUG NOLVP NOXINST NOICPRT
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: E00F   NOWRT NOWRTD NOWRTC NOWRTB
   Word  7: 400F   NOEBTR NOEBTRB

ROM data:
F00000: 23 45 34 56 
